[1 of 3] Compiling T2902_Sum        ( T2902_Sum.hs, T2902_Sum.o )

==================== Cmm produced by new codegen ====================
[section "data" { __stginit_main:T2902_Sum:
 }]



==================== Post CPS Cmm ====================
[section "data" { __stginit_main:T2902_Sum:
 }]



==================== Output Cmm ====================
[section "data" { __stginit_main:T2902_Sum:
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.insert_closure:
         const T2902_Sum.insert_info;
 },
 T2902_Sum.insert_entry() //  []
         { info_tbl: [(cfY,
                       label: T2902_Sum.insert_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cfY:
           _sf2::P32 = P32[(old + 8)];
           goto cfT;
       cfT:
           if (Sp - <highSp> < SpLim) goto cfZ; else goto cg0;
       cfZ:
           R1 = T2902_Sum.insert_closure;
           P32[(old + 8)] = _sf2::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cg0:
           I32[(young<cfV> + 4)] = cfV;
           R1 = _sf2::P32;
           if (R1 & 3 != 0) goto cfV; else goto cfW;
       cfW:
           call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
       cfV:
           _sf3::P32 = R1;
           _sf4::P32 = P32[_sf3::P32 + 3];
           _sf5::P32 = P32[_sf3::P32 + 7];
           _sf6::P32 = P32[_sf3::P32 + 11];
           _sf7::P32 = P32[_sf3::P32 + 15];
           _sf8::P32 = P32[_sf3::P32 + 19];
           _sf9::P32 = P32[_sf3::P32 + 23];
           R1 = _sf4::P32;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cfY:
      _sf2::P32 = P32[(old + 8)];
      goto cfT;
  cfT:
      if (Sp - <highSp> < SpLim) goto cfZ; else goto cg0;
  cfZ:
      R1 = T2902_Sum.insert_closure;
      P32[(old + 8)] = _sf2::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cg0:
      I32[(young<cfV> + 4)] = cfV;
      R1 = _sf2::P32;
      if (R1 & 3 != 0) goto cfV; else goto cfW;
  cfW:
      call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
  cfV:
      _sf3::P32 = R1;
      _sf4::P32 = P32[_sf3::P32 + 3];
      _sf5::P32 = P32[_sf3::P32 + 7];
      _sf6::P32 = P32[_sf3::P32 + 11];
      _sf7::P32 = P32[_sf3::P32 + 15];
      _sf8::P32 = P32[_sf3::P32 + 19];
      _sf9::P32 = P32[_sf3::P32 + 23];
      R1 = _sf4::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cfY:
      _sf2::P32 = P32[(old + 8)];
      goto cfT;
  cfT:
      if (Sp - <highSp> < SpLim) goto cfZ; else goto cg0;
  cfZ:
      R1 = T2902_Sum.insert_closure;
      P32[(old + 8)] = _sf2::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cg0:
      I32[(young<cfV> + 4)] = cfV;
      R1 = _sf2::P32;
      if (R1 & 3 != 0) goto cfV; else goto cfW;
  cfW:
      call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
  cfV:
      _sf3::P32 = R1;
      _sf4::P32 = P32[_sf3::P32 + 3];
      _sf5::P32 = P32[_sf3::P32 + 7];
      _sf6::P32 = P32[_sf3::P32 + 11];
      _sf7::P32 = P32[_sf3::P32 + 15];
      _sf8::P32 = P32[_sf3::P32 + 19];
      _sf9::P32 = P32[_sf3::P32 + 23];
      R1 = _sf4::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cfY:
      _sf2::P32 = P32[(old + 8)];
      goto cfT;
  cfT:
      if (Sp - <highSp> < SpLim) goto cfZ; else goto cg0;
  cfZ:
      R1 = T2902_Sum.insert_closure;
      P32[(old + 8)] = _sf2::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cg0:
      I32[(young<cfV> + 4)] = cfV;
      R1 = _sf2::P32;
      if (R1 & 3 != 0) goto cfV; else goto cfW;
  cfW:
      call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
  cfV:
      _sf3::P32 = R1;
      _sf4::P32 = P32[_sf3::P32 + 3];
      _sf5::P32 = P32[_sf3::P32 + 7];
      _sf6::P32 = P32[_sf3::P32 + 11];
      _sf7::P32 = P32[_sf3::P32 + 15];
      _sf8::P32 = P32[_sf3::P32 + 19];
      _sf9::P32 = P32[_sf3::P32 + 23];
      R1 = _sf4::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cfY:
      _sf2::P32 = P32[Sp];
      goto cfT;
  cfT:
      goto cg0;
  cg0:
      I32[Sp] = cfV;
      R1 = _sf2::P32;
      if (R1 & 3 != 0) goto cfV; else goto cfW;
  cfW:
      call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
  cfV:
      _sf3::P32 = R1;
      _sf4::P32 = P32[_sf3::P32 + 3];
      _sf5::P32 = P32[_sf3::P32 + 7];
      _sf6::P32 = P32[_sf3::P32 + 11];
      _sf7::P32 = P32[_sf3::P32 + 15];
      _sf8::P32 = P32[_sf3::P32 + 19];
      _sf9::P32 = P32[_sf3::P32 + 23];
      R1 = _sf4::P32;
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cfY:
      goto cfT;
  cfT:
      goto cg0;
  cg0:
      _sf2::P32 = P32[Sp];
      I32[Sp] = cfV;
      R1 = _sf2::P32;
      if (R1 & 3 != 0) goto cfV; else goto cfW;
  cfW:
      call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
  cfV:
      R1 = P32[R1 + 3];
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cfT, {}), (cfV, {}), (cfW, {}), (cfY, {}), (cg0, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.insert_entry() //  []
        { info_tbl: [(cfV,
                      label: block_cfV_info
                      rep:StackRep []),
                     (cfY,
                      label: T2902_Sum.insert_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cfY:
          goto cfT;
      cfT:
          goto cg0;
      cg0:
          _sf2::P32 = P32[Sp];
          I32[Sp] = cfV;
          R1 = _sf2::P32;
          if (R1 & 3 != 0) goto cfV; else goto cfW;
      cfW:
          call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
      cfV:
          R1 = P32[R1 + 3];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.insert_entry() //  []
        { info_tbl: [(cfV,
                      label: block_cfV_info
                      rep:StackRep []),
                     (cg0,
                      label: T2902_Sum.insert_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cg0:
          _sf2::P32 = P32[Sp];
          I32[Sp] = cfV;
          R1 = _sf2::P32;
          if (R1 & 3 != 0) goto cfV; else goto cfW;
      cfW:
          call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
      cfV:
          R1 = P32[R1 + 3];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.insert_closure:
         const T2902_Sum.insert_info;
 },
 T2902_Sum.insert_entry() //  []
         { info_tbl: [(cfV,
                       label: block_cfV_info
                       rep:StackRep []),
                      (cg0,
                       label: T2902_Sum.insert_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cg0:
           _sf2::P32 = P32[Sp];
           I32[Sp] = cfV;
           R1 = _sf2::P32;
           if (R1 & 3 != 0) goto cfV; else goto cfW;
       cfW:
           call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
       cfV:
           R1 = P32[R1 + 3];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.insert_closure:
         const T2902_Sum.insert_info;
 },
 T2902_Sum.insert_entry() //  []
         { info_tbl: [(cfV,
                       label: block_cfV_info
                       rep:StackRep []),
                      (cg0,
                       label: T2902_Sum.insert_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cg0:
           _sf2::P32 = P32[Sp];
           I32[Sp] = cfV;
           R1 = _sf2::P32;
           if (R1 & 3 != 0) goto cfV; else goto cfW;
       cfW:
           call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
       cfV:
           R1 = P32[R1 + 3];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.union_closure:
         const T2902_Sum.union_info;
 },
 T2902_Sum.union_entry() //  []
         { info_tbl: [(cgi,
                       label: T2902_Sum.union_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgi:
           _sfa::P32 = P32[(old + 8)];
           goto cgd;
       cgd:
           if (Sp - <highSp> < SpLim) goto cgj; else goto cgk;
       cgj:
           R1 = T2902_Sum.union_closure;
           P32[(old + 8)] = _sfa::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cgk:
           I32[(young<cgf> + 4)] = cgf;
           R1 = _sfa::P32;
           if (R1 & 3 != 0) goto cgf; else goto cgg;
       cgg:
           call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
       cgf:
           _sfb::P32 = R1;
           _sfc::P32 = P32[_sfb::P32 + 3];
           _sfd::P32 = P32[_sfb::P32 + 7];
           _sfe::P32 = P32[_sfb::P32 + 11];
           _sff::P32 = P32[_sfb::P32 + 15];
           _sfg::P32 = P32[_sfb::P32 + 19];
           _sfh::P32 = P32[_sfb::P32 + 23];
           R1 = _sfd::P32;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cgi:
      _sfa::P32 = P32[(old + 8)];
      goto cgd;
  cgd:
      if (Sp - <highSp> < SpLim) goto cgj; else goto cgk;
  cgj:
      R1 = T2902_Sum.union_closure;
      P32[(old + 8)] = _sfa::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgk:
      I32[(young<cgf> + 4)] = cgf;
      R1 = _sfa::P32;
      if (R1 & 3 != 0) goto cgf; else goto cgg;
  cgg:
      call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
  cgf:
      _sfb::P32 = R1;
      _sfc::P32 = P32[_sfb::P32 + 3];
      _sfd::P32 = P32[_sfb::P32 + 7];
      _sfe::P32 = P32[_sfb::P32 + 11];
      _sff::P32 = P32[_sfb::P32 + 15];
      _sfg::P32 = P32[_sfb::P32 + 19];
      _sfh::P32 = P32[_sfb::P32 + 23];
      R1 = _sfd::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cgi:
      _sfa::P32 = P32[(old + 8)];
      goto cgd;
  cgd:
      if (Sp - <highSp> < SpLim) goto cgj; else goto cgk;
  cgj:
      R1 = T2902_Sum.union_closure;
      P32[(old + 8)] = _sfa::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgk:
      I32[(young<cgf> + 4)] = cgf;
      R1 = _sfa::P32;
      if (R1 & 3 != 0) goto cgf; else goto cgg;
  cgg:
      call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
  cgf:
      _sfb::P32 = R1;
      _sfc::P32 = P32[_sfb::P32 + 3];
      _sfd::P32 = P32[_sfb::P32 + 7];
      _sfe::P32 = P32[_sfb::P32 + 11];
      _sff::P32 = P32[_sfb::P32 + 15];
      _sfg::P32 = P32[_sfb::P32 + 19];
      _sfh::P32 = P32[_sfb::P32 + 23];
      R1 = _sfd::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cgi:
      _sfa::P32 = P32[(old + 8)];
      goto cgd;
  cgd:
      if (Sp - <highSp> < SpLim) goto cgj; else goto cgk;
  cgj:
      R1 = T2902_Sum.union_closure;
      P32[(old + 8)] = _sfa::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgk:
      I32[(young<cgf> + 4)] = cgf;
      R1 = _sfa::P32;
      if (R1 & 3 != 0) goto cgf; else goto cgg;
  cgg:
      call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
  cgf:
      _sfb::P32 = R1;
      _sfc::P32 = P32[_sfb::P32 + 3];
      _sfd::P32 = P32[_sfb::P32 + 7];
      _sfe::P32 = P32[_sfb::P32 + 11];
      _sff::P32 = P32[_sfb::P32 + 15];
      _sfg::P32 = P32[_sfb::P32 + 19];
      _sfh::P32 = P32[_sfb::P32 + 23];
      R1 = _sfd::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cgi:
      _sfa::P32 = P32[Sp];
      goto cgd;
  cgd:
      goto cgk;
  cgk:
      I32[Sp] = cgf;
      R1 = _sfa::P32;
      if (R1 & 3 != 0) goto cgf; else goto cgg;
  cgg:
      call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
  cgf:
      _sfb::P32 = R1;
      _sfc::P32 = P32[_sfb::P32 + 3];
      _sfd::P32 = P32[_sfb::P32 + 7];
      _sfe::P32 = P32[_sfb::P32 + 11];
      _sff::P32 = P32[_sfb::P32 + 15];
      _sfg::P32 = P32[_sfb::P32 + 19];
      _sfh::P32 = P32[_sfb::P32 + 23];
      R1 = _sfd::P32;
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cgi:
      goto cgd;
  cgd:
      goto cgk;
  cgk:
      _sfa::P32 = P32[Sp];
      I32[Sp] = cgf;
      R1 = _sfa::P32;
      if (R1 & 3 != 0) goto cgf; else goto cgg;
  cgg:
      call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
  cgf:
      R1 = P32[R1 + 7];
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cgd, {}), (cgf, {}), (cgg, {}), (cgi, {}), (cgk, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.union_entry() //  []
        { info_tbl: [(cgf,
                      label: block_cgf_info
                      rep:StackRep []),
                     (cgi,
                      label: T2902_Sum.union_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cgi:
          goto cgd;
      cgd:
          goto cgk;
      cgk:
          _sfa::P32 = P32[Sp];
          I32[Sp] = cgf;
          R1 = _sfa::P32;
          if (R1 & 3 != 0) goto cgf; else goto cgg;
      cgg:
          call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
      cgf:
          R1 = P32[R1 + 7];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.union_entry() //  []
        { info_tbl: [(cgf,
                      label: block_cgf_info
                      rep:StackRep []),
                     (cgk,
                      label: T2902_Sum.union_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cgk:
          _sfa::P32 = P32[Sp];
          I32[Sp] = cgf;
          R1 = _sfa::P32;
          if (R1 & 3 != 0) goto cgf; else goto cgg;
      cgg:
          call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
      cgf:
          R1 = P32[R1 + 7];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.union_closure:
         const T2902_Sum.union_info;
 },
 T2902_Sum.union_entry() //  []
         { info_tbl: [(cgf,
                       label: block_cgf_info
                       rep:StackRep []),
                      (cgk,
                       label: T2902_Sum.union_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgk:
           _sfa::P32 = P32[Sp];
           I32[Sp] = cgf;
           R1 = _sfa::P32;
           if (R1 & 3 != 0) goto cgf; else goto cgg;
       cgg:
           call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
       cgf:
           R1 = P32[R1 + 7];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.union_closure:
         const T2902_Sum.union_info;
 },
 T2902_Sum.union_entry() //  []
         { info_tbl: [(cgf,
                       label: block_cgf_info
                       rep:StackRep []),
                      (cgk,
                       label: T2902_Sum.union_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgk:
           _sfa::P32 = P32[Sp];
           I32[Sp] = cgf;
           R1 = _sfa::P32;
           if (R1 & 3 != 0) goto cgf; else goto cgg;
       cgg:
           call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
       cgf:
           R1 = P32[R1 + 7];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.unions_closure:
         const T2902_Sum.unions_info;
 },
 T2902_Sum.unions_entry() //  []
         { info_tbl: [(cgC,
                       label: T2902_Sum.unions_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgC:
           _sfi::P32 = P32[(old + 8)];
           goto cgx;
       cgx:
           if (Sp - <highSp> < SpLim) goto cgD; else goto cgE;
       cgD:
           R1 = T2902_Sum.unions_closure;
           P32[(old + 8)] = _sfi::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cgE:
           I32[(young<cgz> + 4)] = cgz;
           R1 = _sfi::P32;
           if (R1 & 3 != 0) goto cgz; else goto cgA;
       cgA:
           call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
       cgz:
           _sfj::P32 = R1;
           _sfk::P32 = P32[_sfj::P32 + 3];
           _sfl::P32 = P32[_sfj::P32 + 7];
           _sfm::P32 = P32[_sfj::P32 + 11];
           _sfn::P32 = P32[_sfj::P32 + 15];
           _sfo::P32 = P32[_sfj::P32 + 19];
           _sfp::P32 = P32[_sfj::P32 + 23];
           R1 = _sfm::P32;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cgC:
      _sfi::P32 = P32[(old + 8)];
      goto cgx;
  cgx:
      if (Sp - <highSp> < SpLim) goto cgD; else goto cgE;
  cgD:
      R1 = T2902_Sum.unions_closure;
      P32[(old + 8)] = _sfi::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgE:
      I32[(young<cgz> + 4)] = cgz;
      R1 = _sfi::P32;
      if (R1 & 3 != 0) goto cgz; else goto cgA;
  cgA:
      call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
  cgz:
      _sfj::P32 = R1;
      _sfk::P32 = P32[_sfj::P32 + 3];
      _sfl::P32 = P32[_sfj::P32 + 7];
      _sfm::P32 = P32[_sfj::P32 + 11];
      _sfn::P32 = P32[_sfj::P32 + 15];
      _sfo::P32 = P32[_sfj::P32 + 19];
      _sfp::P32 = P32[_sfj::P32 + 23];
      R1 = _sfm::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cgC:
      _sfi::P32 = P32[(old + 8)];
      goto cgx;
  cgx:
      if (Sp - <highSp> < SpLim) goto cgD; else goto cgE;
  cgD:
      R1 = T2902_Sum.unions_closure;
      P32[(old + 8)] = _sfi::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgE:
      I32[(young<cgz> + 4)] = cgz;
      R1 = _sfi::P32;
      if (R1 & 3 != 0) goto cgz; else goto cgA;
  cgA:
      call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
  cgz:
      _sfj::P32 = R1;
      _sfk::P32 = P32[_sfj::P32 + 3];
      _sfl::P32 = P32[_sfj::P32 + 7];
      _sfm::P32 = P32[_sfj::P32 + 11];
      _sfn::P32 = P32[_sfj::P32 + 15];
      _sfo::P32 = P32[_sfj::P32 + 19];
      _sfp::P32 = P32[_sfj::P32 + 23];
      R1 = _sfm::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cgC:
      _sfi::P32 = P32[(old + 8)];
      goto cgx;
  cgx:
      if (Sp - <highSp> < SpLim) goto cgD; else goto cgE;
  cgD:
      R1 = T2902_Sum.unions_closure;
      P32[(old + 8)] = _sfi::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgE:
      I32[(young<cgz> + 4)] = cgz;
      R1 = _sfi::P32;
      if (R1 & 3 != 0) goto cgz; else goto cgA;
  cgA:
      call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
  cgz:
      _sfj::P32 = R1;
      _sfk::P32 = P32[_sfj::P32 + 3];
      _sfl::P32 = P32[_sfj::P32 + 7];
      _sfm::P32 = P32[_sfj::P32 + 11];
      _sfn::P32 = P32[_sfj::P32 + 15];
      _sfo::P32 = P32[_sfj::P32 + 19];
      _sfp::P32 = P32[_sfj::P32 + 23];
      R1 = _sfm::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cgC:
      _sfi::P32 = P32[Sp];
      goto cgx;
  cgx:
      goto cgE;
  cgE:
      I32[Sp] = cgz;
      R1 = _sfi::P32;
      if (R1 & 3 != 0) goto cgz; else goto cgA;
  cgA:
      call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
  cgz:
      _sfj::P32 = R1;
      _sfk::P32 = P32[_sfj::P32 + 3];
      _sfl::P32 = P32[_sfj::P32 + 7];
      _sfm::P32 = P32[_sfj::P32 + 11];
      _sfn::P32 = P32[_sfj::P32 + 15];
      _sfo::P32 = P32[_sfj::P32 + 19];
      _sfp::P32 = P32[_sfj::P32 + 23];
      R1 = _sfm::P32;
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cgC:
      goto cgx;
  cgx:
      goto cgE;
  cgE:
      _sfi::P32 = P32[Sp];
      I32[Sp] = cgz;
      R1 = _sfi::P32;
      if (R1 & 3 != 0) goto cgz; else goto cgA;
  cgA:
      call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
  cgz:
      R1 = P32[R1 + 11];
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cgx, {}), (cgz, {}), (cgA, {}), (cgC, {}), (cgE, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.unions_entry() //  []
        { info_tbl: [(cgz,
                      label: block_cgz_info
                      rep:StackRep []),
                     (cgC,
                      label: T2902_Sum.unions_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cgC:
          goto cgx;
      cgx:
          goto cgE;
      cgE:
          _sfi::P32 = P32[Sp];
          I32[Sp] = cgz;
          R1 = _sfi::P32;
          if (R1 & 3 != 0) goto cgz; else goto cgA;
      cgA:
          call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
      cgz:
          R1 = P32[R1 + 11];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.unions_entry() //  []
        { info_tbl: [(cgz,
                      label: block_cgz_info
                      rep:StackRep []),
                     (cgE,
                      label: T2902_Sum.unions_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cgE:
          _sfi::P32 = P32[Sp];
          I32[Sp] = cgz;
          R1 = _sfi::P32;
          if (R1 & 3 != 0) goto cgz; else goto cgA;
      cgA:
          call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
      cgz:
          R1 = P32[R1 + 11];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.unions_closure:
         const T2902_Sum.unions_info;
 },
 T2902_Sum.unions_entry() //  []
         { info_tbl: [(cgz,
                       label: block_cgz_info
                       rep:StackRep []),
                      (cgE,
                       label: T2902_Sum.unions_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgE:
           _sfi::P32 = P32[Sp];
           I32[Sp] = cgz;
           R1 = _sfi::P32;
           if (R1 & 3 != 0) goto cgz; else goto cgA;
       cgA:
           call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
       cgz:
           R1 = P32[R1 + 11];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.unions_closure:
         const T2902_Sum.unions_info;
 },
 T2902_Sum.unions_entry() //  []
         { info_tbl: [(cgz,
                       label: block_cgz_info
                       rep:StackRep []),
                      (cgE,
                       label: T2902_Sum.unions_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgE:
           _sfi::P32 = P32[Sp];
           I32[Sp] = cgz;
           R1 = _sfi::P32;
           if (R1 & 3 != 0) goto cgz; else goto cgA;
       cgA:
           call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
       cgz:
           R1 = P32[R1 + 11];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.extractMin_closure:
         const T2902_Sum.extractMin_info;
 },
 T2902_Sum.extractMin_entry() //  []
         { info_tbl: [(cgW,
                       label: T2902_Sum.extractMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgW:
           _sfq::P32 = P32[(old + 8)];
           goto cgR;
       cgR:
           if (Sp - <highSp> < SpLim) goto cgX; else goto cgY;
       cgX:
           R1 = T2902_Sum.extractMin_closure;
           P32[(old + 8)] = _sfq::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cgY:
           I32[(young<cgT> + 4)] = cgT;
           R1 = _sfq::P32;
           if (R1 & 3 != 0) goto cgT; else goto cgU;
       cgU:
           call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
       cgT:
           _sfr::P32 = R1;
           _sfs::P32 = P32[_sfr::P32 + 3];
           _sft::P32 = P32[_sfr::P32 + 7];
           _sfu::P32 = P32[_sfr::P32 + 11];
           _sfv::P32 = P32[_sfr::P32 + 15];
           _sfw::P32 = P32[_sfr::P32 + 19];
           _sfx::P32 = P32[_sfr::P32 + 23];
           R1 = _sfv::P32;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cgW:
      _sfq::P32 = P32[(old + 8)];
      goto cgR;
  cgR:
      if (Sp - <highSp> < SpLim) goto cgX; else goto cgY;
  cgX:
      R1 = T2902_Sum.extractMin_closure;
      P32[(old + 8)] = _sfq::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgY:
      I32[(young<cgT> + 4)] = cgT;
      R1 = _sfq::P32;
      if (R1 & 3 != 0) goto cgT; else goto cgU;
  cgU:
      call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
  cgT:
      _sfr::P32 = R1;
      _sfs::P32 = P32[_sfr::P32 + 3];
      _sft::P32 = P32[_sfr::P32 + 7];
      _sfu::P32 = P32[_sfr::P32 + 11];
      _sfv::P32 = P32[_sfr::P32 + 15];
      _sfw::P32 = P32[_sfr::P32 + 19];
      _sfx::P32 = P32[_sfr::P32 + 23];
      R1 = _sfv::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cgW:
      _sfq::P32 = P32[(old + 8)];
      goto cgR;
  cgR:
      if (Sp - <highSp> < SpLim) goto cgX; else goto cgY;
  cgX:
      R1 = T2902_Sum.extractMin_closure;
      P32[(old + 8)] = _sfq::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgY:
      I32[(young<cgT> + 4)] = cgT;
      R1 = _sfq::P32;
      if (R1 & 3 != 0) goto cgT; else goto cgU;
  cgU:
      call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
  cgT:
      _sfr::P32 = R1;
      _sfs::P32 = P32[_sfr::P32 + 3];
      _sft::P32 = P32[_sfr::P32 + 7];
      _sfu::P32 = P32[_sfr::P32 + 11];
      _sfv::P32 = P32[_sfr::P32 + 15];
      _sfw::P32 = P32[_sfr::P32 + 19];
      _sfx::P32 = P32[_sfr::P32 + 23];
      R1 = _sfv::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cgW:
      _sfq::P32 = P32[(old + 8)];
      goto cgR;
  cgR:
      if (Sp - <highSp> < SpLim) goto cgX; else goto cgY;
  cgX:
      R1 = T2902_Sum.extractMin_closure;
      P32[(old + 8)] = _sfq::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgY:
      I32[(young<cgT> + 4)] = cgT;
      R1 = _sfq::P32;
      if (R1 & 3 != 0) goto cgT; else goto cgU;
  cgU:
      call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
  cgT:
      _sfr::P32 = R1;
      _sfs::P32 = P32[_sfr::P32 + 3];
      _sft::P32 = P32[_sfr::P32 + 7];
      _sfu::P32 = P32[_sfr::P32 + 11];
      _sfv::P32 = P32[_sfr::P32 + 15];
      _sfw::P32 = P32[_sfr::P32 + 19];
      _sfx::P32 = P32[_sfr::P32 + 23];
      R1 = _sfv::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cgW:
      _sfq::P32 = P32[Sp];
      goto cgR;
  cgR:
      goto cgY;
  cgY:
      I32[Sp] = cgT;
      R1 = _sfq::P32;
      if (R1 & 3 != 0) goto cgT; else goto cgU;
  cgU:
      call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
  cgT:
      _sfr::P32 = R1;
      _sfs::P32 = P32[_sfr::P32 + 3];
      _sft::P32 = P32[_sfr::P32 + 7];
      _sfu::P32 = P32[_sfr::P32 + 11];
      _sfv::P32 = P32[_sfr::P32 + 15];
      _sfw::P32 = P32[_sfr::P32 + 19];
      _sfx::P32 = P32[_sfr::P32 + 23];
      R1 = _sfv::P32;
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cgW:
      goto cgR;
  cgR:
      goto cgY;
  cgY:
      _sfq::P32 = P32[Sp];
      I32[Sp] = cgT;
      R1 = _sfq::P32;
      if (R1 & 3 != 0) goto cgT; else goto cgU;
  cgU:
      call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
  cgT:
      R1 = P32[R1 + 15];
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cgR, {}), (cgT, {}), (cgU, {}), (cgW, {}), (cgY, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.extractMin_entry() //  []
        { info_tbl: [(cgT,
                      label: block_cgT_info
                      rep:StackRep []),
                     (cgW,
                      label: T2902_Sum.extractMin_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cgW:
          goto cgR;
      cgR:
          goto cgY;
      cgY:
          _sfq::P32 = P32[Sp];
          I32[Sp] = cgT;
          R1 = _sfq::P32;
          if (R1 & 3 != 0) goto cgT; else goto cgU;
      cgU:
          call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
      cgT:
          R1 = P32[R1 + 15];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.extractMin_entry() //  []
        { info_tbl: [(cgT,
                      label: block_cgT_info
                      rep:StackRep []),
                     (cgY,
                      label: T2902_Sum.extractMin_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cgY:
          _sfq::P32 = P32[Sp];
          I32[Sp] = cgT;
          R1 = _sfq::P32;
          if (R1 & 3 != 0) goto cgT; else goto cgU;
      cgU:
          call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
      cgT:
          R1 = P32[R1 + 15];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.extractMin_closure:
         const T2902_Sum.extractMin_info;
 },
 T2902_Sum.extractMin_entry() //  []
         { info_tbl: [(cgT,
                       label: block_cgT_info
                       rep:StackRep []),
                      (cgY,
                       label: T2902_Sum.extractMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgY:
           _sfq::P32 = P32[Sp];
           I32[Sp] = cgT;
           R1 = _sfq::P32;
           if (R1 & 3 != 0) goto cgT; else goto cgU;
       cgU:
           call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
       cgT:
           R1 = P32[R1 + 15];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.extractMin_closure:
         const T2902_Sum.extractMin_info;
 },
 T2902_Sum.extractMin_entry() //  []
         { info_tbl: [(cgT,
                       label: block_cgT_info
                       rep:StackRep []),
                      (cgY,
                       label: T2902_Sum.extractMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgY:
           _sfq::P32 = P32[Sp];
           I32[Sp] = cgT;
           R1 = _sfq::P32;
           if (R1 & 3 != 0) goto cgT; else goto cgU;
       cgU:
           call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
       cgT:
           R1 = P32[R1 + 15];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.fromList_closure:
         const T2902_Sum.fromList_info;
 },
 T2902_Sum.fromList_entry() //  []
         { info_tbl: [(chg,
                       label: T2902_Sum.fromList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       chg:
           _sfy::P32 = P32[(old + 8)];
           goto chb;
       chb:
           if (Sp - <highSp> < SpLim) goto chh; else goto chi;
       chh:
           R1 = T2902_Sum.fromList_closure;
           P32[(old + 8)] = _sfy::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       chi:
           I32[(young<chd> + 4)] = chd;
           R1 = _sfy::P32;
           if (R1 & 3 != 0) goto chd; else goto che;
       che:
           call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
       chd:
           _sfz::P32 = R1;
           _sfA::P32 = P32[_sfz::P32 + 3];
           _sfB::P32 = P32[_sfz::P32 + 7];
           _sfC::P32 = P32[_sfz::P32 + 11];
           _sfD::P32 = P32[_sfz::P32 + 15];
           _sfE::P32 = P32[_sfz::P32 + 19];
           _sfF::P32 = P32[_sfz::P32 + 23];
           R1 = _sfE::P32;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  chg:
      _sfy::P32 = P32[(old + 8)];
      goto chb;
  chb:
      if (Sp - <highSp> < SpLim) goto chh; else goto chi;
  chh:
      R1 = T2902_Sum.fromList_closure;
      P32[(old + 8)] = _sfy::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chi:
      I32[(young<chd> + 4)] = chd;
      R1 = _sfy::P32;
      if (R1 & 3 != 0) goto chd; else goto che;
  che:
      call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
  chd:
      _sfz::P32 = R1;
      _sfA::P32 = P32[_sfz::P32 + 3];
      _sfB::P32 = P32[_sfz::P32 + 7];
      _sfC::P32 = P32[_sfz::P32 + 11];
      _sfD::P32 = P32[_sfz::P32 + 15];
      _sfE::P32 = P32[_sfz::P32 + 19];
      _sfF::P32 = P32[_sfz::P32 + 23];
      R1 = _sfE::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  chg:
      _sfy::P32 = P32[(old + 8)];
      goto chb;
  chb:
      if (Sp - <highSp> < SpLim) goto chh; else goto chi;
  chh:
      R1 = T2902_Sum.fromList_closure;
      P32[(old + 8)] = _sfy::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chi:
      I32[(young<chd> + 4)] = chd;
      R1 = _sfy::P32;
      if (R1 & 3 != 0) goto chd; else goto che;
  che:
      call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
  chd:
      _sfz::P32 = R1;
      _sfA::P32 = P32[_sfz::P32 + 3];
      _sfB::P32 = P32[_sfz::P32 + 7];
      _sfC::P32 = P32[_sfz::P32 + 11];
      _sfD::P32 = P32[_sfz::P32 + 15];
      _sfE::P32 = P32[_sfz::P32 + 19];
      _sfF::P32 = P32[_sfz::P32 + 23];
      R1 = _sfE::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  chg:
      _sfy::P32 = P32[(old + 8)];
      goto chb;
  chb:
      if (Sp - <highSp> < SpLim) goto chh; else goto chi;
  chh:
      R1 = T2902_Sum.fromList_closure;
      P32[(old + 8)] = _sfy::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chi:
      I32[(young<chd> + 4)] = chd;
      R1 = _sfy::P32;
      if (R1 & 3 != 0) goto chd; else goto che;
  che:
      call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
  chd:
      _sfz::P32 = R1;
      _sfA::P32 = P32[_sfz::P32 + 3];
      _sfB::P32 = P32[_sfz::P32 + 7];
      _sfC::P32 = P32[_sfz::P32 + 11];
      _sfD::P32 = P32[_sfz::P32 + 15];
      _sfE::P32 = P32[_sfz::P32 + 19];
      _sfF::P32 = P32[_sfz::P32 + 23];
      R1 = _sfE::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  chg:
      _sfy::P32 = P32[Sp];
      goto chb;
  chb:
      goto chi;
  chi:
      I32[Sp] = chd;
      R1 = _sfy::P32;
      if (R1 & 3 != 0) goto chd; else goto che;
  che:
      call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
  chd:
      _sfz::P32 = R1;
      _sfA::P32 = P32[_sfz::P32 + 3];
      _sfB::P32 = P32[_sfz::P32 + 7];
      _sfC::P32 = P32[_sfz::P32 + 11];
      _sfD::P32 = P32[_sfz::P32 + 15];
      _sfE::P32 = P32[_sfz::P32 + 19];
      _sfF::P32 = P32[_sfz::P32 + 23];
      R1 = _sfE::P32;
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  chg:
      goto chb;
  chb:
      goto chi;
  chi:
      _sfy::P32 = P32[Sp];
      I32[Sp] = chd;
      R1 = _sfy::P32;
      if (R1 & 3 != 0) goto chd; else goto che;
  che:
      call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
  chd:
      R1 = P32[R1 + 19];
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(chb, {}), (chd, {}), (che, {}), (chg, {}), (chi, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.fromList_entry() //  []
        { info_tbl: [(chd,
                      label: block_chd_info
                      rep:StackRep []),
                     (chg,
                      label: T2902_Sum.fromList_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      chg:
          goto chb;
      chb:
          goto chi;
      chi:
          _sfy::P32 = P32[Sp];
          I32[Sp] = chd;
          R1 = _sfy::P32;
          if (R1 & 3 != 0) goto chd; else goto che;
      che:
          call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
      chd:
          R1 = P32[R1 + 19];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.fromList_entry() //  []
        { info_tbl: [(chd,
                      label: block_chd_info
                      rep:StackRep []),
                     (chi,
                      label: T2902_Sum.fromList_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      chi:
          _sfy::P32 = P32[Sp];
          I32[Sp] = chd;
          R1 = _sfy::P32;
          if (R1 & 3 != 0) goto chd; else goto che;
      che:
          call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
      chd:
          R1 = P32[R1 + 19];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.fromList_closure:
         const T2902_Sum.fromList_info;
 },
 T2902_Sum.fromList_entry() //  []
         { info_tbl: [(chd,
                       label: block_chd_info
                       rep:StackRep []),
                      (chi,
                       label: T2902_Sum.fromList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       chi:
           _sfy::P32 = P32[Sp];
           I32[Sp] = chd;
           R1 = _sfy::P32;
           if (R1 & 3 != 0) goto chd; else goto che;
       che:
           call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
       chd:
           R1 = P32[R1 + 19];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.fromList_closure:
         const T2902_Sum.fromList_info;
 },
 T2902_Sum.fromList_entry() //  []
         { info_tbl: [(chd,
                       label: block_chd_info
                       rep:StackRep []),
                      (chi,
                       label: T2902_Sum.fromList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       chi:
           _sfy::P32 = P32[Sp];
           I32[Sp] = chd;
           R1 = _sfy::P32;
           if (R1 & 3 != 0) goto chd; else goto che;
       che:
           call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
       chd:
           R1 = P32[R1 + 19];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.toList_closure:
         const T2902_Sum.toList_info;
 },
 T2902_Sum.toList_entry() //  []
         { info_tbl: [(chA,
                       label: T2902_Sum.toList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       chA:
           _sfG::P32 = P32[(old + 8)];
           goto chv;
       chv:
           if (Sp - <highSp> < SpLim) goto chB; else goto chC;
       chB:
           R1 = T2902_Sum.toList_closure;
           P32[(old + 8)] = _sfG::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       chC:
           I32[(young<chx> + 4)] = chx;
           R1 = _sfG::P32;
           if (R1 & 3 != 0) goto chx; else goto chy;
       chy:
           call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
       chx:
           _sfH::P32 = R1;
           _sfI::P32 = P32[_sfH::P32 + 3];
           _sfJ::P32 = P32[_sfH::P32 + 7];
           _sfK::P32 = P32[_sfH::P32 + 11];
           _sfL::P32 = P32[_sfH::P32 + 15];
           _sfM::P32 = P32[_sfH::P32 + 19];
           _sfN::P32 = P32[_sfH::P32 + 23];
           R1 = _sfN::P32;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  chA:
      _sfG::P32 = P32[(old + 8)];
      goto chv;
  chv:
      if (Sp - <highSp> < SpLim) goto chB; else goto chC;
  chB:
      R1 = T2902_Sum.toList_closure;
      P32[(old + 8)] = _sfG::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chC:
      I32[(young<chx> + 4)] = chx;
      R1 = _sfG::P32;
      if (R1 & 3 != 0) goto chx; else goto chy;
  chy:
      call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
  chx:
      _sfH::P32 = R1;
      _sfI::P32 = P32[_sfH::P32 + 3];
      _sfJ::P32 = P32[_sfH::P32 + 7];
      _sfK::P32 = P32[_sfH::P32 + 11];
      _sfL::P32 = P32[_sfH::P32 + 15];
      _sfM::P32 = P32[_sfH::P32 + 19];
      _sfN::P32 = P32[_sfH::P32 + 23];
      R1 = _sfN::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  chA:
      _sfG::P32 = P32[(old + 8)];
      goto chv;
  chv:
      if (Sp - <highSp> < SpLim) goto chB; else goto chC;
  chB:
      R1 = T2902_Sum.toList_closure;
      P32[(old + 8)] = _sfG::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chC:
      I32[(young<chx> + 4)] = chx;
      R1 = _sfG::P32;
      if (R1 & 3 != 0) goto chx; else goto chy;
  chy:
      call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
  chx:
      _sfH::P32 = R1;
      _sfI::P32 = P32[_sfH::P32 + 3];
      _sfJ::P32 = P32[_sfH::P32 + 7];
      _sfK::P32 = P32[_sfH::P32 + 11];
      _sfL::P32 = P32[_sfH::P32 + 15];
      _sfM::P32 = P32[_sfH::P32 + 19];
      _sfN::P32 = P32[_sfH::P32 + 23];
      R1 = _sfN::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  chA:
      _sfG::P32 = P32[(old + 8)];
      goto chv;
  chv:
      if (Sp - <highSp> < SpLim) goto chB; else goto chC;
  chB:
      R1 = T2902_Sum.toList_closure;
      P32[(old + 8)] = _sfG::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chC:
      I32[(young<chx> + 4)] = chx;
      R1 = _sfG::P32;
      if (R1 & 3 != 0) goto chx; else goto chy;
  chy:
      call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
  chx:
      _sfH::P32 = R1;
      _sfI::P32 = P32[_sfH::P32 + 3];
      _sfJ::P32 = P32[_sfH::P32 + 7];
      _sfK::P32 = P32[_sfH::P32 + 11];
      _sfL::P32 = P32[_sfH::P32 + 15];
      _sfM::P32 = P32[_sfH::P32 + 19];
      _sfN::P32 = P32[_sfH::P32 + 23];
      R1 = _sfN::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  chA:
      _sfG::P32 = P32[Sp];
      goto chv;
  chv:
      goto chC;
  chC:
      I32[Sp] = chx;
      R1 = _sfG::P32;
      if (R1 & 3 != 0) goto chx; else goto chy;
  chy:
      call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
  chx:
      _sfH::P32 = R1;
      _sfI::P32 = P32[_sfH::P32 + 3];
      _sfJ::P32 = P32[_sfH::P32 + 7];
      _sfK::P32 = P32[_sfH::P32 + 11];
      _sfL::P32 = P32[_sfH::P32 + 15];
      _sfM::P32 = P32[_sfH::P32 + 19];
      _sfN::P32 = P32[_sfH::P32 + 23];
      R1 = _sfN::P32;
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  chA:
      goto chv;
  chv:
      goto chC;
  chC:
      _sfG::P32 = P32[Sp];
      I32[Sp] = chx;
      R1 = _sfG::P32;
      if (R1 & 3 != 0) goto chx; else goto chy;
  chy:
      call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
  chx:
      R1 = P32[R1 + 23];
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(chv, {}), (chx, {}), (chy, {}), (chA, {}), (chC, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.toList_entry() //  []
        { info_tbl: [(chx,
                      label: block_chx_info
                      rep:StackRep []),
                     (chA,
                      label: T2902_Sum.toList_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      chA:
          goto chv;
      chv:
          goto chC;
      chC:
          _sfG::P32 = P32[Sp];
          I32[Sp] = chx;
          R1 = _sfG::P32;
          if (R1 & 3 != 0) goto chx; else goto chy;
      chy:
          call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
      chx:
          R1 = P32[R1 + 23];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.toList_entry() //  []
        { info_tbl: [(chx,
                      label: block_chx_info
                      rep:StackRep []),
                     (chC,
                      label: T2902_Sum.toList_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      chC:
          _sfG::P32 = P32[Sp];
          I32[Sp] = chx;
          R1 = _sfG::P32;
          if (R1 & 3 != 0) goto chx; else goto chy;
      chy:
          call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
      chx:
          R1 = P32[R1 + 23];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.toList_closure:
         const T2902_Sum.toList_info;
 },
 T2902_Sum.toList_entry() //  []
         { info_tbl: [(chx,
                       label: block_chx_info
                       rep:StackRep []),
                      (chC,
                       label: T2902_Sum.toList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       chC:
           _sfG::P32 = P32[Sp];
           I32[Sp] = chx;
           R1 = _sfG::P32;
           if (R1 & 3 != 0) goto chx; else goto chy;
       chy:
           call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
       chx:
           R1 = P32[R1 + 23];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.toList_closure:
         const T2902_Sum.toList_info;
 },
 T2902_Sum.toList_entry() //  []
         { info_tbl: [(chx,
                       label: block_chx_info
                       rep:StackRep []),
                      (chC,
                       label: T2902_Sum.toList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       chC:
           _sfG::P32 = P32[Sp];
           I32[Sp] = chx;
           R1 = _sfG::P32;
           if (R1 & 3 != 0) goto chx; else goto chy;
       chy:
           call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
       chx:
           R1 = P32[R1 + 23];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.D:Sum_closure:
         const T2902_Sum.D:Sum_info;
 },
 T2902_Sum.D:Sum_entry() //  []
         { info_tbl: [(chP,
                       label: T2902_Sum.D:Sum_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 28 updfr_space: Just 4
         }
     {offset
       chP:
           _B6::P32 = P32[(old + 28)];
           _B5::P32 = P32[(old + 24)];
           _B4::P32 = P32[(old + 20)];
           _B3::P32 = P32[(old + 16)];
           _B2::P32 = P32[(old + 12)];
           _B1::P32 = P32[(old + 8)];
           goto chM;
       chM:
           if (Sp - <highSp> < SpLim) goto chQ; else goto chR;
       chR:
           Hp = Hp + 28;
           if (Hp > HpLim) goto chT; else goto chS;
       chT:
           HpAlloc = 28;
           goto chQ;
       chQ:
           R1 = T2902_Sum.D:Sum_closure;
           P32[(old + 28)] = _B6::P32;
           P32[(old + 24)] = _B5::P32;
           P32[(old + 20)] = _B4::P32;
           P32[(old + 16)] = _B3::P32;
           P32[(old + 12)] = _B2::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
       chS:
           I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
           P32[Hp - 20] = _B6::P32;
           P32[Hp - 16] = _B5::P32;
           P32[Hp - 12] = _B4::P32;
           P32[Hp - 8] = _B3::P32;
           P32[Hp - 4] = _B2::P32;
           P32[Hp] = _B1::P32;
           _chO::P32 = Hp - 23;
           R1 = _chO::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  chP:
      _B6::P32 = P32[(old + 28)];
      _B5::P32 = P32[(old + 24)];
      _B4::P32 = P32[(old + 20)];
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto chM;
  chM:
      if (Sp - <highSp> < SpLim) goto chQ; else goto chR;
  chR:
      Hp = Hp + 28;
      if (Hp > HpLim) goto chT; else goto chS;
  chT:
      HpAlloc = 28;
      goto chQ;
  chQ:
      R1 = T2902_Sum.D:Sum_closure;
      P32[(old + 28)] = _B6::P32;
      P32[(old + 24)] = _B5::P32;
      P32[(old + 20)] = _B4::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  chS:
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _B6::P32;
      P32[Hp - 16] = _B5::P32;
      P32[Hp - 12] = _B4::P32;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _chO::P32 = Hp - 23;
      R1 = _chO::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  chP:
      _B6::P32 = P32[(old + 28)];
      _B5::P32 = P32[(old + 24)];
      _B4::P32 = P32[(old + 20)];
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto chM;
  chM:
      if (Sp - <highSp> < SpLim) goto chQ; else goto chR;
  chR:
      Hp = Hp + 28;
      if (Hp > HpLim) goto chT; else goto chS;
  chT:
      HpAlloc = 28;
      goto chQ;
  chQ:
      R1 = T2902_Sum.D:Sum_closure;
      P32[(old + 28)] = _B6::P32;
      P32[(old + 24)] = _B5::P32;
      P32[(old + 20)] = _B4::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  chS:
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _B6::P32;
      P32[Hp - 16] = _B5::P32;
      P32[Hp - 12] = _B4::P32;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _chO::P32 = Hp - 23;
      R1 = _chO::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  chP:
      _B6::P32 = P32[(old + 28)];
      _B5::P32 = P32[(old + 24)];
      _B4::P32 = P32[(old + 20)];
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto chM;
  chM:
      if (Sp - <highSp> < SpLim) goto chQ; else goto chR;
  chR:
      Hp = Hp + 28;
      if (Hp > HpLim) goto chT; else goto chS;
  chT:
      HpAlloc = 28;
      goto chQ;
  chQ:
      R1 = T2902_Sum.D:Sum_closure;
      P32[(old + 28)] = _B6::P32;
      P32[(old + 24)] = _B5::P32;
      P32[(old + 20)] = _B4::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  chS:
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _B6::P32;
      P32[Hp - 16] = _B5::P32;
      P32[Hp - 12] = _B4::P32;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _chO::P32 = Hp - 23;
      R1 = _chO::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  chP:
      _B6::P32 = P32[Sp];
      _B5::P32 = P32[Sp + 4];
      _B4::P32 = P32[Sp + 8];
      _B3::P32 = P32[Sp + 12];
      _B2::P32 = P32[Sp + 16];
      _B1::P32 = P32[Sp + 20];
      goto chM;
  chM:
      goto chR;
  chR:
      Hp = Hp + 28;
      if (Hp > HpLim) goto chT; else goto chS;
  chT:
      HpAlloc = 28;
      goto chQ;
  chQ:
      R1 = T2902_Sum.D:Sum_closure;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  chS:
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _B6::P32;
      P32[Hp - 16] = _B5::P32;
      P32[Hp - 12] = _B4::P32;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _chO::P32 = Hp - 23;
      R1 = _chO::P32;
      Sp = Sp + 24;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  chP:
      goto chM;
  chM:
      goto chR;
  chR:
      Hp = Hp + 28;
      if (Hp > HpLim) goto chT; else goto chS;
  chT:
      HpAlloc = 28;
      goto chQ;
  chQ:
      R1 = T2902_Sum.D:Sum_closure;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  chS:
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = P32[Sp];
      P32[Hp - 16] = P32[Sp + 4];
      P32[Hp - 12] = P32[Sp + 8];
      P32[Hp - 8] = P32[Sp + 12];
      P32[Hp - 4] = P32[Sp + 16];
      P32[Hp] = P32[Sp + 20];
      R1 = Hp - 23;
      Sp = Sp + 24;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(chM, {}), (chP, {}), (chQ, {}), (chR, {}), (chS, {}), (chT, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.D:Sum_entry() //  []
        { info_tbl: [(chP,
                      label: T2902_Sum.D:Sum_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 28 updfr_space: Just 4
        }
    {offset
      chP:
          goto chM;
      chM:
          goto chR;
      chR:
          Hp = Hp + 28;
          if (Hp > HpLim) goto chT; else goto chS;
      chT:
          HpAlloc = 28;
          goto chQ;
      chQ:
          R1 = T2902_Sum.D:Sum_closure;
          call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
      chS:
          I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
          P32[Hp - 20] = P32[Sp];
          P32[Hp - 16] = P32[Sp + 4];
          P32[Hp - 12] = P32[Sp + 8];
          P32[Hp - 8] = P32[Sp + 12];
          P32[Hp - 4] = P32[Sp + 16];
          P32[Hp] = P32[Sp + 20];
          R1 = Hp - 23;
          Sp = Sp + 24;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.D:Sum_entry() //  []
        { info_tbl: [(chR,
                      label: T2902_Sum.D:Sum_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 28 updfr_space: Just 4
        }
    {offset
      chR:
          Hp = Hp + 28;
          if (Hp > HpLim) goto chT; else goto chS;
      chT:
          HpAlloc = 28;
          goto chQ;
      chQ:
          R1 = T2902_Sum.D:Sum_closure;
          call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
      chS:
          I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
          P32[Hp - 20] = P32[Sp];
          P32[Hp - 16] = P32[Sp + 4];
          P32[Hp - 12] = P32[Sp + 8];
          P32[Hp - 8] = P32[Sp + 12];
          P32[Hp - 4] = P32[Sp + 16];
          P32[Hp] = P32[Sp + 20];
          R1 = Hp - 23;
          Sp = Sp + 24;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.D:Sum_closure:
         const T2902_Sum.D:Sum_info;
 },
 T2902_Sum.D:Sum_entry() //  []
         { info_tbl: [(chR,
                       label: T2902_Sum.D:Sum_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 28 updfr_space: Just 4
         }
     {offset
       chR:
           Hp = Hp + 28;
           if (Hp > HpLim) goto chT; else goto chS;
       chT:
           HpAlloc = 28;
           goto chQ;
       chQ:
           R1 = T2902_Sum.D:Sum_closure;
           call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
       chS:
           I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
           P32[Hp - 20] = P32[Sp];
           P32[Hp - 16] = P32[Sp + 4];
           P32[Hp - 12] = P32[Sp + 8];
           P32[Hp - 8] = P32[Sp + 12];
           P32[Hp - 4] = P32[Sp + 16];
           P32[Hp] = P32[Sp + 20];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.D:Sum_closure:
         const T2902_Sum.D:Sum_info;
 },
 T2902_Sum.D:Sum_entry() //  []
         { info_tbl: [(chR,
                       label: T2902_Sum.D:Sum_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 28 updfr_space: Just 4
         }
     {offset
       chR:
           Hp = Hp + 28;
           if (Hp > HpLim) goto chT; else goto chS;
       chT:
           HpAlloc = 28;
           goto chQ;
       chQ:
           R1 = T2902_Sum.D:Sum_closure;
           call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
       chS:
           I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
           P32[Hp - 20] = P32[Sp];
           P32[Hp - 16] = P32[Sp + 4];
           P32[Hp - 12] = P32[Sp + 8];
           P32[Hp - 8] = P32[Sp + 12];
           P32[Hp - 4] = P32[Sp + 16];
           P32[Hp] = P32[Sp + 20];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[T2902_Sum.D:Sum_con_entry() //  []
         { info_tbl: [(ci4,
                       label: T2902_Sum.D:Sum_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       ci4:
           R1 = R1 + 1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 },
 T2902_Sum.D:Sum_static_entry() //  []
         { info_tbl: [(ci5,
                       label: T2902_Sum.D:Sum_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       ci5:
           R1 = R1 + 1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  ci4:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  ci4:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  ci4:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  ci4:
      R1 = R1 + 1;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  ci4:
      R1 = R1 + 1;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(ci4, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.D:Sum_con_entry() //  []
        { info_tbl: [(ci4,
                      label: T2902_Sum.D:Sum_con_info
                      rep:HeapRep 6 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      ci4:
          R1 = R1 + 1;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.D:Sum_con_entry() //  []
        { info_tbl: [(ci4,
                      label: T2902_Sum.D:Sum_con_info
                      rep:HeapRep 6 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      ci4:
          R1 = R1 + 1;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  ci5:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  ci5:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  ci5:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  ci5:
      R1 = R1 + 1;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  ci5:
      R1 = R1 + 1;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(ci5, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.D:Sum_static_entry() //  []
        { info_tbl: [(ci5,
                      label: T2902_Sum.D:Sum_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      ci5:
          R1 = R1 + 1;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.D:Sum_static_entry() //  []
        { info_tbl: [(ci5,
                      label: T2902_Sum.D:Sum_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      ci5:
          R1 = R1 + 1;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[T2902_Sum.D:Sum_con_entry() //  []
         { info_tbl: [(ci4,
                       label: T2902_Sum.D:Sum_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       ci4:
           R1 = R1 + 1;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 },
 T2902_Sum.D:Sum_static_entry() //  []
         { info_tbl: [(ci5,
                       label: T2902_Sum.D:Sum_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       ci5:
           R1 = R1 + 1;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[T2902_Sum.D:Sum_con_entry() //  []
         { info_tbl: [(ci4,
                       label: T2902_Sum.D:Sum_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       ci4:
           R1 = R1 + 1;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 },
 T2902_Sum.D:Sum_static_entry() //  []
         { info_tbl: [(ci5,
                       label: T2902_Sum.D:Sum_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       ci5:
           R1 = R1 + 1;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "relreadonly" { Sie_srt:
 }]


[2 of 3] Compiling T2902_B_PairingSum ( T2902_B_PairingSum.hs, T2902_B_PairingSum.o )

==================== Cmm produced by new codegen ====================
[section "data" { __stginit_main:T2902_B_PairingSum:
 }]



==================== Post CPS Cmm ====================
[section "data" { __stginit_main:T2902_B_PairingSum:
 }]



==================== Output Cmm ====================
[section "data" { __stginit_main:T2902_B_PairingSum:
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     lvl_rHo_closure:
         const GHC.Integer.Type.S#_static_info;
         const 0;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     lvl_rHo_closure:
         const GHC.Integer.Type.S#_static_info;
         const 0;
 }]



==================== Output Cmm ====================
[section "data" {
     lvl_rHo_closure:
         const GHC.Integer.Type.S#_static_info;
         const 0;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cunions_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cunions_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cunions_entry() //  []
         { info_tbl: [(cJP,
                       label: T2902_B_PairingSum.$fSumPSumab_$cunions_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cJP:
           _sHs::P32 = P32[(old + 20)];
           _sHt::P32 = P32[(old + 16)];
           _sHu::P32 = P32[(old + 12)];
           _sHv::P32 = P32[(old + 8)];
           goto cJD;
       cJD:
           if (Sp - <highSp> < SpLim) goto cJQ; else goto cJR;
       cJQ:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
           P32[(old + 20)] = _sHs::P32;
           P32[(old + 16)] = _sHt::P32;
           P32[(old + 12)] = _sHu::P32;
           P32[(old + 8)] = _sHv::P32;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cJR:
           I32[(young<cJF> + 4)] = cJF;
           R1 = _sHv::P32;
           if (R1 & 3 != 0) goto cJF; else goto cJG;
       cJG:
           call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
       cJF:
           _sHw::P32 = R1;
           _cJL::P32 = _sHw::P32 & 3;
           if (_cJL::P32 >= 2) goto cJN; else goto cJO;
       cJN:
           goto cJK;
       cJK:
           _sHx::P32 = P32[_sHw::P32 + 2];
           _sHy::P32 = P32[_sHw::P32 + 6];
           I32[(young<cJX> + 4)] = cJX;
           R1 = _sHy::P32;
           if (R1 & 3 != 0) goto cJX; else goto cJZ;
       cJZ:
           call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
       cJX:
           _sHz::P32 = R1;
           _cKk::P32 = _sHz::P32 & 3;
           if (_cKk::P32 >= 2) goto cKm; else goto cKn;
       cKm:
           goto cKe;
       cKe:
           _sHA::P32 = P32[_sHz::P32 + 2];
           _sHB::P32 = P32[_sHz::P32 + 6];
           I32[(young<cK8> + 4)] = cK8;
           P32[(young<cK8> + 20)] = _sHs::P32;
           P32[(young<cK8> + 16)] = _sHt::P32;
           P32[(young<cK8> + 12)] = _sHu::P32;
           P32[(young<cK8> + 8)] = _sHB::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
       cK8:
           _sHD::P32 = R1;
           I32[(young<cKc> + 4)] = cKc;
           P32[(young<cKc> + 24)] = _sHs::P32;
           P32[(young<cKc> + 20)] = _sHt::P32;
           P32[(young<cKc> + 16)] = _sHu::P32;
           P32[(young<cKc> + 12)] = _sHx::P32;
           P32[(young<cKc> + 8)] = _sHA::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
       cKc:
           _sHC::P32 = R1;
           P32[(old + 24)] = _sHs::P32;
           P32[(old + 20)] = _sHt::P32;
           P32[(old + 16)] = _sHu::P32;
           P32[(old + 12)] = _sHC::P32;
           P32[(old + 8)] = _sHD::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
       cKn:
           goto cK5;
       cK5:
           R1 = _sHx::P32 & (-4);
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cJO:
           goto cJJ;
       cJJ:
           R1 = T2902_B_PairingSum.Empty_closure+1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 },
 section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cunion_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cunion_info;
         const 0;
 },
 ds1_sHT_entry() //  [R1]
         { info_tbl: [(cKM,
                       label: ds1_sHT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cKM:
           _sHT::P32 = R1;
           goto cKK;
       cKK:
           if (Sp - <highSp> < SpLim) goto cKN; else goto cKO;
       cKN:
           R1 = _sHT::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cKO:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _sHT::P32;
           _sHG::P32 = P32[_sHT::P32 + 8];
           _sHL::P32 = P32[_sHT::P32 + 12];
           _sHP::P32 = P32[_sHT::P32 + 16];
           P32[(old + 28)] = _sHG::P32;
           I32[(old + 24)] = stg_ap_pp_info;
           P32[(old + 20)] = _sHP::P32;
           P32[(old + 16)] = _sHL::P32;
           call GHC.Num.+_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_sHX_entry() //  [R1]
         { info_tbl: [(cL5,
                       label: sat_sHX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cL5:
           _sHX::P32 = R1;
           goto cL3;
       cL3:
           if (Sp - <highSp> < SpLim) goto cL6; else goto cL7;
       cL6:
           R1 = _sHX::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cL7:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _sHX::P32;
           _sHG::P32 = P32[_sHX::P32 + 8];
           P32[(old + 24)] = _sHG::P32;
           I32[(old + 20)] = stg_ap_p_info;
           P32[(old + 16)] = lvl_rHo_closure+1;
           call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$cunion_entry() //  []
         { info_tbl: [(cLf,
                       label: T2902_B_PairingSum.$fSumPSumab_$cunion_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 24 updfr_space: Just 4
         }
     {offset
       cLf:
           _sHE::P32 = P32[(old + 24)];
           _sHF::P32 = P32[(old + 20)];
           _sHG::P32 = P32[(old + 16)];
           _sHH::P32 = P32[(old + 12)];
           _sHI::P32 = P32[(old + 8)];
           goto cKp;
       cKp:
           if (Sp - <highSp> < SpLim) goto cLg; else goto cLh;
       cLg:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
           P32[(old + 24)] = _sHE::P32;
           P32[(old + 20)] = _sHF::P32;
           P32[(old + 16)] = _sHG::P32;
           P32[(old + 12)] = _sHH::P32;
           P32[(old + 8)] = _sHI::P32;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
       cLh:
           I32[(young<cKr> + 4)] = cKr;
           R1 = _sHI::P32;
           if (R1 & 3 != 0) goto cKr; else goto cKs;
       cKs:
           call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
       cKr:
           _sHJ::P32 = R1;
           _cLb::P32 = _sHJ::P32 & 3;
           if (_cLb::P32 >= 2) goto cLd; else goto cLe;
       cLd:
           goto cLa;
       cLa:
           _sHK::P32 = P32[_sHJ::P32 + 2];
           _sHL::P32 = P32[_sHJ::P32 + 6];
           _sHM::P32 = P32[_sHJ::P32 + 10];
           I32[(young<cKx> + 4)] = cKx;
           R1 = _sHH::P32;
           if (R1 & 3 != 0) goto cKx; else goto cKy;
       cKy:
           call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
       cKx:
           _sHN::P32 = R1;
           _cMc::P32 = _sHN::P32 & 3;
           if (_cMc::P32 >= 2) goto cMe; else goto cMf;
       cMe:
           goto cLq;
       cLq:
           _sHO::P32 = P32[_sHN::P32 + 2];
           _sHP::P32 = P32[_sHN::P32 + 6];
           _sHQ::P32 = P32[_sHN::P32 + 10];
           I32[(young<cKD> + 4)] = cKD;
           P32[(young<cKD> + 20)] = _sHE::P32;
           I32[(young<cKD> + 16)] = stg_ap_pp_info;
           P32[(young<cKD> + 12)] = _sHO::P32;
           P32[(young<cKD> + 8)] = _sHK::P32;
           call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
       cKD:
           _sHR::P32 = R1;
           _cM5::P32 = _sHR::P32 & 3;
           if (_cM5::P32 >= 2) goto cMa; else goto cMb;
       cMa:
           if (_cM5::P32 >= 3) goto cM7; else goto cM8;
       cM7:
           goto cM1;
       cM1:
           Hp = Hp + 28;
           if (Hp > HpLim) goto cM4; else goto cM3;
       cM4:
           HpAlloc = 28;
           goto cM2;
       cM2:
           R1 = _sHR::P32;
           call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
       cM3:
           I32[Hp - 24] = :_con_info;
           P32[Hp - 20] = _sHN::P32;
           P32[Hp - 16] = _sHM::P32;
           _cLZ::P32 = Hp - 22;
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = _sHK::P32;
           P32[Hp - 4] = _sHL::P32;
           P32[Hp] = _cLZ::P32;
           _cM0::P32 = Hp - 10;
           R1 = _cM0::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
       cM8:
           goto cLz;
       cLz:
           Hp = Hp + 20;
           if (Hp > HpLim) goto cLC; else goto cLB;
       cLC:
           HpAlloc = 20;
           goto cLA;
       cLA:
           R1 = _sHR::P32;
           call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
       cLB:
           I32[Hp - 16] = ds1_sHT_info;
           P32[Hp - 8] = _sHG::P32;
           P32[Hp - 4] = _sHL::P32;
           P32[Hp] = _sHP::P32;
           _cKI::P32 = Hp - 16;
           I32[(young<cKP> + 4)] = cKP;
           P32[(young<cKP> + 20)] = _sHE::P32;
           P32[(young<cKP> + 16)] = _sHF::P32;
           P32[(young<cKP> + 12)] = _sHG::P32;
           P32[(young<cKP> + 8)] = _sHM::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
       cKP:
           _sHW::P32 = R1;
           I32[(young<cKT> + 4)] = cKT;
           P32[(young<cKT> + 20)] = _sHE::P32;
           P32[(young<cKT> + 16)] = _sHF::P32;
           P32[(young<cKT> + 12)] = _sHG::P32;
           P32[(young<cKT> + 8)] = _sHQ::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
       cKT:
           _sHV::P32 = R1;
           I32[(young<cKX> + 4)] = cKX;
           P32[(young<cKX> + 24)] = _sHE::P32;
           P32[(young<cKX> + 20)] = _sHF::P32;
           P32[(young<cKX> + 16)] = _sHG::P32;
           P32[(young<cKX> + 12)] = _sHV::P32;
           P32[(young<cKX> + 8)] = _sHW::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
       cKX:
           _sHU::P32 = R1;
           Hp = Hp + 12;
           if (Hp > HpLim) goto cLI; else goto cLH;
       cLI:
           HpAlloc = 12;
           goto cLG;
       cLG:
           R1 = _sHU::P32;
           call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
       cLH:
           I32[Hp - 8] = sat_sHX_info;
           P32[Hp] = _sHG::P32;
           _cL1::P32 = Hp - 8;
           I32[(young<cLF> + 4)] = cLF;
           P32[(young<cLF> + 20)] = _sHF::P32;
           I32[(young<cLF> + 16)] = stg_ap_pp_info;
           P32[(young<cLF> + 12)] = _cKI::P32;
           P32[(young<cLF> + 8)] = _cL1::P32;
           call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
       cLF:
           _sHY::P32 = R1;
           _cLT::P32 = _sHY::P32 & 3;
           if (_cLT::P32 >= 2) goto cLV; else goto cLW;
       cLV:
           goto cLS;
       cLS:
           R1 = _sHU::P32 & (-4);
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cLW:
           goto cLO;
       cLO:
           P32[(old + 28)] = _sHE::P32;
           P32[(old + 24)] = _sHF::P32;
           P32[(old + 20)] = _sHG::P32;
           P32[(old + 16)] = _sHO::P32;
           P32[(old + 12)] = _cKI::P32;
           P32[(old + 8)] = _sHU::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
       cMb:
           goto cLv;
       cLv:
           Hp = Hp + 28;
           if (Hp > HpLim) goto cLy; else goto cLx;
       cLy:
           HpAlloc = 28;
           goto cLw;
       cLw:
           R1 = _sHR::P32;
           call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
       cLx:
           I32[Hp - 24] = :_con_info;
           P32[Hp - 20] = _sHJ::P32;
           P32[Hp - 16] = _sHQ::P32;
           _cLs::P32 = Hp - 22;
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = _sHO::P32;
           P32[Hp - 4] = _sHP::P32;
           P32[Hp] = _cLs::P32;
           _cLt::P32 = Hp - 10;
           R1 = _cLt::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
       cMf:
           goto cLo;
       cLo:
           R1 = _sHJ::P32 & (-4);
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cLe:
           goto cL9;
       cL9:
           R1 = _sHH::P32 & (-4);
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
     }
 },
 section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cinsert_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cinsert_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cinsert_entry() //  []
         { info_tbl: [(cMk,
                       label: T2902_B_PairingSum.$fSumPSumab_$cinsert_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 28 updfr_space: Just 4
         }
     {offset
       cMk:
           _sI0::P32 = P32[(old + 28)];
           _sI1::P32 = P32[(old + 24)];
           _sI2::P32 = P32[(old + 20)];
           _sI3::P32 = P32[(old + 16)];
           _sI4::P32 = P32[(old + 12)];
           _sI5::P32 = P32[(old + 8)];
           goto cMh;
       cMh:
           if (Sp - <highSp> < SpLim) goto cMl; else goto cMm;
       cMm:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cMo; else goto cMn;
       cMo:
           HpAlloc = 16;
           goto cMl;
       cMl:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
           P32[(old + 28)] = _sI0::P32;
           P32[(old + 24)] = _sI1::P32;
           P32[(old + 20)] = _sI2::P32;
           P32[(old + 16)] = _sI3::P32;
           P32[(old + 12)] = _sI4::P32;
           P32[(old + 8)] = _sI5::P32;
           call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
       cMn:
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = _sI3::P32;
           P32[Hp - 4] = _sI4::P32;
           P32[Hp] = GHC.Types.[]_closure+1;
           _cMj::P32 = Hp - 10;
           P32[(old + 24)] = _sI0::P32;
           P32[(old + 20)] = _sI1::P32;
           P32[(old + 16)] = _sI2::P32;
           P32[(old + 12)] = _cMj::P32;
           P32[(old + 8)] = _sI5::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cJP:
      _sHs::P32 = P32[(old + 20)];
      _sHt::P32 = P32[(old + 16)];
      _sHu::P32 = P32[(old + 12)];
      _sHv::P32 = P32[(old + 8)];
      goto cJD;
  cJD:
      if (Sp - <highSp> < SpLim) goto cJQ; else goto cJR;
  cJQ:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
      P32[(old + 20)] = _sHs::P32;
      P32[(old + 16)] = _sHt::P32;
      P32[(old + 12)] = _sHu::P32;
      P32[(old + 8)] = _sHv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cJR:
      I32[(young<cJF> + 4)] = cJF;
      R1 = _sHv::P32;
      if (R1 & 3 != 0) goto cJF; else goto cJG;
  cJG:
      call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
  cJF:
      _sHw::P32 = R1;
      _cJL::P32 = _sHw::P32 & 3;
      if (_cJL::P32 >= 2) goto cJK; else goto cJJ;
  cJK:
      _sHx::P32 = P32[_sHw::P32 + 2];
      _sHy::P32 = P32[_sHw::P32 + 6];
      I32[(young<cJX> + 4)] = cJX;
      R1 = _sHy::P32;
      if (R1 & 3 != 0) goto cJX; else goto cJZ;
  cJZ:
      call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
  cJX:
      _sHz::P32 = R1;
      _cKk::P32 = _sHz::P32 & 3;
      if (_cKk::P32 >= 2) goto cKe; else goto cK5;
  cKe:
      _sHA::P32 = P32[_sHz::P32 + 2];
      _sHB::P32 = P32[_sHz::P32 + 6];
      I32[(young<cK8> + 4)] = cK8;
      P32[(young<cK8> + 20)] = _sHs::P32;
      P32[(young<cK8> + 16)] = _sHt::P32;
      P32[(young<cK8> + 12)] = _sHu::P32;
      P32[(young<cK8> + 8)] = _sHB::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
  cK8:
      _sHD::P32 = R1;
      I32[(young<cKc> + 4)] = cKc;
      P32[(young<cKc> + 24)] = _sHs::P32;
      P32[(young<cKc> + 20)] = _sHt::P32;
      P32[(young<cKc> + 16)] = _sHu::P32;
      P32[(young<cKc> + 12)] = _sHx::P32;
      P32[(young<cKc> + 8)] = _sHA::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
  cKc:
      _sHC::P32 = R1;
      P32[(old + 24)] = _sHs::P32;
      P32[(old + 20)] = _sHt::P32;
      P32[(old + 16)] = _sHu::P32;
      P32[(old + 12)] = _sHC::P32;
      P32[(old + 8)] = _sHD::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
  cK5:
      R1 = _sHx::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cJJ:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cJP:
      _sHs::P32 = P32[(old + 20)];
      _sHt::P32 = P32[(old + 16)];
      _sHu::P32 = P32[(old + 12)];
      _sHv::P32 = P32[(old + 8)];
      goto cJD;
  cJD:
      if (Sp - <highSp> < SpLim) goto cJQ; else goto cJR;
  cJQ:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
      P32[(old + 20)] = _sHs::P32;
      P32[(old + 16)] = _sHt::P32;
      P32[(old + 12)] = _sHu::P32;
      P32[(old + 8)] = _sHv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cJR:
      I32[(young<cJF> + 4)] = cJF;
      R1 = _sHv::P32;
      if (R1 & 3 != 0) goto cJF; else goto cJG;
  cJG:
      call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
  cJF:
      _sHw::P32 = R1;
      _cJL::P32 = _sHw::P32 & 3;
      if (_cJL::P32 >= 2) goto cJK; else goto cJJ;
  cJK:
      _sHx::P32 = P32[_sHw::P32 + 2];
      _sHy::P32 = P32[_sHw::P32 + 6];
      I32[(young<cJX> + 4)] = cJX;
      R1 = _sHy::P32;
      if (R1 & 3 != 0) goto cJX; else goto cJZ;
  cJZ:
      call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
  cJX:
      _sHz::P32 = R1;
      _cKk::P32 = _sHz::P32 & 3;
      if (_cKk::P32 >= 2) goto cKe; else goto cK5;
  cKe:
      _sHA::P32 = P32[_sHz::P32 + 2];
      _sHB::P32 = P32[_sHz::P32 + 6];
      I32[(young<cK8> + 4)] = cK8;
      P32[(young<cK8> + 20)] = _sHs::P32;
      P32[(young<cK8> + 16)] = _sHt::P32;
      P32[(young<cK8> + 12)] = _sHu::P32;
      P32[(young<cK8> + 8)] = _sHB::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
  cK8:
      _sHD::P32 = R1;
      I32[(young<cKc> + 4)] = cKc;
      P32[(young<cKc> + 24)] = _sHs::P32;
      P32[(young<cKc> + 20)] = _sHt::P32;
      P32[(young<cKc> + 16)] = _sHu::P32;
      P32[(young<cKc> + 12)] = _sHx::P32;
      P32[(young<cKc> + 8)] = _sHA::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
  cKc:
      _sHC::P32 = R1;
      P32[(old + 24)] = _sHs::P32;
      P32[(old + 20)] = _sHt::P32;
      P32[(old + 16)] = _sHu::P32;
      P32[(old + 12)] = _sHC::P32;
      P32[(old + 8)] = _sHD::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
  cK5:
      R1 = _sHx::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cJJ:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cJP:
      _sHs::P32 = P32[(old + 20)];
      _sHt::P32 = P32[(old + 16)];
      _sHu::P32 = P32[(old + 12)];
      _sHv::P32 = P32[(old + 8)];
      goto cJD;
  cJD:
      if (Sp - <highSp> < SpLim) goto cJQ; else goto cJR;
  cJQ:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
      P32[(old + 20)] = _sHs::P32;
      P32[(old + 16)] = _sHt::P32;
      P32[(old + 12)] = _sHu::P32;
      P32[(old + 8)] = _sHv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cJR:
      I32[(young<cJF> + 4)] = cJF;
      R1 = _sHv::P32;
      if (R1 & 3 != 0) goto cJF; else goto cJG;
  cJG:
      call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
  cJF:
      _sHw::P32 = R1;
      _cJL::P32 = _sHw::P32 & 3;
      if (_cJL::P32 >= 2) goto cJK; else goto cJJ;
  cJK:
      _sHx::P32 = P32[_sHw::P32 + 2];
      _sHy::P32 = P32[_sHw::P32 + 6];
      I32[(young<cJX> + 4)] = cJX;
      R1 = _sHy::P32;
      if (R1 & 3 != 0) goto cJX; else goto cJZ;
  cJZ:
      call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
  cJX:
      _sHz::P32 = R1;
      _cKk::P32 = _sHz::P32 & 3;
      if (_cKk::P32 >= 2) goto cKe; else goto cK5;
  cKe:
      _sHA::P32 = P32[_sHz::P32 + 2];
      _sHB::P32 = P32[_sHz::P32 + 6];
      I32[(young<cK8> + 4)] = cK8;
      P32[(young<cK8> + 20)] = _sHs::P32;
      P32[(young<cK8> + 16)] = _sHt::P32;
      P32[(young<cK8> + 12)] = _sHu::P32;
      P32[(young<cK8> + 8)] = _sHB::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
  cK8:
      _sHD::P32 = R1;
      I32[(young<cKc> + 4)] = cKc;
      P32[(young<cKc> + 24)] = _sHs::P32;
      P32[(young<cKc> + 20)] = _sHt::P32;
      P32[(young<cKc> + 16)] = _sHu::P32;
      P32[(young<cKc> + 12)] = _sHx::P32;
      P32[(young<cKc> + 8)] = _sHA::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
  cKc:
      _sHC::P32 = R1;
      P32[(old + 24)] = _sHs::P32;
      P32[(old + 20)] = _sHt::P32;
      P32[(old + 16)] = _sHu::P32;
      P32[(old + 12)] = _sHC::P32;
      P32[(old + 8)] = _sHD::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
  cK5:
      R1 = _sHx::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cJJ:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cJP:
      _sHs::P32 = P32[Sp];
      _sHt::P32 = P32[Sp + 4];
      _sHu::P32 = P32[Sp + 8];
      _sHv::P32 = P32[Sp + 12];
      goto cJD;
  cJD:
      if (Sp - 24 < SpLim) goto cJQ; else goto cJR;
  cJQ:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cJR:
      I32[Sp - 4] = cJF;
      R1 = _sHv::P32;
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto cJF; else goto cJG;
  cJG:
      call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
  cJF:
      _sHs::P32 = P32[Sp + 4];
      _sHt::P32 = P32[Sp + 8];
      _sHu::P32 = P32[Sp + 12];
      _sHw::P32 = R1;
      _cJL::P32 = _sHw::P32 & 3;
      if (_cJL::P32 >= 2) goto cJK; else goto cJJ;
  cJK:
      _sHx::P32 = P32[_sHw::P32 + 2];
      _sHy::P32 = P32[_sHw::P32 + 6];
      I32[Sp] = cJX;
      R1 = _sHy::P32;
      P32[Sp + 16] = _sHx::P32;
      if (R1 & 3 != 0) goto cJX; else goto cJZ;
  cJZ:
      call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
  cJX:
      _sHs::P32 = P32[Sp + 4];
      _sHt::P32 = P32[Sp + 8];
      _sHu::P32 = P32[Sp + 12];
      _sHx::P32 = P32[Sp + 16];
      _sHz::P32 = R1;
      _cKk::P32 = _sHz::P32 & 3;
      if (_cKk::P32 >= 2) goto cKe; else goto cK5;
  cKe:
      _sHA::P32 = P32[_sHz::P32 + 2];
      _sHB::P32 = P32[_sHz::P32 + 6];
      I32[Sp - 4] = cK8;
      P32[Sp - 20] = _sHs::P32;
      P32[Sp - 16] = _sHt::P32;
      P32[Sp - 12] = _sHu::P32;
      P32[Sp - 8] = _sHB::P32;
      P32[Sp] = _sHA::P32;
      Sp = Sp - 20;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
  cK8:
      _sHs::P32 = P32[Sp + 8];
      _sHt::P32 = P32[Sp + 12];
      _sHu::P32 = P32[Sp + 16];
      _sHx::P32 = P32[Sp + 20];
      _sHA::P32 = P32[Sp + 4];
      _sHD::P32 = R1;
      I32[Sp + 4] = cKc;
      P32[Sp - 16] = _sHs::P32;
      P32[Sp - 12] = _sHt::P32;
      P32[Sp - 8] = _sHu::P32;
      P32[Sp - 4] = _sHx::P32;
      P32[Sp] = _sHA::P32;
      P32[Sp + 20] = _sHD::P32;
      Sp = Sp - 16;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
  cKc:
      _sHs::P32 = P32[Sp + 4];
      _sHt::P32 = P32[Sp + 8];
      _sHu::P32 = P32[Sp + 12];
      _sHD::P32 = P32[Sp + 16];
      _sHC::P32 = R1;
      P32[Sp] = _sHs::P32;
      P32[Sp + 4] = _sHt::P32;
      P32[Sp + 8] = _sHu::P32;
      P32[Sp + 12] = _sHC::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
  cK5:
      R1 = _sHx::P32 & (-4);
      Sp = Sp + 20;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cJJ:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cJP:
      goto cJD;
  cJD:
      if ((Sp + -24) < SpLim) goto cJQ; else goto cJR;
  cJQ:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cJR:
      I32[Sp - 4] = cJF;
      R1 = P32[Sp + 12];
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto cJF; else goto cJG;
  cJG:
      call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
  cJF:
      _sHw::P32 = R1;
      if (_sHw::P32 & 3 >= 2) goto cJK; else goto cJJ;
  cJK:
      I32[Sp] = cJX;
      R1 = P32[_sHw::P32 + 6];
      P32[Sp + 16] = P32[_sHw::P32 + 2];
      if (R1 & 3 != 0) goto cJX; else goto cJZ;
  cJZ:
      call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
  cJX:
      _sHz::P32 = R1;
      if (_sHz::P32 & 3 >= 2) goto cKe; else goto cK5;
  cKe:
      I32[Sp - 4] = cK8;
      P32[Sp - 20] = P32[Sp + 4];
      P32[Sp - 16] = P32[Sp + 8];
      P32[Sp - 12] = P32[Sp + 12];
      P32[Sp - 8] = P32[_sHz::P32 + 6];
      P32[Sp] = P32[_sHz::P32 + 2];
      Sp = Sp - 20;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
  cK8:
      _sHA::P32 = P32[Sp + 4];
      I32[Sp + 4] = cKc;
      P32[Sp - 16] = P32[Sp + 8];
      P32[Sp - 12] = P32[Sp + 12];
      P32[Sp - 8] = P32[Sp + 16];
      P32[Sp - 4] = P32[Sp + 20];
      P32[Sp] = _sHA::P32;
      P32[Sp + 20] = R1;
      Sp = Sp - 16;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
  cKc:
      P32[Sp] = P32[Sp + 4];
      P32[Sp + 4] = P32[Sp + 8];
      P32[Sp + 8] = P32[Sp + 12];
      P32[Sp + 12] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
  cK5:
      R1 = P32[Sp + 16] & (-4);
      Sp = Sp + 20;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cJJ:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cJD,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJF,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJG,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJJ, {}),
 (cJK,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJP,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJQ, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cJR,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJX,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJZ,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cK5, {}), (cK8, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cKc, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cKe,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_$cunions_entry() //  []
        { info_tbl: [(cJF,
                      label: block_cJF_info
                      rep:StackRep [False, False, False, True]),
                     (cJP,
                      label: T2902_B_PairingSum.$fSumPSumab_$cunions_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                     (cJX,
                      label: block_cJX_info
                      rep:StackRep [False, False, False, False]),
                     (cK8,
                      label: block_cK8_info
                      rep:StackRep [False, False, False, False, False]),
                     (cKc,
                      label: block_cKc_info
                      rep:StackRep [False, False, False, False])]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cJP:
          goto cJD;
      cJD:
          if ((Sp + -24) < SpLim) goto cJQ; else goto cJR;
      cJQ:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cJR:
          I32[Sp - 4] = cJF;
          R1 = P32[Sp + 12];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto cJF; else goto cJG;
      cJG:
          call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
      cJF:
          _sHw::P32 = R1;
          if (_sHw::P32 & 3 >= 2) goto cJK; else goto cJJ;
      cJK:
          I32[Sp] = cJX;
          R1 = P32[_sHw::P32 + 6];
          P32[Sp + 16] = P32[_sHw::P32 + 2];
          if (R1 & 3 != 0) goto cJX; else goto cJZ;
      cJZ:
          call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
      cJX:
          _sHz::P32 = R1;
          if (_sHz::P32 & 3 >= 2) goto cKe; else goto cK5;
      cKe:
          I32[Sp - 4] = cK8;
          P32[Sp - 20] = P32[Sp + 4];
          P32[Sp - 16] = P32[Sp + 8];
          P32[Sp - 12] = P32[Sp + 12];
          P32[Sp - 8] = P32[_sHz::P32 + 6];
          P32[Sp] = P32[_sHz::P32 + 2];
          Sp = Sp - 20;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
      cK8:
          _sHA::P32 = P32[Sp + 4];
          I32[Sp + 4] = cKc;
          P32[Sp - 16] = P32[Sp + 8];
          P32[Sp - 12] = P32[Sp + 12];
          P32[Sp - 8] = P32[Sp + 16];
          P32[Sp - 4] = P32[Sp + 20];
          P32[Sp] = _sHA::P32;
          P32[Sp + 20] = R1;
          Sp = Sp - 16;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
      cKc:
          P32[Sp] = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp + 8];
          P32[Sp + 8] = P32[Sp + 12];
          P32[Sp + 12] = R1;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
      cK5:
          R1 = P32[Sp + 16] & (-4);
          Sp = Sp + 20;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
      cJJ:
          R1 = T2902_B_PairingSum.Empty_closure+1;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_$cunions_entry() //  []
        { info_tbl: [(cJD,
                      label: T2902_B_PairingSum.$fSumPSumab_$cunions_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                     (cJF,
                      label: block_cJF_info
                      rep:StackRep [False, False, False, True]),
                     (cJX,
                      label: block_cJX_info
                      rep:StackRep [False, False, False, False]),
                     (cK8,
                      label: block_cK8_info
                      rep:StackRep [False, False, False, False, False]),
                     (cKc,
                      label: block_cKc_info
                      rep:StackRep [False, False, False, False])]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cJD:
          if ((Sp + -24) < SpLim) goto cJQ; else goto cJR;
      cJQ:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cJR:
          I32[Sp - 4] = cJF;
          R1 = P32[Sp + 12];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto cJF; else goto cJG;
      cJG:
          call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
      cJF:
          _sHw::P32 = R1;
          if (_sHw::P32 & 3 >= 2) goto cJK; else goto cJJ;
      cJK:
          I32[Sp] = cJX;
          R1 = P32[_sHw::P32 + 6];
          P32[Sp + 16] = P32[_sHw::P32 + 2];
          if (R1 & 3 != 0) goto cJX; else goto cJZ;
      cJZ:
          call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
      cJX:
          _sHz::P32 = R1;
          if (_sHz::P32 & 3 >= 2) goto cKe; else goto cK5;
      cKe:
          I32[Sp - 4] = cK8;
          P32[Sp - 20] = P32[Sp + 4];
          P32[Sp - 16] = P32[Sp + 8];
          P32[Sp - 12] = P32[Sp + 12];
          P32[Sp - 8] = P32[_sHz::P32 + 6];
          P32[Sp] = P32[_sHz::P32 + 2];
          Sp = Sp - 20;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
      cK8:
          _sHA::P32 = P32[Sp + 4];
          I32[Sp + 4] = cKc;
          P32[Sp - 16] = P32[Sp + 8];
          P32[Sp - 12] = P32[Sp + 12];
          P32[Sp - 8] = P32[Sp + 16];
          P32[Sp - 4] = P32[Sp + 20];
          P32[Sp] = _sHA::P32;
          P32[Sp + 20] = R1;
          Sp = Sp - 16;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
      cKc:
          P32[Sp] = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp + 8];
          P32[Sp + 8] = P32[Sp + 12];
          P32[Sp + 12] = R1;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
      cK5:
          R1 = P32[Sp + 16] & (-4);
          Sp = Sp + 20;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
      cJJ:
          R1 = T2902_B_PairingSum.Empty_closure+1;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cKM:
      _sHT::P32 = R1;
      goto cKK;
  cKK:
      if (Sp - <highSp> < SpLim) goto cKN; else goto cKO;
  cKN:
      R1 = _sHT::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cKO:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sHT::P32;
      _sHG::P32 = P32[_sHT::P32 + 8];
      _sHL::P32 = P32[_sHT::P32 + 12];
      _sHP::P32 = P32[_sHT::P32 + 16];
      P32[(old + 28)] = _sHG::P32;
      I32[(old + 24)] = stg_ap_pp_info;
      P32[(old + 20)] = _sHP::P32;
      P32[(old + 16)] = _sHL::P32;
      call GHC.Num.+_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  cKM:
      _sHT::P32 = R1;
      goto cKK;
  cKK:
      if (Sp - <highSp> < SpLim) goto cKN; else goto cKO;
  cKN:
      R1 = _sHT::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cKO:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sHT::P32;
      _sHG::P32 = P32[_sHT::P32 + 8];
      _sHL::P32 = P32[_sHT::P32 + 12];
      _sHP::P32 = P32[_sHT::P32 + 16];
      P32[(old + 28)] = _sHG::P32;
      I32[(old + 24)] = stg_ap_pp_info;
      P32[(old + 20)] = _sHP::P32;
      P32[(old + 16)] = _sHL::P32;
      call GHC.Num.+_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  cKM:
      _sHT::P32 = R1;
      goto cKK;
  cKK:
      if (Sp - <highSp> < SpLim) goto cKN; else goto cKO;
  cKN:
      R1 = _sHT::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cKO:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sHT::P32;
      _sHG::P32 = P32[_sHT::P32 + 8];
      _sHL::P32 = P32[_sHT::P32 + 12];
      _sHP::P32 = P32[_sHT::P32 + 16];
      P32[(old + 28)] = _sHG::P32;
      I32[(old + 24)] = stg_ap_pp_info;
      P32[(old + 20)] = _sHP::P32;
      P32[(old + 16)] = _sHL::P32;
      call GHC.Num.+_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  cKM:
      _sHT::P32 = R1;
      goto cKK;
  cKK:
      if (Sp - 24 < SpLim) goto cKN; else goto cKO;
  cKN:
      R1 = _sHT::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cKO:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _sHT::P32;
      _sHG::P32 = P32[_sHT::P32 + 8];
      _sHL::P32 = P32[_sHT::P32 + 12];
      _sHP::P32 = P32[_sHT::P32 + 16];
      P32[Sp - 24] = _sHG::P32;
      I32[Sp - 20] = stg_ap_pp_info;
      P32[Sp - 16] = _sHP::P32;
      P32[Sp - 12] = _sHL::P32;
      Sp = Sp - 24;
      call GHC.Num.+_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  cKM:
      goto cKK;
  cKK:
      _sHT::P32 = R1;
      if ((Sp + -24) < SpLim) goto cKN; else goto cKO;
  cKN:
      R1 = _sHT::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cKO:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _sHT::P32;
      P32[Sp - 24] = P32[_sHT::P32 + 8];
      I32[Sp - 20] = stg_ap_pp_info;
      P32[Sp - 16] = P32[_sHT::P32 + 16];
      P32[Sp - 12] = P32[_sHT::P32 + 12];
      Sp = Sp - 24;
      call GHC.Num.+_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(cKK, {}), (cKM, {}), (cKN, {}), (cKO, {})]



==================== after setInfoTableStackMap ====================
ds1_sHT_entry() //  [R1]
        { info_tbl: [(cKM,
                      label: ds1_sHT_info
                      rep:HeapRep 3 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cKM:
          goto cKK;
      cKK:
          _sHT::P32 = R1;
          if ((Sp + -24) < SpLim) goto cKN; else goto cKO;
      cKN:
          R1 = _sHT::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cKO:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _sHT::P32;
          P32[Sp - 24] = P32[_sHT::P32 + 8];
          I32[Sp - 20] = stg_ap_pp_info;
          P32[Sp - 16] = P32[_sHT::P32 + 16];
          P32[Sp - 12] = P32[_sHT::P32 + 12];
          Sp = Sp - 24;
          call GHC.Num.+_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
ds1_sHT_entry() //  [R1]
        { info_tbl: [(cKK,
                      label: ds1_sHT_info
                      rep:HeapRep 3 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cKK:
          _sHT::P32 = R1;
          if ((Sp + -24) < SpLim) goto cKN; else goto cKO;
      cKN:
          R1 = _sHT::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cKO:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _sHT::P32;
          P32[Sp - 24] = P32[_sHT::P32 + 8];
          I32[Sp - 20] = stg_ap_pp_info;
          P32[Sp - 16] = P32[_sHT::P32 + 16];
          P32[Sp - 12] = P32[_sHT::P32 + 12];
          Sp = Sp - 24;
          call GHC.Num.+_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cL5:
      _sHX::P32 = R1;
      goto cL3;
  cL3:
      if (Sp - <highSp> < SpLim) goto cL6; else goto cL7;
  cL6:
      R1 = _sHX::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cL7:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sHX::P32;
      _sHG::P32 = P32[_sHX::P32 + 8];
      P32[(old + 24)] = _sHG::P32;
      I32[(old + 20)] = stg_ap_p_info;
      P32[(old + 16)] = lvl_rHo_closure+1;
      call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  cL5:
      _sHX::P32 = R1;
      goto cL3;
  cL3:
      if (Sp - <highSp> < SpLim) goto cL6; else goto cL7;
  cL6:
      R1 = _sHX::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cL7:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sHX::P32;
      _sHG::P32 = P32[_sHX::P32 + 8];
      P32[(old + 24)] = _sHG::P32;
      I32[(old + 20)] = stg_ap_p_info;
      P32[(old + 16)] = lvl_rHo_closure+1;
      call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  cL5:
      _sHX::P32 = R1;
      goto cL3;
  cL3:
      if (Sp - <highSp> < SpLim) goto cL6; else goto cL7;
  cL6:
      R1 = _sHX::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cL7:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sHX::P32;
      _sHG::P32 = P32[_sHX::P32 + 8];
      P32[(old + 24)] = _sHG::P32;
      I32[(old + 20)] = stg_ap_p_info;
      P32[(old + 16)] = lvl_rHo_closure+1;
      call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  cL5:
      _sHX::P32 = R1;
      goto cL3;
  cL3:
      if (Sp - 20 < SpLim) goto cL6; else goto cL7;
  cL6:
      R1 = _sHX::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cL7:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _sHX::P32;
      _sHG::P32 = P32[_sHX::P32 + 8];
      P32[Sp - 20] = _sHG::P32;
      I32[Sp - 16] = stg_ap_p_info;
      P32[Sp - 12] = lvl_rHo_closure+1;
      Sp = Sp - 20;
      call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  cL5:
      goto cL3;
  cL3:
      _sHX::P32 = R1;
      if ((Sp + -20) < SpLim) goto cL6; else goto cL7;
  cL6:
      R1 = _sHX::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cL7:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _sHX::P32;
      P32[Sp - 20] = P32[_sHX::P32 + 8];
      I32[Sp - 16] = stg_ap_p_info;
      P32[Sp - 12] = lvl_rHo_closure+1;
      Sp = Sp - 20;
      call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(cL3, {lvl_rHo_closure}), (cL5, {lvl_rHo_closure}), (cL6, {}),
 (cL7, {lvl_rHo_closure})]



==================== after setInfoTableStackMap ====================
sat_sHX_entry() //  [R1]
        { info_tbl: [(cL5,
                      label: sat_sHX_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cL5:
          goto cL3;
      cL3:
          _sHX::P32 = R1;
          if ((Sp + -20) < SpLim) goto cL6; else goto cL7;
      cL6:
          R1 = _sHX::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cL7:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _sHX::P32;
          P32[Sp - 20] = P32[_sHX::P32 + 8];
          I32[Sp - 16] = stg_ap_p_info;
          P32[Sp - 12] = lvl_rHo_closure+1;
          Sp = Sp - 20;
          call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_sHX_entry() //  [R1]
        { info_tbl: [(cL3,
                      label: sat_sHX_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cL3:
          _sHX::P32 = R1;
          if ((Sp + -20) < SpLim) goto cL6; else goto cL7;
      cL6:
          R1 = _sHX::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cL7:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _sHX::P32;
          P32[Sp - 20] = P32[_sHX::P32 + 8];
          I32[Sp - 16] = stg_ap_p_info;
          P32[Sp - 12] = lvl_rHo_closure+1;
          Sp = Sp - 20;
          call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cLf:
      _sHE::P32 = P32[(old + 24)];
      _sHF::P32 = P32[(old + 20)];
      _sHG::P32 = P32[(old + 16)];
      _sHH::P32 = P32[(old + 12)];
      _sHI::P32 = P32[(old + 8)];
      goto cKp;
  cKp:
      if (Sp - <highSp> < SpLim) goto cLg; else goto cLh;
  cLg:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
      P32[(old + 24)] = _sHE::P32;
      P32[(old + 20)] = _sHF::P32;
      P32[(old + 16)] = _sHG::P32;
      P32[(old + 12)] = _sHH::P32;
      P32[(old + 8)] = _sHI::P32;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
  cLh:
      I32[(young<cKr> + 4)] = cKr;
      R1 = _sHI::P32;
      if (R1 & 3 != 0) goto cKr; else goto cKs;
  cKs:
      call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
  cKr:
      _sHJ::P32 = R1;
      _cLb::P32 = _sHJ::P32 & 3;
      if (_cLb::P32 >= 2) goto cLa; else goto cL9;
  cLa:
      _sHK::P32 = P32[_sHJ::P32 + 2];
      _sHL::P32 = P32[_sHJ::P32 + 6];
      _sHM::P32 = P32[_sHJ::P32 + 10];
      I32[(young<cKx> + 4)] = cKx;
      R1 = _sHH::P32;
      if (R1 & 3 != 0) goto cKx; else goto cKy;
  cKy:
      call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
  cKx:
      _sHN::P32 = R1;
      _cMc::P32 = _sHN::P32 & 3;
      if (_cMc::P32 >= 2) goto cLq; else goto cLo;
  cLq:
      _sHO::P32 = P32[_sHN::P32 + 2];
      _sHP::P32 = P32[_sHN::P32 + 6];
      _sHQ::P32 = P32[_sHN::P32 + 10];
      I32[(young<cKD> + 4)] = cKD;
      P32[(young<cKD> + 20)] = _sHE::P32;
      I32[(young<cKD> + 16)] = stg_ap_pp_info;
      P32[(young<cKD> + 12)] = _sHO::P32;
      P32[(young<cKD> + 8)] = _sHK::P32;
      call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
  cKD:
      _sHR::P32 = R1;
      _cM5::P32 = _sHR::P32 & 3;
      if (_cM5::P32 >= 2) goto cMa; else goto cLv;
  cMa:
      if (_cM5::P32 >= 3) goto cM1; else goto cLz;
  cM1:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cM3;
  cM4:
      HpAlloc = 28;
      goto cM2;
  cM2:
      R1 = _sHR::P32;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cM3:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHN::P32;
      P32[Hp - 16] = _sHM::P32;
      _cLZ::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHK::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _cLZ::P32;
      _cM0::P32 = Hp - 10;
      R1 = _cM0::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLz:
      Hp = Hp + 20;
      if (Hp > HpLim) goto cLC; else goto cLB;
  cLC:
      HpAlloc = 20;
      goto cLA;
  cLA:
      R1 = _sHR::P32;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLB:
      I32[Hp - 16] = ds1_sHT_info;
      P32[Hp - 8] = _sHG::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _sHP::P32;
      _cKI::P32 = Hp - 16;
      I32[(young<cKP> + 4)] = cKP;
      P32[(young<cKP> + 20)] = _sHE::P32;
      P32[(young<cKP> + 16)] = _sHF::P32;
      P32[(young<cKP> + 12)] = _sHG::P32;
      P32[(young<cKP> + 8)] = _sHM::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
  cKP:
      _sHW::P32 = R1;
      I32[(young<cKT> + 4)] = cKT;
      P32[(young<cKT> + 20)] = _sHE::P32;
      P32[(young<cKT> + 16)] = _sHF::P32;
      P32[(young<cKT> + 12)] = _sHG::P32;
      P32[(young<cKT> + 8)] = _sHQ::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
  cKT:
      _sHV::P32 = R1;
      I32[(young<cKX> + 4)] = cKX;
      P32[(young<cKX> + 24)] = _sHE::P32;
      P32[(young<cKX> + 20)] = _sHF::P32;
      P32[(young<cKX> + 16)] = _sHG::P32;
      P32[(young<cKX> + 12)] = _sHV::P32;
      P32[(young<cKX> + 8)] = _sHW::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
  cKX:
      _sHU::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto cLI; else goto cLH;
  cLI:
      HpAlloc = 12;
      goto cLG;
  cLG:
      R1 = _sHU::P32;
      call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
  cLH:
      I32[Hp - 8] = sat_sHX_info;
      P32[Hp] = _sHG::P32;
      _cL1::P32 = Hp - 8;
      I32[(young<cLF> + 4)] = cLF;
      P32[(young<cLF> + 20)] = _sHF::P32;
      I32[(young<cLF> + 16)] = stg_ap_pp_info;
      P32[(young<cLF> + 12)] = _cKI::P32;
      P32[(young<cLF> + 8)] = _cL1::P32;
      call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
  cLF:
      _sHY::P32 = R1;
      _cLT::P32 = _sHY::P32 & 3;
      if (_cLT::P32 >= 2) goto cLS; else goto cLO;
  cLS:
      R1 = _sHU::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cLO:
      P32[(old + 28)] = _sHE::P32;
      P32[(old + 24)] = _sHF::P32;
      P32[(old + 20)] = _sHG::P32;
      P32[(old + 16)] = _sHO::P32;
      P32[(old + 12)] = _cKI::P32;
      P32[(old + 8)] = _sHU::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cLv:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cLy; else goto cLx;
  cLy:
      HpAlloc = 28;
      goto cLw;
  cLw:
      R1 = _sHR::P32;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLx:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHJ::P32;
      P32[Hp - 16] = _sHQ::P32;
      _cLs::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHO::P32;
      P32[Hp - 4] = _sHP::P32;
      P32[Hp] = _cLs::P32;
      _cLt::P32 = Hp - 10;
      R1 = _cLt::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLo:
      R1 = _sHJ::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cL9:
      R1 = _sHH::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cLf:
      _sHE::P32 = P32[(old + 24)];
      _sHF::P32 = P32[(old + 20)];
      _sHG::P32 = P32[(old + 16)];
      _sHH::P32 = P32[(old + 12)];
      _sHI::P32 = P32[(old + 8)];
      goto cKp;
  cKp:
      if (Sp - <highSp> < SpLim) goto cLg; else goto cLh;
  cLg:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
      P32[(old + 24)] = _sHE::P32;
      P32[(old + 20)] = _sHF::P32;
      P32[(old + 16)] = _sHG::P32;
      P32[(old + 12)] = _sHH::P32;
      P32[(old + 8)] = _sHI::P32;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
  cLh:
      I32[(young<cKr> + 4)] = cKr;
      R1 = _sHI::P32;
      if (R1 & 3 != 0) goto cKr; else goto cKs;
  cKs:
      call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
  cKr:
      _sHJ::P32 = R1;
      _cLb::P32 = _sHJ::P32 & 3;
      if (_cLb::P32 >= 2) goto cLa; else goto cL9;
  cLa:
      _sHK::P32 = P32[_sHJ::P32 + 2];
      _sHL::P32 = P32[_sHJ::P32 + 6];
      _sHM::P32 = P32[_sHJ::P32 + 10];
      I32[(young<cKx> + 4)] = cKx;
      R1 = _sHH::P32;
      if (R1 & 3 != 0) goto cKx; else goto cKy;
  cKy:
      call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
  cKx:
      _sHN::P32 = R1;
      _cMc::P32 = _sHN::P32 & 3;
      if (_cMc::P32 >= 2) goto cLq; else goto cLo;
  cLq:
      _sHO::P32 = P32[_sHN::P32 + 2];
      _sHP::P32 = P32[_sHN::P32 + 6];
      _sHQ::P32 = P32[_sHN::P32 + 10];
      I32[(young<cKD> + 4)] = cKD;
      P32[(young<cKD> + 20)] = _sHE::P32;
      I32[(young<cKD> + 16)] = stg_ap_pp_info;
      P32[(young<cKD> + 12)] = _sHO::P32;
      P32[(young<cKD> + 8)] = _sHK::P32;
      call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
  cKD:
      _sHR::P32 = R1;
      _cM5::P32 = _sHR::P32 & 3;
      if (_cM5::P32 >= 2) goto cMa; else goto cLv;
  cMa:
      if (_cM5::P32 >= 3) goto cM1; else goto cLz;
  cM1:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cM3;
  cM3:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHN::P32;
      P32[Hp - 16] = _sHM::P32;
      _cLZ::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHK::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _cLZ::P32;
      _cM0::P32 = Hp - 10;
      R1 = _cM0::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLz:
      Hp = Hp + 20;
      if (Hp > HpLim) goto cLC; else goto cLB;
  cLC:
      HpAlloc = 20;
      goto cM2;
  cLB:
      I32[Hp - 16] = ds1_sHT_info;
      P32[Hp - 8] = _sHG::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _sHP::P32;
      _cKI::P32 = Hp - 16;
      I32[(young<cKP> + 4)] = cKP;
      P32[(young<cKP> + 20)] = _sHE::P32;
      P32[(young<cKP> + 16)] = _sHF::P32;
      P32[(young<cKP> + 12)] = _sHG::P32;
      P32[(young<cKP> + 8)] = _sHM::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
  cKP:
      _sHW::P32 = R1;
      I32[(young<cKT> + 4)] = cKT;
      P32[(young<cKT> + 20)] = _sHE::P32;
      P32[(young<cKT> + 16)] = _sHF::P32;
      P32[(young<cKT> + 12)] = _sHG::P32;
      P32[(young<cKT> + 8)] = _sHQ::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
  cKT:
      _sHV::P32 = R1;
      I32[(young<cKX> + 4)] = cKX;
      P32[(young<cKX> + 24)] = _sHE::P32;
      P32[(young<cKX> + 20)] = _sHF::P32;
      P32[(young<cKX> + 16)] = _sHG::P32;
      P32[(young<cKX> + 12)] = _sHV::P32;
      P32[(young<cKX> + 8)] = _sHW::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
  cKX:
      _sHU::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto cLI; else goto cLH;
  cLI:
      HpAlloc = 12;
      goto cLG;
  cLG:
      R1 = _sHU::P32;
      call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
  cLH:
      I32[Hp - 8] = sat_sHX_info;
      P32[Hp] = _sHG::P32;
      _cL1::P32 = Hp - 8;
      I32[(young<cLF> + 4)] = cLF;
      P32[(young<cLF> + 20)] = _sHF::P32;
      I32[(young<cLF> + 16)] = stg_ap_pp_info;
      P32[(young<cLF> + 12)] = _cKI::P32;
      P32[(young<cLF> + 8)] = _cL1::P32;
      call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
  cLF:
      _sHY::P32 = R1;
      _cLT::P32 = _sHY::P32 & 3;
      if (_cLT::P32 >= 2) goto cLS; else goto cLO;
  cLS:
      R1 = _sHU::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cLO:
      P32[(old + 28)] = _sHE::P32;
      P32[(old + 24)] = _sHF::P32;
      P32[(old + 20)] = _sHG::P32;
      P32[(old + 16)] = _sHO::P32;
      P32[(old + 12)] = _cKI::P32;
      P32[(old + 8)] = _sHU::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cLv:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cLx;
  cM4:
      HpAlloc = 28;
      goto cM2;
  cM2:
      R1 = _sHR::P32;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLx:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHJ::P32;
      P32[Hp - 16] = _sHQ::P32;
      _cLs::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHO::P32;
      P32[Hp - 4] = _sHP::P32;
      P32[Hp] = _cLs::P32;
      _cLt::P32 = Hp - 10;
      R1 = _cLt::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLo:
      R1 = _sHJ::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cL9:
      R1 = _sHH::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cLf:
      _sHE::P32 = P32[(old + 24)];
      _sHF::P32 = P32[(old + 20)];
      _sHG::P32 = P32[(old + 16)];
      _sHH::P32 = P32[(old + 12)];
      _sHI::P32 = P32[(old + 8)];
      goto cKp;
  cKp:
      if (Sp - <highSp> < SpLim) goto cLg; else goto cLh;
  cLg:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
      P32[(old + 24)] = _sHE::P32;
      P32[(old + 20)] = _sHF::P32;
      P32[(old + 16)] = _sHG::P32;
      P32[(old + 12)] = _sHH::P32;
      P32[(old + 8)] = _sHI::P32;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
  cLh:
      I32[(young<cKr> + 4)] = cKr;
      R1 = _sHI::P32;
      if (R1 & 3 != 0) goto cKr; else goto cKs;
  cKs:
      call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
  cKr:
      _sHJ::P32 = R1;
      _cLb::P32 = _sHJ::P32 & 3;
      if (_cLb::P32 >= 2) goto cLa; else goto cL9;
  cLa:
      _sHK::P32 = P32[_sHJ::P32 + 2];
      _sHL::P32 = P32[_sHJ::P32 + 6];
      _sHM::P32 = P32[_sHJ::P32 + 10];
      I32[(young<cKx> + 4)] = cKx;
      R1 = _sHH::P32;
      if (R1 & 3 != 0) goto cKx; else goto cKy;
  cKy:
      call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
  cKx:
      _sHN::P32 = R1;
      _cMc::P32 = _sHN::P32 & 3;
      if (_cMc::P32 >= 2) goto cLq; else goto cLo;
  cLq:
      _sHO::P32 = P32[_sHN::P32 + 2];
      _sHP::P32 = P32[_sHN::P32 + 6];
      _sHQ::P32 = P32[_sHN::P32 + 10];
      I32[(young<cKD> + 4)] = cKD;
      P32[(young<cKD> + 20)] = _sHE::P32;
      I32[(young<cKD> + 16)] = stg_ap_pp_info;
      P32[(young<cKD> + 12)] = _sHO::P32;
      P32[(young<cKD> + 8)] = _sHK::P32;
      call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
  cKD:
      _sHR::P32 = R1;
      _cM5::P32 = _sHR::P32 & 3;
      if (_cM5::P32 >= 2) goto cMa; else goto cLv;
  cMa:
      if (_cM5::P32 >= 3) goto cM1; else goto cLz;
  cM1:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cM3;
  cM3:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHN::P32;
      P32[Hp - 16] = _sHM::P32;
      _cLZ::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHK::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _cLZ::P32;
      _cM0::P32 = Hp - 10;
      R1 = _cM0::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLz:
      Hp = Hp + 20;
      if (Hp > HpLim) goto cLC; else goto cLB;
  cLC:
      HpAlloc = 20;
      goto cM2;
  cLB:
      I32[Hp - 16] = ds1_sHT_info;
      P32[Hp - 8] = _sHG::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _sHP::P32;
      _cKI::P32 = Hp - 16;
      I32[(young<cKP> + 4)] = cKP;
      P32[(young<cKP> + 20)] = _sHE::P32;
      P32[(young<cKP> + 16)] = _sHF::P32;
      P32[(young<cKP> + 12)] = _sHG::P32;
      P32[(young<cKP> + 8)] = _sHM::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
  cKP:
      _sHW::P32 = R1;
      I32[(young<cKT> + 4)] = cKT;
      P32[(young<cKT> + 20)] = _sHE::P32;
      P32[(young<cKT> + 16)] = _sHF::P32;
      P32[(young<cKT> + 12)] = _sHG::P32;
      P32[(young<cKT> + 8)] = _sHQ::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
  cKT:
      _sHV::P32 = R1;
      I32[(young<cKX> + 4)] = cKX;
      P32[(young<cKX> + 24)] = _sHE::P32;
      P32[(young<cKX> + 20)] = _sHF::P32;
      P32[(young<cKX> + 16)] = _sHG::P32;
      P32[(young<cKX> + 12)] = _sHV::P32;
      P32[(young<cKX> + 8)] = _sHW::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
  cKX:
      _sHU::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto cLI; else goto cLH;
  cLI:
      HpAlloc = 12;
      goto cLG;
  cLG:
      R1 = _sHU::P32;
      call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
  cLH:
      I32[Hp - 8] = sat_sHX_info;
      P32[Hp] = _sHG::P32;
      _cL1::P32 = Hp - 8;
      I32[(young<cLF> + 4)] = cLF;
      P32[(young<cLF> + 20)] = _sHF::P32;
      I32[(young<cLF> + 16)] = stg_ap_pp_info;
      P32[(young<cLF> + 12)] = _cKI::P32;
      P32[(young<cLF> + 8)] = _cL1::P32;
      call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
  cLF:
      _sHY::P32 = R1;
      _cLT::P32 = _sHY::P32 & 3;
      if (_cLT::P32 >= 2) goto cLS; else goto cLO;
  cLS:
      R1 = _sHU::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cLO:
      P32[(old + 28)] = _sHE::P32;
      P32[(old + 24)] = _sHF::P32;
      P32[(old + 20)] = _sHG::P32;
      P32[(old + 16)] = _sHO::P32;
      P32[(old + 12)] = _cKI::P32;
      P32[(old + 8)] = _sHU::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cLv:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cLx;
  cM4:
      HpAlloc = 28;
      goto cM2;
  cM2:
      R1 = _sHR::P32;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLx:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHJ::P32;
      P32[Hp - 16] = _sHQ::P32;
      _cLs::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHO::P32;
      P32[Hp - 4] = _sHP::P32;
      P32[Hp] = _cLs::P32;
      _cLt::P32 = Hp - 10;
      R1 = _cLt::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLo:
      R1 = _sHJ::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cL9:
      R1 = _sHH::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cLf:
      _sHE::P32 = P32[Sp];
      _sHF::P32 = P32[Sp + 4];
      _sHG::P32 = P32[Sp + 8];
      _sHH::P32 = P32[Sp + 12];
      _sHI::P32 = P32[Sp + 16];
      goto cKp;
  cKp:
      if (Sp - 48 < SpLim) goto cLg; else goto cLh;
  cLg:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
  cLh:
      I32[Sp - 4] = cKr;
      R1 = _sHI::P32;
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto cKr; else goto cKs;
  cKs:
      call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
  cKr:
      _sHE::P32 = P32[Sp + 4];
      _sHF::P32 = P32[Sp + 8];
      _sHG::P32 = P32[Sp + 12];
      _sHH::P32 = P32[Sp + 16];
      _sHJ::P32 = R1;
      _cLb::P32 = _sHJ::P32 & 3;
      if (_cLb::P32 >= 2) goto cLa; else goto cL9;
  cLa:
      _sHK::P32 = P32[_sHJ::P32 + 2];
      _sHL::P32 = P32[_sHJ::P32 + 6];
      _sHM::P32 = P32[_sHJ::P32 + 10];
      I32[Sp - 8] = cKx;
      R1 = _sHH::P32;
      P32[Sp - 4] = _sHM::P32;
      P32[Sp] = _sHL::P32;
      P32[Sp + 16] = _sHK::P32;
      P32[Sp + 20] = _sHJ::P32;
      Sp = Sp - 8;
      if (R1 & 3 != 0) goto cKx; else goto cKy;
  cKy:
      call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
  cKx:
      _sHE::P32 = P32[Sp + 12];
      _sHF::P32 = P32[Sp + 16];
      _sHG::P32 = P32[Sp + 20];
      _sHJ::P32 = P32[Sp + 28];
      _sHK::P32 = P32[Sp + 24];
      _sHL::P32 = P32[Sp + 8];
      _sHM::P32 = P32[Sp + 4];
      _sHN::P32 = R1;
      _cMc::P32 = _sHN::P32 & 3;
      if (_cMc::P32 >= 2) goto cLq; else goto cLo;
  cLq:
      _sHO::P32 = P32[_sHN::P32 + 2];
      _sHP::P32 = P32[_sHN::P32 + 6];
      _sHQ::P32 = P32[_sHN::P32 + 10];
      I32[Sp - 16] = cKD;
      P32[Sp - 32] = _sHE::P32;
      I32[Sp - 28] = stg_ap_pp_info;
      P32[Sp - 24] = _sHO::P32;
      P32[Sp - 20] = _sHK::P32;
      P32[Sp - 12] = _sHO::P32;
      P32[Sp - 8] = _sHP::P32;
      P32[Sp - 4] = _sHQ::P32;
      P32[Sp] = _sHN::P32;
      Sp = Sp - 32;
      call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
  cKD:
      _sHE::P32 = P32[Sp + 28];
      _sHF::P32 = P32[Sp + 32];
      _sHG::P32 = P32[Sp + 36];
      _sHJ::P32 = P32[Sp + 44];
      _sHK::P32 = P32[Sp + 40];
      _sHL::P32 = P32[Sp + 24];
      _sHM::P32 = P32[Sp + 20];
      _sHN::P32 = P32[Sp + 16];
      _sHO::P32 = P32[Sp + 4];
      _sHP::P32 = P32[Sp + 8];
      _sHQ::P32 = P32[Sp + 12];
      _sHR::P32 = R1;
      _cM5::P32 = _sHR::P32 & 3;
      if (_cM5::P32 >= 2) goto cMa; else goto cLv;
  cMa:
      if (_cM5::P32 >= 3) goto cM1; else goto cLz;
  cM1:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cM3;
  cM3:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHN::P32;
      P32[Hp - 16] = _sHM::P32;
      _cLZ::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHK::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _cLZ::P32;
      _cM0::P32 = Hp - 10;
      R1 = _cM0::P32;
      Sp = Sp + 48;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cLz:
      Hp = Hp + 20;
      if (Hp > HpLim) goto cLC; else goto cLB;
  cLC:
      HpAlloc = 20;
      goto cM2;
  cLB:
      I32[Hp - 16] = ds1_sHT_info;
      P32[Hp - 8] = _sHG::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _sHP::P32;
      _cKI::P32 = Hp - 16;
      I32[Sp] = cKP;
      P32[Sp - 16] = _sHE::P32;
      P32[Sp - 12] = _sHF::P32;
      P32[Sp - 8] = _sHG::P32;
      P32[Sp - 4] = _sHM::P32;
      P32[Sp + 44] = _cKI::P32;
      Sp = Sp - 16;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
  cKP:
      _cKI::P32 = P32[Sp + 44];
      _sHE::P32 = P32[Sp + 28];
      _sHF::P32 = P32[Sp + 32];
      _sHG::P32 = P32[Sp + 36];
      _sHO::P32 = P32[Sp + 4];
      _sHQ::P32 = P32[Sp + 12];
      _sHW::P32 = R1;
      I32[Sp] = cKT;
      P32[Sp - 16] = _sHE::P32;
      P32[Sp - 12] = _sHF::P32;
      P32[Sp - 8] = _sHG::P32;
      P32[Sp - 4] = _sHQ::P32;
      P32[Sp + 40] = _sHW::P32;
      Sp = Sp - 16;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
  cKT:
      _cKI::P32 = P32[Sp + 44];
      _sHE::P32 = P32[Sp + 28];
      _sHF::P32 = P32[Sp + 32];
      _sHG::P32 = P32[Sp + 36];
      _sHO::P32 = P32[Sp + 4];
      _sHW::P32 = P32[Sp + 40];
      _sHV::P32 = R1;
      I32[Sp] = cKX;
      P32[Sp - 20] = _sHE::P32;
      P32[Sp - 16] = _sHF::P32;
      P32[Sp - 12] = _sHG::P32;
      P32[Sp - 8] = _sHV::P32;
      P32[Sp - 4] = _sHW::P32;
      Sp = Sp - 20;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
  cKX:
      _cKI::P32 = P32[Sp + 44];
      _sHE::P32 = P32[Sp + 28];
      _sHF::P32 = P32[Sp + 32];
      _sHG::P32 = P32[Sp + 36];
      _sHO::P32 = P32[Sp + 4];
      _sHU::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto cLI; else goto cLH;
  cLI:
      HpAlloc = 12;
      goto cLG;
  cLG:
      R1 = _sHU::P32;
      call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
  cLH:
      I32[Hp - 8] = sat_sHX_info;
      P32[Hp] = _sHG::P32;
      _cL1::P32 = Hp - 8;
      I32[Sp] = cLF;
      P32[Sp - 16] = _sHF::P32;
      I32[Sp - 12] = stg_ap_pp_info;
      P32[Sp - 8] = _cKI::P32;
      P32[Sp - 4] = _cL1::P32;
      P32[Sp + 40] = _sHU::P32;
      Sp = Sp - 16;
      call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
  cLF:
      _cKI::P32 = P32[Sp + 44];
      _sHE::P32 = P32[Sp + 28];
      _sHF::P32 = P32[Sp + 32];
      _sHG::P32 = P32[Sp + 36];
      _sHO::P32 = P32[Sp + 4];
      _sHU::P32 = P32[Sp + 40];
      _sHY::P32 = R1;
      _cLT::P32 = _sHY::P32 & 3;
      if (_cLT::P32 >= 2) goto cLS; else goto cLO;
  cLS:
      R1 = _sHU::P32 & (-4);
      Sp = Sp + 48;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cLO:
      P32[Sp + 24] = _sHE::P32;
      P32[Sp + 28] = _sHF::P32;
      P32[Sp + 32] = _sHG::P32;
      P32[Sp + 36] = _sHO::P32;
      P32[Sp + 40] = _cKI::P32;
      P32[Sp + 44] = _sHU::P32;
      Sp = Sp + 24;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cLv:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cLx;
  cM4:
      HpAlloc = 28;
      goto cM2;
  cM2:
      R1 = _sHR::P32;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLx:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHJ::P32;
      P32[Hp - 16] = _sHQ::P32;
      _cLs::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHO::P32;
      P32[Hp - 4] = _sHP::P32;
      P32[Hp] = _cLs::P32;
      _cLt::P32 = Hp - 10;
      R1 = _cLt::P32;
      Sp = Sp + 48;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cLo:
      R1 = _sHJ::P32 & (-4);
      Sp = Sp + 32;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cL9:
      R1 = _sHH::P32 & (-4);
      Sp = Sp + 24;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cLf:
      goto cKp;
  cKp:
      if ((Sp + -48) < SpLim) goto cLg; else goto cLh;
  cLg:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
  cLh:
      I32[Sp - 4] = cKr;
      R1 = P32[Sp + 16];
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto cKr; else goto cKs;
  cKs:
      call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
  cKr:
      _sHH::P32 = P32[Sp + 16];
      _sHJ::P32 = R1;
      if (_sHJ::P32 & 3 >= 2) goto cLa; else goto cL9;
  cLa:
      I32[Sp - 8] = cKx;
      R1 = _sHH::P32;
      P32[Sp - 4] = P32[_sHJ::P32 + 10];
      P32[Sp] = P32[_sHJ::P32 + 6];
      P32[Sp + 16] = P32[_sHJ::P32 + 2];
      P32[Sp + 20] = _sHJ::P32;
      Sp = Sp - 8;
      if (R1 & 3 != 0) goto cKx; else goto cKy;
  cKy:
      call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
  cKx:
      _sHN::P32 = R1;
      if (_sHN::P32 & 3 >= 2) goto cLq; else goto cLo;
  cLq:
      I32[Sp - 16] = cKD;
      P32[Sp - 32] = P32[Sp + 12];
      I32[Sp - 28] = stg_ap_pp_info;
      _sHO::P32 = P32[_sHN::P32 + 2];
      P32[Sp - 24] = _sHO::P32;
      P32[Sp - 20] = P32[Sp + 24];
      P32[Sp - 12] = _sHO::P32;
      P32[Sp - 8] = P32[_sHN::P32 + 6];
      P32[Sp - 4] = P32[_sHN::P32 + 10];
      P32[Sp] = _sHN::P32;
      Sp = Sp - 32;
      call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
  cKD:
      _sHP::P32 = P32[Sp + 8];
      _sHR::P32 = R1;
      _cM5::P32 = _sHR::P32 & 3;
      if (_cM5::P32 >= 2) goto cMa; else goto cLv;
  cMa:
      _sHL::P32 = P32[Sp + 24];
      _sHM::P32 = P32[Sp + 20];
      if (_cM5::P32 >= 3) goto cM1; else goto cLz;
  cM1:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cM3;
  cM3:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = P32[Sp + 16];
      P32[Hp - 16] = _sHM::P32;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = P32[Sp + 40];
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = Hp - 22;
      R1 = Hp - 10;
      Sp = Sp + 48;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cLz:
      Hp = Hp + 20;
      if (Hp > HpLim) goto cLC; else goto cLB;
  cLC:
      HpAlloc = 20;
      goto cM2;
  cLB:
      I32[Hp - 16] = ds1_sHT_info;
      _sHG::P32 = P32[Sp + 36];
      P32[Hp - 8] = _sHG::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _sHP::P32;
      I32[Sp] = cKP;
      P32[Sp - 16] = P32[Sp + 28];
      P32[Sp - 12] = P32[Sp + 32];
      P32[Sp - 8] = _sHG::P32;
      P32[Sp - 4] = _sHM::P32;
      P32[Sp + 44] = Hp - 16;
      Sp = Sp - 16;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
  cKP:
      I32[Sp] = cKT;
      P32[Sp - 16] = P32[Sp + 28];
      P32[Sp - 12] = P32[Sp + 32];
      P32[Sp - 8] = P32[Sp + 36];
      P32[Sp - 4] = P32[Sp + 12];
      P32[Sp + 40] = R1;
      Sp = Sp - 16;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
  cKT:
      I32[Sp] = cKX;
      P32[Sp - 20] = P32[Sp + 28];
      P32[Sp - 16] = P32[Sp + 32];
      P32[Sp - 12] = P32[Sp + 36];
      P32[Sp - 8] = R1;
      P32[Sp - 4] = P32[Sp + 40];
      Sp = Sp - 20;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
  cKX:
      Hp = Hp + 12;
      _sHU::P32 = R1;
      if (Hp > HpLim) goto cLI; else goto cLH;
  cLI:
      HpAlloc = 12;
      goto cLG;
  cLG:
      R1 = _sHU::P32;
      call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
  cLH:
      I32[Hp - 8] = sat_sHX_info;
      P32[Hp] = P32[Sp + 36];
      I32[Sp] = cLF;
      P32[Sp - 16] = P32[Sp + 32];
      I32[Sp - 12] = stg_ap_pp_info;
      P32[Sp - 8] = P32[Sp + 44];
      P32[Sp - 4] = Hp - 8;
      P32[Sp + 40] = _sHU::P32;
      Sp = Sp - 16;
      call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
  cLF:
      _sHU::P32 = P32[Sp + 40];
      if (R1 & 3 >= 2) goto cLS; else goto cLO;
  cLS:
      R1 = _sHU::P32 & (-4);
      Sp = Sp + 48;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cLO:
      P32[Sp + 24] = P32[Sp + 28];
      P32[Sp + 28] = P32[Sp + 32];
      P32[Sp + 32] = P32[Sp + 36];
      P32[Sp + 36] = P32[Sp + 4];
      P32[Sp + 40] = P32[Sp + 44];
      P32[Sp + 44] = _sHU::P32;
      Sp = Sp + 24;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cLv:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cLx;
  cM4:
      HpAlloc = 28;
      goto cM2;
  cM2:
      R1 = _sHR::P32;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLx:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = P32[Sp + 44];
      P32[Hp - 16] = P32[Sp + 12];
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = P32[Sp + 4];
      P32[Hp - 4] = _sHP::P32;
      P32[Hp] = Hp - 22;
      R1 = Hp - 10;
      Sp = Sp + 48;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cLo:
      R1 = P32[Sp + 28] & (-4);
      Sp = Sp + 32;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cL9:
      R1 = _sHH::P32 & (-4);
      Sp = Sp + 24;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cKp,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cKr,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cKs,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cKx,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cKy,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cKD,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cKP,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, sat_sHX_closure}),
 (cKT,
  {T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, sat_sHX_closure}),
 (cKX,
  {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure,
   sat_sHX_closure}),
 (cL9, {}),
 (cLa,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLf,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLg, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cLh,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLo, {}),
 (cLq,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLv,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLx, {}),
 (cLz,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLB,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLC,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLF, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cLG,
  {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure,
   sat_sHX_closure}),
 (cLH,
  {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure,
   sat_sHX_closure}),
 (cLI,
  {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure,
   sat_sHX_closure}),
 (cLO, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cLS, {}),
 (cM1,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cM2,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cM3, {}),
 (cM4,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cMa,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_$cunion_entry() //  []
        { info_tbl: [(cKr,
                      label: block_cKr_info
                      rep:StackRep [False, False, False, False, True]),
                     (cKx,
                      label: block_cKx_info
                      rep:StackRep [False, False, False, False, False, False, False]),
                     (cKD,
                      label: block_cKD_info
                      rep:StackRep [False, False, False, False, False, False, False,
                                    False, False, False, False]),
                     (cKP,
                      label: block_cKP_info
                      rep:StackRep [False, True, False, True, True, True, False, False,
                                    False, True, False]),
                     (cKT,
                      label: block_cKT_info
                      rep:StackRep [False, True, True, True, True, True, False, False,
                                    False, False, False]),
                     (cKX,
                      label: block_cKX_info
                      rep:StackRep [False, True, True, True, True, True, False, False,
                                    False, True, False]),
                     (cLf,
                      label: T2902_B_PairingSum.$fSumPSumab_$cunion_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 23} }),
                     (cLF,
                      label: block_cLF_info
                      rep:StackRep [False, True, True, True, True, True, False, False,
                                    False, False, False])]
          stack_info: arg_space: 24 updfr_space: Just 4
        }
    {offset
      cLf:
          goto cKp;
      cKp:
          if ((Sp + -48) < SpLim) goto cLg; else goto cLh;
      cLg:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
      cLh:
          I32[Sp - 4] = cKr;
          R1 = P32[Sp + 16];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto cKr; else goto cKs;
      cKs:
          call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
      cKr:
          _sHH::P32 = P32[Sp + 16];
          _sHJ::P32 = R1;
          if (_sHJ::P32 & 3 >= 2) goto cLa; else goto cL9;
      cLa:
          I32[Sp - 8] = cKx;
          R1 = _sHH::P32;
          P32[Sp - 4] = P32[_sHJ::P32 + 10];
          P32[Sp] = P32[_sHJ::P32 + 6];
          P32[Sp + 16] = P32[_sHJ::P32 + 2];
          P32[Sp + 20] = _sHJ::P32;
          Sp = Sp - 8;
          if (R1 & 3 != 0) goto cKx; else goto cKy;
      cKy:
          call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
      cKx:
          _sHN::P32 = R1;
          if (_sHN::P32 & 3 >= 2) goto cLq; else goto cLo;
      cLq:
          I32[Sp - 16] = cKD;
          P32[Sp - 32] = P32[Sp + 12];
          I32[Sp - 28] = stg_ap_pp_info;
          _sHO::P32 = P32[_sHN::P32 + 2];
          P32[Sp - 24] = _sHO::P32;
          P32[Sp - 20] = P32[Sp + 24];
          P32[Sp - 12] = _sHO::P32;
          P32[Sp - 8] = P32[_sHN::P32 + 6];
          P32[Sp - 4] = P32[_sHN::P32 + 10];
          P32[Sp] = _sHN::P32;
          Sp = Sp - 32;
          call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
      cKD:
          _sHP::P32 = P32[Sp + 8];
          _sHR::P32 = R1;
          _cM5::P32 = _sHR::P32 & 3;
          if (_cM5::P32 >= 2) goto cMa; else goto cLv;
      cMa:
          _sHL::P32 = P32[Sp + 24];
          _sHM::P32 = P32[Sp + 20];
          if (_cM5::P32 >= 3) goto cM1; else goto cLz;
      cM1:
          Hp = Hp + 28;
          if (Hp > HpLim) goto cM4; else goto cM3;
      cM3:
          I32[Hp - 24] = :_con_info;
          P32[Hp - 20] = P32[Sp + 16];
          P32[Hp - 16] = _sHM::P32;
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp + 40];
          P32[Hp - 4] = _sHL::P32;
          P32[Hp] = Hp - 22;
          R1 = Hp - 10;
          Sp = Sp + 48;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cLz:
          Hp = Hp + 20;
          if (Hp > HpLim) goto cLC; else goto cLB;
      cLC:
          HpAlloc = 20;
          goto cM2;
      cLB:
          I32[Hp - 16] = ds1_sHT_info;
          _sHG::P32 = P32[Sp + 36];
          P32[Hp - 8] = _sHG::P32;
          P32[Hp - 4] = _sHL::P32;
          P32[Hp] = _sHP::P32;
          I32[Sp] = cKP;
          P32[Sp - 16] = P32[Sp + 28];
          P32[Sp - 12] = P32[Sp + 32];
          P32[Sp - 8] = _sHG::P32;
          P32[Sp - 4] = _sHM::P32;
          P32[Sp + 44] = Hp - 16;
          Sp = Sp - 16;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
      cKP:
          I32[Sp] = cKT;
          P32[Sp - 16] = P32[Sp + 28];
          P32[Sp - 12] = P32[Sp + 32];
          P32[Sp - 8] = P32[Sp + 36];
          P32[Sp - 4] = P32[Sp + 12];
          P32[Sp + 40] = R1;
          Sp = Sp - 16;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
      cKT:
          I32[Sp] = cKX;
          P32[Sp - 20] = P32[Sp + 28];
          P32[Sp - 16] = P32[Sp + 32];
          P32[Sp - 12] = P32[Sp + 36];
          P32[Sp - 8] = R1;
          P32[Sp - 4] = P32[Sp + 40];
          Sp = Sp - 20;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
      cKX:
          Hp = Hp + 12;
          _sHU::P32 = R1;
          if (Hp > HpLim) goto cLI; else goto cLH;
      cLI:
          HpAlloc = 12;
          goto cLG;
      cLG:
          R1 = _sHU::P32;
          call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
      cLH:
          I32[Hp - 8] = sat_sHX_info;
          P32[Hp] = P32[Sp + 36];
          I32[Sp] = cLF;
          P32[Sp - 16] = P32[Sp + 32];
          I32[Sp - 12] = stg_ap_pp_info;
          P32[Sp - 8] = P32[Sp + 44];
          P32[Sp - 4] = Hp - 8;
          P32[Sp + 40] = _sHU::P32;
          Sp = Sp - 16;
          call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
      cLF:
          _sHU::P32 = P32[Sp + 40];
          if (R1 & 3 >= 2) goto cLS; else goto cLO;
      cLS:
          R1 = _sHU::P32 & (-4);
          Sp = Sp + 48;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
      cLO:
          P32[Sp + 24] = P32[Sp + 28];
          P32[Sp + 28] = P32[Sp + 32];
          P32[Sp + 32] = P32[Sp + 36];
          P32[Sp + 36] = P32[Sp + 4];
          P32[Sp + 40] = P32[Sp + 44];
          P32[Sp + 44] = _sHU::P32;
          Sp = Sp + 24;
          call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
      cLv:
          Hp = Hp + 28;
          if (Hp > HpLim) goto cM4; else goto cLx;
      cM4:
          HpAlloc = 28;
          goto cM2;
      cM2:
          R1 = _sHR::P32;
          call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
      cLx:
          I32[Hp - 24] = :_con_info;
          P32[Hp - 20] = P32[Sp + 44];
          P32[Hp - 16] = P32[Sp + 12];
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp + 4];
          P32[Hp - 4] = _sHP::P32;
          P32[Hp] = Hp - 22;
          R1 = Hp - 10;
          Sp = Sp + 48;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cLo:
          R1 = P32[Sp + 28] & (-4);
          Sp = Sp + 32;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
      cL9:
          R1 = _sHH::P32 & (-4);
          Sp = Sp + 24;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_$cunion_entry() //  []
        { info_tbl: [(cKp,
                      label: T2902_B_PairingSum.$fSumPSumab_$cunion_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 23} }),
                     (cKr,
                      label: block_cKr_info
                      rep:StackRep [False, False, False, False, True]),
                     (cKx,
                      label: block_cKx_info
                      rep:StackRep [False, False, False, False, False, False, False]),
                     (cKD,
                      label: block_cKD_info
                      rep:StackRep [False, False, False, False, False, False, False,
                                    False, False, False, False]),
                     (cKP,
                      label: block_cKP_info
                      rep:StackRep [False, True, False, True, True, True, False, False,
                                    False, True, False]),
                     (cKT,
                      label: block_cKT_info
                      rep:StackRep [False, True, True, True, True, True, False, False,
                                    False, False, False]),
                     (cKX,
                      label: block_cKX_info
                      rep:StackRep [False, True, True, True, True, True, False, False,
                                    False, True, False]),
                     (cLF,
                      label: block_cLF_info
                      rep:StackRep [False, True, True, True, True, True, False, False,
                                    False, False, False])]
          stack_info: arg_space: 24 updfr_space: Just 4
        }
    {offset
      cKp:
          if ((Sp + -48) < SpLim) goto cLg; else goto cLh;
      cLg:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
      cLh:
          I32[Sp - 4] = cKr;
          R1 = P32[Sp + 16];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto cKr; else goto cKs;
      cKs:
          call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
      cKr:
          _sHH::P32 = P32[Sp + 16];
          _sHJ::P32 = R1;
          if (_sHJ::P32 & 3 >= 2) goto cLa; else goto cL9;
      cLa:
          I32[Sp - 8] = cKx;
          R1 = _sHH::P32;
          P32[Sp - 4] = P32[_sHJ::P32 + 10];
          P32[Sp] = P32[_sHJ::P32 + 6];
          P32[Sp + 16] = P32[_sHJ::P32 + 2];
          P32[Sp + 20] = _sHJ::P32;
          Sp = Sp - 8;
          if (R1 & 3 != 0) goto cKx; else goto cKy;
      cKy:
          call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
      cKx:
          _sHN::P32 = R1;
          if (_sHN::P32 & 3 >= 2) goto cLq; else goto cLo;
      cLq:
          I32[Sp - 16] = cKD;
          P32[Sp - 32] = P32[Sp + 12];
          I32[Sp - 28] = stg_ap_pp_info;
          _sHO::P32 = P32[_sHN::P32 + 2];
          P32[Sp - 24] = _sHO::P32;
          P32[Sp - 20] = P32[Sp + 24];
          P32[Sp - 12] = _sHO::P32;
          P32[Sp - 8] = P32[_sHN::P32 + 6];
          P32[Sp - 4] = P32[_sHN::P32 + 10];
          P32[Sp] = _sHN::P32;
          Sp = Sp - 32;
          call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
      cKD:
          _sHP::P32 = P32[Sp + 8];
          _sHR::P32 = R1;
          _cM5::P32 = _sHR::P32 & 3;
          if (_cM5::P32 >= 2) goto cMa; else goto cLv;
      cMa:
          _sHL::P32 = P32[Sp + 24];
          _sHM::P32 = P32[Sp + 20];
          if (_cM5::P32 >= 3) goto cM1; else goto cLz;
      cM1:
          Hp = Hp + 28;
          if (Hp > HpLim) goto cM4; else goto cM3;
      cM3:
          I32[Hp - 24] = :_con_info;
          P32[Hp - 20] = P32[Sp + 16];
          P32[Hp - 16] = _sHM::P32;
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp + 40];
          P32[Hp - 4] = _sHL::P32;
          P32[Hp] = Hp - 22;
          R1 = Hp - 10;
          Sp = Sp + 48;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cLz:
          Hp = Hp + 20;
          if (Hp > HpLim) goto cLC; else goto cLB;
      cLC:
          HpAlloc = 20;
          goto cM2;
      cLB:
          I32[Hp - 16] = ds1_sHT_info;
          _sHG::P32 = P32[Sp + 36];
          P32[Hp - 8] = _sHG::P32;
          P32[Hp - 4] = _sHL::P32;
          P32[Hp] = _sHP::P32;
          I32[Sp] = cKP;
          P32[Sp - 16] = P32[Sp + 28];
          P32[Sp - 12] = P32[Sp + 32];
          P32[Sp - 8] = _sHG::P32;
          P32[Sp - 4] = _sHM::P32;
          P32[Sp + 44] = Hp - 16;
          Sp = Sp - 16;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
      cKP:
          I32[Sp] = cKT;
          P32[Sp - 16] = P32[Sp + 28];
          P32[Sp - 12] = P32[Sp + 32];
          P32[Sp - 8] = P32[Sp + 36];
          P32[Sp - 4] = P32[Sp + 12];
          P32[Sp + 40] = R1;
          Sp = Sp - 16;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
      cKT:
          I32[Sp] = cKX;
          P32[Sp - 20] = P32[Sp + 28];
          P32[Sp - 16] = P32[Sp + 32];
          P32[Sp - 12] = P32[Sp + 36];
          P32[Sp - 8] = R1;
          P32[Sp - 4] = P32[Sp + 40];
          Sp = Sp - 20;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
      cKX:
          Hp = Hp + 12;
          _sHU::P32 = R1;
          if (Hp > HpLim) goto cLI; else goto cLH;
      cLI:
          HpAlloc = 12;
          goto cLG;
      cLG:
          R1 = _sHU::P32;
          call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
      cLH:
          I32[Hp - 8] = sat_sHX_info;
          P32[Hp] = P32[Sp + 36];
          I32[Sp] = cLF;
          P32[Sp - 16] = P32[Sp + 32];
          I32[Sp - 12] = stg_ap_pp_info;
          P32[Sp - 8] = P32[Sp + 44];
          P32[Sp - 4] = Hp - 8;
          P32[Sp + 40] = _sHU::P32;
          Sp = Sp - 16;
          call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
      cLF:
          _sHU::P32 = P32[Sp + 40];
          if (R1 & 3 >= 2) goto cLS; else goto cLO;
      cLS:
          R1 = _sHU::P32 & (-4);
          Sp = Sp + 48;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
      cLO:
          P32[Sp + 24] = P32[Sp + 28];
          P32[Sp + 28] = P32[Sp + 32];
          P32[Sp + 32] = P32[Sp + 36];
          P32[Sp + 36] = P32[Sp + 4];
          P32[Sp + 40] = P32[Sp + 44];
          P32[Sp + 44] = _sHU::P32;
          Sp = Sp + 24;
          call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
      cLv:
          Hp = Hp + 28;
          if (Hp > HpLim) goto cM4; else goto cLx;
      cM4:
          HpAlloc = 28;
          goto cM2;
      cM2:
          R1 = _sHR::P32;
          call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
      cLx:
          I32[Hp - 24] = :_con_info;
          P32[Hp - 20] = P32[Sp + 44];
          P32[Hp - 16] = P32[Sp + 12];
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp + 4];
          P32[Hp - 4] = _sHP::P32;
          P32[Hp] = Hp - 22;
          R1 = Hp - 10;
          Sp = Sp + 48;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cLo:
          R1 = P32[Sp + 28] & (-4);
          Sp = Sp + 32;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
      cL9:
          R1 = _sHH::P32 & (-4);
          Sp = Sp + 24;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cMk:
      _sI0::P32 = P32[(old + 28)];
      _sI1::P32 = P32[(old + 24)];
      _sI2::P32 = P32[(old + 20)];
      _sI3::P32 = P32[(old + 16)];
      _sI4::P32 = P32[(old + 12)];
      _sI5::P32 = P32[(old + 8)];
      goto cMh;
  cMh:
      if (Sp - <highSp> < SpLim) goto cMl; else goto cMm;
  cMm:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cMo; else goto cMn;
  cMo:
      HpAlloc = 16;
      goto cMl;
  cMl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
      P32[(old + 28)] = _sI0::P32;
      P32[(old + 24)] = _sI1::P32;
      P32[(old + 20)] = _sI2::P32;
      P32[(old + 16)] = _sI3::P32;
      P32[(old + 12)] = _sI4::P32;
      P32[(old + 8)] = _sI5::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  cMn:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sI3::P32;
      P32[Hp - 4] = _sI4::P32;
      P32[Hp] = GHC.Types.[]_closure+1;
      _cMj::P32 = Hp - 10;
      P32[(old + 24)] = _sI0::P32;
      P32[(old + 20)] = _sI1::P32;
      P32[(old + 16)] = _sI2::P32;
      P32[(old + 12)] = _cMj::P32;
      P32[(old + 8)] = _sI5::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cMk:
      _sI0::P32 = P32[(old + 28)];
      _sI1::P32 = P32[(old + 24)];
      _sI2::P32 = P32[(old + 20)];
      _sI3::P32 = P32[(old + 16)];
      _sI4::P32 = P32[(old + 12)];
      _sI5::P32 = P32[(old + 8)];
      goto cMh;
  cMh:
      if (Sp - <highSp> < SpLim) goto cMl; else goto cMm;
  cMm:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cMo; else goto cMn;
  cMo:
      HpAlloc = 16;
      goto cMl;
  cMl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
      P32[(old + 28)] = _sI0::P32;
      P32[(old + 24)] = _sI1::P32;
      P32[(old + 20)] = _sI2::P32;
      P32[(old + 16)] = _sI3::P32;
      P32[(old + 12)] = _sI4::P32;
      P32[(old + 8)] = _sI5::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  cMn:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sI3::P32;
      P32[Hp - 4] = _sI4::P32;
      P32[Hp] = GHC.Types.[]_closure+1;
      _cMj::P32 = Hp - 10;
      P32[(old + 24)] = _sI0::P32;
      P32[(old + 20)] = _sI1::P32;
      P32[(old + 16)] = _sI2::P32;
      P32[(old + 12)] = _cMj::P32;
      P32[(old + 8)] = _sI5::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cMk:
      _sI0::P32 = P32[(old + 28)];
      _sI1::P32 = P32[(old + 24)];
      _sI2::P32 = P32[(old + 20)];
      _sI3::P32 = P32[(old + 16)];
      _sI4::P32 = P32[(old + 12)];
      _sI5::P32 = P32[(old + 8)];
      goto cMh;
  cMh:
      if (Sp - <highSp> < SpLim) goto cMl; else goto cMm;
  cMm:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cMo; else goto cMn;
  cMo:
      HpAlloc = 16;
      goto cMl;
  cMl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
      P32[(old + 28)] = _sI0::P32;
      P32[(old + 24)] = _sI1::P32;
      P32[(old + 20)] = _sI2::P32;
      P32[(old + 16)] = _sI3::P32;
      P32[(old + 12)] = _sI4::P32;
      P32[(old + 8)] = _sI5::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  cMn:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sI3::P32;
      P32[Hp - 4] = _sI4::P32;
      P32[Hp] = GHC.Types.[]_closure+1;
      _cMj::P32 = Hp - 10;
      P32[(old + 24)] = _sI0::P32;
      P32[(old + 20)] = _sI1::P32;
      P32[(old + 16)] = _sI2::P32;
      P32[(old + 12)] = _cMj::P32;
      P32[(old + 8)] = _sI5::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cMk:
      _sI0::P32 = P32[Sp];
      _sI1::P32 = P32[Sp + 4];
      _sI2::P32 = P32[Sp + 8];
      _sI3::P32 = P32[Sp + 12];
      _sI4::P32 = P32[Sp + 16];
      _sI5::P32 = P32[Sp + 20];
      goto cMh;
  cMh:
      goto cMm;
  cMm:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cMo; else goto cMn;
  cMo:
      HpAlloc = 16;
      goto cMl;
  cMl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  cMn:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sI3::P32;
      P32[Hp - 4] = _sI4::P32;
      P32[Hp] = GHC.Types.[]_closure+1;
      _cMj::P32 = Hp - 10;
      P32[Sp + 4] = _sI0::P32;
      P32[Sp + 8] = _sI1::P32;
      P32[Sp + 12] = _sI2::P32;
      P32[Sp + 16] = _cMj::P32;
      Sp = Sp + 4;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cMk:
      goto cMh;
  cMh:
      goto cMm;
  cMm:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cMo; else goto cMn;
  cMo:
      HpAlloc = 16;
      goto cMl;
  cMl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  cMn:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = P32[Sp + 12];
      P32[Hp - 4] = P32[Sp + 16];
      P32[Hp] = GHC.Types.[]_closure+1;
      _sI1::P32 = P32[Sp + 4];
      P32[Sp + 4] = P32[Sp];
      _sI2::P32 = P32[Sp + 8];
      P32[Sp + 8] = _sI1::P32;
      P32[Sp + 12] = _sI2::P32;
      P32[Sp + 16] = Hp - 10;
      Sp = Sp + 4;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cMh,
  {T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cMk,
  {T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cMl, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cMm,
  {T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cMn, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cMo, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_$cinsert_entry() //  []
        { info_tbl: [(cMk,
                      label: T2902_B_PairingSum.$fSumPSumab_$cinsert_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 28 updfr_space: Just 4
        }
    {offset
      cMk:
          goto cMh;
      cMh:
          goto cMm;
      cMm:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cMo; else goto cMn;
      cMo:
          HpAlloc = 16;
          goto cMl;
      cMl:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
          call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
      cMn:
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp + 12];
          P32[Hp - 4] = P32[Sp + 16];
          P32[Hp] = GHC.Types.[]_closure+1;
          _sI1::P32 = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp];
          _sI2::P32 = P32[Sp + 8];
          P32[Sp + 8] = _sI1::P32;
          P32[Sp + 12] = _sI2::P32;
          P32[Sp + 16] = Hp - 10;
          Sp = Sp + 4;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_$cinsert_entry() //  []
        { info_tbl: [(cMm,
                      label: T2902_B_PairingSum.$fSumPSumab_$cinsert_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 28 updfr_space: Just 4
        }
    {offset
      cMm:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cMo; else goto cMn;
      cMo:
          HpAlloc = 16;
          goto cMl;
      cMl:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
          call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
      cMn:
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp + 12];
          P32[Hp - 4] = P32[Sp + 16];
          P32[Hp] = GHC.Types.[]_closure+1;
          _sI1::P32 = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp];
          _sI2::P32 = P32[Sp + 8];
          P32[Sp + 8] = _sI1::P32;
          P32[Sp + 12] = _sI2::P32;
          P32[Sp + 16] = Hp - 10;
          Sp = Sp + 4;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cunions_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cunions_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cunions_entry() //  []
         { info_tbl: [(cJD,
                       label: T2902_B_PairingSum.$fSumPSumab_$cunions_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cJF,
                       label: block_cJF_info
                       rep:StackRep [False, False, False, True]),
                      (cJX,
                       label: block_cJX_info
                       rep:StackRep [False, False, False, False]),
                      (cK8,
                       label: block_cK8_info
                       rep:StackRep [False, False, False, False, False]),
                      (cKc,
                       label: block_cKc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cJD:
           if ((Sp + -24) < SpLim) goto cJQ; else goto cJR;
       cJQ:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cJR:
           I32[Sp - 4] = cJF;
           R1 = P32[Sp + 12];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto cJF; else goto cJG;
       cJG:
           call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
       cJF:
           _sHw::P32 = R1;
           if (_sHw::P32 & 3 >= 2) goto cJK; else goto cJJ;
       cJK:
           I32[Sp] = cJX;
           R1 = P32[_sHw::P32 + 6];
           P32[Sp + 16] = P32[_sHw::P32 + 2];
           if (R1 & 3 != 0) goto cJX; else goto cJZ;
       cJZ:
           call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
       cJX:
           _sHz::P32 = R1;
           if (_sHz::P32 & 3 >= 2) goto cKe; else goto cK5;
       cKe:
           I32[Sp - 4] = cK8;
           P32[Sp - 20] = P32[Sp + 4];
           P32[Sp - 16] = P32[Sp + 8];
           P32[Sp - 12] = P32[Sp + 12];
           P32[Sp - 8] = P32[_sHz::P32 + 6];
           P32[Sp] = P32[_sHz::P32 + 2];
           Sp = Sp - 20;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
       cK8:
           _sHA::P32 = P32[Sp + 4];
           I32[Sp + 4] = cKc;
           P32[Sp - 16] = P32[Sp + 8];
           P32[Sp - 12] = P32[Sp + 12];
           P32[Sp - 8] = P32[Sp + 16];
           P32[Sp - 4] = P32[Sp + 20];
           P32[Sp] = _sHA::P32;
           P32[Sp + 20] = R1;
           Sp = Sp - 16;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
       cKc:
           P32[Sp] = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp + 8];
           P32[Sp + 8] = P32[Sp + 12];
           P32[Sp + 12] = R1;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
       cK5:
           R1 = P32[Sp + 16] & (-4);
           Sp = Sp + 20;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cJJ:
           R1 = T2902_B_PairingSum.Empty_closure+1;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 },
 section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cunion_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cunion_info;
         const 0;
 },
 ds1_sHT_entry() //  [R1]
         { info_tbl: [(cKK,
                       label: ds1_sHT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cKK:
           _sHT::P32 = R1;
           if ((Sp + -24) < SpLim) goto cKN; else goto cKO;
       cKN:
           R1 = _sHT::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cKO:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _sHT::P32;
           P32[Sp - 24] = P32[_sHT::P32 + 8];
           I32[Sp - 20] = stg_ap_pp_info;
           P32[Sp - 16] = P32[_sHT::P32 + 16];
           P32[Sp - 12] = P32[_sHT::P32 + 12];
           Sp = Sp - 24;
           call GHC.Num.+_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_sHX_entry() //  [R1]
         { info_tbl: [(cL3,
                       label: sat_sHX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cL3:
           _sHX::P32 = R1;
           if ((Sp + -20) < SpLim) goto cL6; else goto cL7;
       cL6:
           R1 = _sHX::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cL7:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _sHX::P32;
           P32[Sp - 20] = P32[_sHX::P32 + 8];
           I32[Sp - 16] = stg_ap_p_info;
           P32[Sp - 12] = lvl_rHo_closure+1;
           Sp = Sp - 20;
           call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$cunion_entry() //  []
         { info_tbl: [(cKp,
                       label: T2902_B_PairingSum.$fSumPSumab_$cunion_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 23} }),
                      (cKr,
                       label: block_cKr_info
                       rep:StackRep [False, False, False, False, True]),
                      (cKx,
                       label: block_cKx_info
                       rep:StackRep [False, False, False, False, False, False, False]),
                      (cKD,
                       label: block_cKD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False]),
                      (cKP,
                       label: block_cKP_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     False, True, False]),
                      (cKT,
                       label: block_cKT_info
                       rep:StackRep [False, True, True, True, True, True, False, False,
                                     False, False, False]),
                      (cKX,
                       label: block_cKX_info
                       rep:StackRep [False, True, True, True, True, True, False, False,
                                     False, True, False]),
                      (cLF,
                       label: block_cLF_info
                       rep:StackRep [False, True, True, True, True, True, False, False,
                                     False, False, False])]
           stack_info: arg_space: 24 updfr_space: Just 4
         }
     {offset
       cKp:
           if ((Sp + -48) < SpLim) goto cLg; else goto cLh;
       cLg:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
       cLh:
           I32[Sp - 4] = cKr;
           R1 = P32[Sp + 16];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto cKr; else goto cKs;
       cKs:
           call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
       cKr:
           _sHH::P32 = P32[Sp + 16];
           _sHJ::P32 = R1;
           if (_sHJ::P32 & 3 >= 2) goto cLa; else goto cL9;
       cLa:
           I32[Sp - 8] = cKx;
           R1 = _sHH::P32;
           P32[Sp - 4] = P32[_sHJ::P32 + 10];
           P32[Sp] = P32[_sHJ::P32 + 6];
           P32[Sp + 16] = P32[_sHJ::P32 + 2];
           P32[Sp + 20] = _sHJ::P32;
           Sp = Sp - 8;
           if (R1 & 3 != 0) goto cKx; else goto cKy;
       cKy:
           call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
       cKx:
           _sHN::P32 = R1;
           if (_sHN::P32 & 3 >= 2) goto cLq; else goto cLo;
       cLq:
           I32[Sp - 16] = cKD;
           P32[Sp - 32] = P32[Sp + 12];
           I32[Sp - 28] = stg_ap_pp_info;
           _sHO::P32 = P32[_sHN::P32 + 2];
           P32[Sp - 24] = _sHO::P32;
           P32[Sp - 20] = P32[Sp + 24];
           P32[Sp - 12] = _sHO::P32;
           P32[Sp - 8] = P32[_sHN::P32 + 6];
           P32[Sp - 4] = P32[_sHN::P32 + 10];
           P32[Sp] = _sHN::P32;
           Sp = Sp - 32;
           call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
       cKD:
           _sHP::P32 = P32[Sp + 8];
           _sHR::P32 = R1;
           _cM5::P32 = _sHR::P32 & 3;
           if (_cM5::P32 >= 2) goto cMa; else goto cLv;
       cMa:
           _sHL::P32 = P32[Sp + 24];
           _sHM::P32 = P32[Sp + 20];
           if (_cM5::P32 >= 3) goto cM1; else goto cLz;
       cM1:
           Hp = Hp + 28;
           if (Hp > HpLim) goto cM4; else goto cM3;
       cM3:
           I32[Hp - 24] = :_con_info;
           P32[Hp - 20] = P32[Sp + 16];
           P32[Hp - 16] = _sHM::P32;
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp + 40];
           P32[Hp - 4] = _sHL::P32;
           P32[Hp] = Hp - 22;
           R1 = Hp - 10;
           Sp = Sp + 48;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cLz:
           Hp = Hp + 20;
           if (Hp > HpLim) goto cLC; else goto cLB;
       cLC:
           HpAlloc = 20;
           goto cM2;
       cLB:
           I32[Hp - 16] = ds1_sHT_info;
           _sHG::P32 = P32[Sp + 36];
           P32[Hp - 8] = _sHG::P32;
           P32[Hp - 4] = _sHL::P32;
           P32[Hp] = _sHP::P32;
           I32[Sp] = cKP;
           P32[Sp - 16] = P32[Sp + 28];
           P32[Sp - 12] = P32[Sp + 32];
           P32[Sp - 8] = _sHG::P32;
           P32[Sp - 4] = _sHM::P32;
           P32[Sp + 44] = Hp - 16;
           Sp = Sp - 16;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
       cKP:
           I32[Sp] = cKT;
           P32[Sp - 16] = P32[Sp + 28];
           P32[Sp - 12] = P32[Sp + 32];
           P32[Sp - 8] = P32[Sp + 36];
           P32[Sp - 4] = P32[Sp + 12];
           P32[Sp + 40] = R1;
           Sp = Sp - 16;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
       cKT:
           I32[Sp] = cKX;
           P32[Sp - 20] = P32[Sp + 28];
           P32[Sp - 16] = P32[Sp + 32];
           P32[Sp - 12] = P32[Sp + 36];
           P32[Sp - 8] = R1;
           P32[Sp - 4] = P32[Sp + 40];
           Sp = Sp - 20;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
       cKX:
           Hp = Hp + 12;
           _sHU::P32 = R1;
           if (Hp > HpLim) goto cLI; else goto cLH;
       cLI:
           HpAlloc = 12;
           goto cLG;
       cLG:
           R1 = _sHU::P32;
           call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
       cLH:
           I32[Hp - 8] = sat_sHX_info;
           P32[Hp] = P32[Sp + 36];
           I32[Sp] = cLF;
           P32[Sp - 16] = P32[Sp + 32];
           I32[Sp - 12] = stg_ap_pp_info;
           P32[Sp - 8] = P32[Sp + 44];
           P32[Sp - 4] = Hp - 8;
           P32[Sp + 40] = _sHU::P32;
           Sp = Sp - 16;
           call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
       cLF:
           _sHU::P32 = P32[Sp + 40];
           if (R1 & 3 >= 2) goto cLS; else goto cLO;
       cLS:
           R1 = _sHU::P32 & (-4);
           Sp = Sp + 48;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cLO:
           P32[Sp + 24] = P32[Sp + 28];
           P32[Sp + 28] = P32[Sp + 32];
           P32[Sp + 32] = P32[Sp + 36];
           P32[Sp + 36] = P32[Sp + 4];
           P32[Sp + 40] = P32[Sp + 44];
           P32[Sp + 44] = _sHU::P32;
           Sp = Sp + 24;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
       cLv:
           Hp = Hp + 28;
           if (Hp > HpLim) goto cM4; else goto cLx;
       cM4:
           HpAlloc = 28;
           goto cM2;
       cM2:
           R1 = _sHR::P32;
           call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
       cLx:
           I32[Hp - 24] = :_con_info;
           P32[Hp - 20] = P32[Sp + 44];
           P32[Hp - 16] = P32[Sp + 12];
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp + 4];
           P32[Hp - 4] = _sHP::P32;
           P32[Hp] = Hp - 22;
           R1 = Hp - 10;
           Sp = Sp + 48;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cLo:
           R1 = P32[Sp + 28] & (-4);
           Sp = Sp + 32;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cL9:
           R1 = _sHH::P32 & (-4);
           Sp = Sp + 24;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
     }
 },
 section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cinsert_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cinsert_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cinsert_entry() //  []
         { info_tbl: [(cMm,
                       label: T2902_B_PairingSum.$fSumPSumab_$cinsert_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 28 updfr_space: Just 4
         }
     {offset
       cMm:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cMo; else goto cMn;
       cMo:
           HpAlloc = 16;
           goto cMl;
       cMl:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
           call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
       cMn:
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp + 12];
           P32[Hp - 4] = P32[Sp + 16];
           P32[Hp] = GHC.Types.[]_closure+1;
           _sI1::P32 = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp];
           _sI2::P32 = P32[Sp + 8];
           P32[Sp + 8] = _sI1::P32;
           P32[Sp + 12] = _sI2::P32;
           P32[Sp + 16] = Hp - 10;
           Sp = Sp + 4;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cunions_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cunions_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cunions_entry() //  []
         { info_tbl: [(cJD,
                       label: T2902_B_PairingSum.$fSumPSumab_$cunions_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cJF,
                       label: block_cJF_info
                       rep:StackRep [False, False, False, True]),
                      (cJX,
                       label: block_cJX_info
                       rep:StackRep [False, False, False, False]),
                      (cK8,
                       label: block_cK8_info
                       rep:StackRep [False, False, False, False, False]),
                      (cKc,
                       label: block_cKc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cJD:
           if ((Sp + -24) < SpLim) goto cJQ; else goto cJR;
       cJQ:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cJR:
           I32[Sp - 4] = cJF;
           R1 = P32[Sp + 12];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto cJF; else goto cJG;
       cJG:
           call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
       cJF:
           _sHw::P32 = R1;
           if (_sHw::P32 & 3 >= 2) goto cJK; else goto cJJ;
       cJK:
           I32[Sp] = cJX;
           R1 = P32[_sHw::P32 + 6];
           P32[Sp + 16] = P32[_sHw::P32 + 2];
           if (R1 & 3 != 0) goto cJX; else goto cJZ;
       cJZ:
           call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
       cJX:
           _sHz::P32 = R1;
           if (_sHz::P32 & 3 >= 2) goto cKe; else goto cK5;
       cKe:
           I32[Sp - 4] = cK8;
           P32[Sp - 20] = P32[Sp + 4];
           P32[Sp - 16] = P32[Sp + 8];
           P32[Sp - 12] = P32[Sp + 12];
           P32[Sp - 8] = P32[_sHz::P32 + 6];
           P32[Sp] = P32[_sHz::P32 + 2];
           Sp = Sp - 20;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
       cK8:
           _sHA::P32 = P32[Sp + 4];
           I32[Sp + 4] = cKc;
           P32[Sp - 16] = P32[Sp + 8];
           P32[Sp - 12] = P32[Sp + 12];
           P32[Sp - 8] = P32[Sp + 16];
           P32[Sp - 4] = P32[Sp + 20];
           P32[Sp] = _sHA::P32;
           P32[Sp + 20] = R1;
           Sp = Sp - 16;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
       cKc:
           P32[Sp] = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp + 8];
           P32[Sp + 8] = P32[Sp + 12];
           P32[Sp + 12] = R1;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
       cK5:
           R1 = P32[Sp + 16] & (-4);
           Sp = Sp + 20;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cJJ:
           R1 = T2902_B_PairingSum.Empty_closure+1;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 },
 section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cunion_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cunion_info;
         const 0;
 },
 ds1_sHT_entry() //  [R1]
         { info_tbl: [(cKK,
                       label: ds1_sHT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cKK:
           _sHT::P32 = R1;
           if ((Sp + -24) < SpLim) goto cKN; else goto cKO;
       cKN:
           R1 = _sHT::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cKO:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _sHT::P32;
           P32[Sp - 24] = P32[_sHT::P32 + 8];
           I32[Sp - 20] = stg_ap_pp_info;
           P32[Sp - 16] = P32[_sHT::P32 + 16];
           P32[Sp - 12] = P32[_sHT::P32 + 12];
           Sp = Sp - 24;
           call GHC.Num.+_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_sHX_entry() //  [R1]
         { info_tbl: [(cL3,
                       label: sat_sHX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cL3:
           _sHX::P32 = R1;
           if ((Sp + -20) < SpLim) goto cL6; else goto cL7;
       cL6:
           R1 = _sHX::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cL7:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _sHX::P32;
           P32[Sp - 20] = P32[_sHX::P32 + 8];
           I32[Sp - 16] = stg_ap_p_info;
           P32[Sp - 12] = lvl_rHo_closure+1;
           Sp = Sp - 20;
           call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$cunion_entry() //  []
         { info_tbl: [(cKp,
                       label: T2902_B_PairingSum.$fSumPSumab_$cunion_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 23} }),
                      (cKr,
                       label: block_cKr_info
                       rep:StackRep [False, False, False, False, True]),
                      (cKx,
                       label: block_cKx_info
                       rep:StackRep [False, False, False, False, False, False, False]),
                      (cKD,
                       label: block_cKD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False]),
                      (cKP,
                       label: block_cKP_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     False, True, False]),
                      (cKT,
                       label: block_cKT_info
                       rep:StackRep [False, True, True, True, True, True, False, False,
                                     False, False, False]),
                      (cKX,
                       label: block_cKX_info
                       rep:StackRep [False, True, True, True, True, True, False, False,
                                     False, True, False]),
                      (cLF,
                       label: block_cLF_info
                       rep:StackRep [False, True, True, True, True, True, False, False,
                                     False, False, False])]
           stack_info: arg_space: 24 updfr_space: Just 4
         }
     {offset
       cKp:
           if ((Sp + -48) < SpLim) goto cLg; else goto cLh;
       cLg:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
       cLh:
           I32[Sp - 4] = cKr;
           R1 = P32[Sp + 16];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto cKr; else goto cKs;
       cKs:
           call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
       cKr:
           _sHH::P32 = P32[Sp + 16];
           _sHJ::P32 = R1;
           if (_sHJ::P32 & 3 >= 2) goto cLa; else goto cL9;
       cLa:
           I32[Sp - 8] = cKx;
           R1 = _sHH::P32;
           P32[Sp - 4] = P32[_sHJ::P32 + 10];
           P32[Sp] = P32[_sHJ::P32 + 6];
           P32[Sp + 16] = P32[_sHJ::P32 + 2];
           P32[Sp + 20] = _sHJ::P32;
           Sp = Sp - 8;
           if (R1 & 3 != 0) goto cKx; else goto cKy;
       cKy:
           call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
       cKx:
           _sHN::P32 = R1;
           if (_sHN::P32 & 3 >= 2) goto cLq; else goto cLo;
       cLq:
           I32[Sp - 16] = cKD;
           P32[Sp - 32] = P32[Sp + 12];
           I32[Sp - 28] = stg_ap_pp_info;
           _sHO::P32 = P32[_sHN::P32 + 2];
           P32[Sp - 24] = _sHO::P32;
           P32[Sp - 20] = P32[Sp + 24];
           P32[Sp - 12] = _sHO::P32;
           P32[Sp - 8] = P32[_sHN::P32 + 6];
           P32[Sp - 4] = P32[_sHN::P32 + 10];
           P32[Sp] = _sHN::P32;
           Sp = Sp - 32;
           call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
       cKD:
           _sHP::P32 = P32[Sp + 8];
           _sHR::P32 = R1;
           _cM5::P32 = _sHR::P32 & 3;
           if (_cM5::P32 >= 2) goto cMa; else goto cLv;
       cMa:
           _sHL::P32 = P32[Sp + 24];
           _sHM::P32 = P32[Sp + 20];
           if (_cM5::P32 >= 3) goto cM1; else goto cLz;
       cM1:
           Hp = Hp + 28;
           if (Hp > HpLim) goto cM4; else goto cM3;
       cM3:
           I32[Hp - 24] = :_con_info;
           P32[Hp - 20] = P32[Sp + 16];
           P32[Hp - 16] = _sHM::P32;
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp + 40];
           P32[Hp - 4] = _sHL::P32;
           P32[Hp] = Hp - 22;
           R1 = Hp - 10;
           Sp = Sp + 48;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cLz:
           Hp = Hp + 20;
           if (Hp > HpLim) goto cLC; else goto cLB;
       cLC:
           HpAlloc = 20;
           goto cM2;
       cLB:
           I32[Hp - 16] = ds1_sHT_info;
           _sHG::P32 = P32[Sp + 36];
           P32[Hp - 8] = _sHG::P32;
           P32[Hp - 4] = _sHL::P32;
           P32[Hp] = _sHP::P32;
           I32[Sp] = cKP;
           P32[Sp - 16] = P32[Sp + 28];
           P32[Sp - 12] = P32[Sp + 32];
           P32[Sp - 8] = _sHG::P32;
           P32[Sp - 4] = _sHM::P32;
           P32[Sp + 44] = Hp - 16;
           Sp = Sp - 16;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
       cKP:
           I32[Sp] = cKT;
           P32[Sp - 16] = P32[Sp + 28];
           P32[Sp - 12] = P32[Sp + 32];
           P32[Sp - 8] = P32[Sp + 36];
           P32[Sp - 4] = P32[Sp + 12];
           P32[Sp + 40] = R1;
           Sp = Sp - 16;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
       cKT:
           I32[Sp] = cKX;
           P32[Sp - 20] = P32[Sp + 28];
           P32[Sp - 16] = P32[Sp + 32];
           P32[Sp - 12] = P32[Sp + 36];
           P32[Sp - 8] = R1;
           P32[Sp - 4] = P32[Sp + 40];
           Sp = Sp - 20;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
       cKX:
           Hp = Hp + 12;
           _sHU::P32 = R1;
           if (Hp > HpLim) goto cLI; else goto cLH;
       cLI:
           HpAlloc = 12;
           goto cLG;
       cLG:
           R1 = _sHU::P32;
           call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
       cLH:
           I32[Hp - 8] = sat_sHX_info;
           P32[Hp] = P32[Sp + 36];
           I32[Sp] = cLF;
           P32[Sp - 16] = P32[Sp + 32];
           I32[Sp - 12] = stg_ap_pp_info;
           P32[Sp - 8] = P32[Sp + 44];
           P32[Sp - 4] = Hp - 8;
           P32[Sp + 40] = _sHU::P32;
           Sp = Sp - 16;
           call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
       cLF:
           _sHU::P32 = P32[Sp + 40];
           if (R1 & 3 >= 2) goto cLS; else goto cLO;
       cLS:
           R1 = _sHU::P32 & (-4);
           Sp = Sp + 48;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cLO:
           P32[Sp + 24] = P32[Sp + 28];
           P32[Sp + 28] = P32[Sp + 32];
           P32[Sp + 32] = P32[Sp + 36];
           P32[Sp + 36] = P32[Sp + 4];
           P32[Sp + 40] = P32[Sp + 44];
           P32[Sp + 44] = _sHU::P32;
           Sp = Sp + 24;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
       cLv:
           Hp = Hp + 28;
           if (Hp > HpLim) goto cM4; else goto cLx;
       cM4:
           HpAlloc = 28;
           goto cM2;
       cM2:
           R1 = _sHR::P32;
           call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
       cLx:
           I32[Hp - 24] = :_con_info;
           P32[Hp - 20] = P32[Sp + 44];
           P32[Hp - 16] = P32[Sp + 12];
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp + 4];
           P32[Hp - 4] = _sHP::P32;
           P32[Hp] = Hp - 22;
           R1 = Hp - 10;
           Sp = Sp + 48;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cLo:
           R1 = P32[Sp + 28] & (-4);
           Sp = Sp + 32;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cL9:
           R1 = _sHH::P32 & (-4);
           Sp = Sp + 24;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
     }
 },
 section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cinsert_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cinsert_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cinsert_entry() //  []
         { info_tbl: [(cMm,
                       label: T2902_B_PairingSum.$fSumPSumab_$cinsert_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 28 updfr_space: Just 4
         }
     {offset
       cMm:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cMo; else goto cMn;
       cMo:
           HpAlloc = 16;
           goto cMl;
       cMl:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
           call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
       cMn:
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp + 12];
           P32[Hp - 4] = P32[Sp + 16];
           P32[Hp] = GHC.Types.[]_closure+1;
           _sI1::P32 = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp];
           _sI2::P32 = P32[Sp + 8];
           P32[Sp + 8] = _sI1::P32;
           P32[Sp + 12] = _sI2::P32;
           P32[Sp + 16] = Hp - 10;
           Sp = Sp + 4;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cextractMin_info;
         const 0;
 },
 sat_sIg_entry() //  [R1]
         { info_tbl: [(cO8,
                       label: sat_sIg_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cO8:
           _sIg::P32 = R1;
           goto cO6;
       cO6:
           if (Sp - <highSp> < SpLim) goto cO9; else goto cOa;
       cO9:
           R1 = _sIg::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cOa:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _sIg::P32;
           _sI7::P32 = P32[_sIg::P32 + 8];
           _sI8::P32 = P32[_sIg::P32 + 12];
           _sI9::P32 = P32[_sIg::P32 + 16];
           _sIe::P32 = P32[_sIg::P32 + 20];
           P32[(old + 28)] = _sI7::P32;
           P32[(old + 24)] = _sI8::P32;
           P32[(old + 20)] = _sI9::P32;
           P32[(old + 16)] = _sIe::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$cextractMin_entry() //  []
         { info_tbl: [(cOi,
                       label: T2902_B_PairingSum.$fSumPSumab_$cextractMin_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cOi:
           _sI7::P32 = P32[(old + 20)];
           _sI8::P32 = P32[(old + 16)];
           _sI9::P32 = P32[(old + 12)];
           _sIa::P32 = P32[(old + 8)];
           goto cNW;
       cNW:
           if (Sp - <highSp> < SpLim) goto cOj; else goto cOk;
       cOj:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
           P32[(old + 20)] = _sI7::P32;
           P32[(old + 16)] = _sI8::P32;
           P32[(old + 12)] = _sI9::P32;
           P32[(old + 8)] = _sIa::P32;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cOk:
           I32[(young<cNY> + 4)] = cNY;
           R1 = _sIa::P32;
           if (R1 & 3 != 0) goto cNY; else goto cNZ;
       cNZ:
           call (I32[R1])(R1) returns to cNY, args: 4, res: 4, upd: 4;
       cNY:
           _sIb::P32 = R1;
           _cOe::P32 = _sIb::P32 & 3;
           if (_cOe::P32 >= 2) goto cOg; else goto cOh;
       cOg:
           goto cOd;
       cOd:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cOr; else goto cOq;
       cOr:
           HpAlloc = 48;
           goto cOp;
       cOp:
           R1 = _sIb::P32;
           call stg_gc_unpt_r1(R1) returns to cNY, args: 4, res: 4, upd: 4;
       cOq:
           _sIc::P32 = P32[_sIb::P32 + 2];
           _sId::P32 = P32[_sIb::P32 + 6];
           _sIe::P32 = P32[_sIb::P32 + 10];
           I32[Hp - 44] = sat_sIg_info;
           P32[Hp - 36] = _sI7::P32;
           P32[Hp - 32] = _sI8::P32;
           P32[Hp - 28] = _sI9::P32;
           P32[Hp - 24] = _sIe::P32;
           _cO4::P32 = Hp - 44;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _sIc::P32;
           P32[Hp - 12] = _sId::P32;
           _cOn::P32 = Hp - 19;
           I32[Hp - 8] = (,)_con_info;
           P32[Hp - 4] = _cOn::P32;
           P32[Hp] = _cO4::P32;
           _cOo::P32 = Hp - 7;
           R1 = _cOo::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
       cOh:
           goto cOc;
       cOc:
           R1 = GHC.Err.undefined_closure;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cO8:
      _sIg::P32 = R1;
      goto cO6;
  cO6:
      if (Sp - <highSp> < SpLim) goto cO9; else goto cOa;
  cO9:
      R1 = _sIg::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cOa:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sIg::P32;
      _sI7::P32 = P32[_sIg::P32 + 8];
      _sI8::P32 = P32[_sIg::P32 + 12];
      _sI9::P32 = P32[_sIg::P32 + 16];
      _sIe::P32 = P32[_sIg::P32 + 20];
      P32[(old + 28)] = _sI7::P32;
      P32[(old + 24)] = _sI8::P32;
      P32[(old + 20)] = _sI9::P32;
      P32[(old + 16)] = _sIe::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  cO8:
      _sIg::P32 = R1;
      goto cO6;
  cO6:
      if (Sp - <highSp> < SpLim) goto cO9; else goto cOa;
  cO9:
      R1 = _sIg::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cOa:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sIg::P32;
      _sI7::P32 = P32[_sIg::P32 + 8];
      _sI8::P32 = P32[_sIg::P32 + 12];
      _sI9::P32 = P32[_sIg::P32 + 16];
      _sIe::P32 = P32[_sIg::P32 + 20];
      P32[(old + 28)] = _sI7::P32;
      P32[(old + 24)] = _sI8::P32;
      P32[(old + 20)] = _sI9::P32;
      P32[(old + 16)] = _sIe::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  cO8:
      _sIg::P32 = R1;
      goto cO6;
  cO6:
      if (Sp - <highSp> < SpLim) goto cO9; else goto cOa;
  cO9:
      R1 = _sIg::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cOa:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sIg::P32;
      _sI7::P32 = P32[_sIg::P32 + 8];
      _sI8::P32 = P32[_sIg::P32 + 12];
      _sI9::P32 = P32[_sIg::P32 + 16];
      _sIe::P32 = P32[_sIg::P32 + 20];
      P32[(old + 28)] = _sI7::P32;
      P32[(old + 24)] = _sI8::P32;
      P32[(old + 20)] = _sI9::P32;
      P32[(old + 16)] = _sIe::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  cO8:
      _sIg::P32 = R1;
      goto cO6;
  cO6:
      if (Sp - 24 < SpLim) goto cO9; else goto cOa;
  cO9:
      R1 = _sIg::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cOa:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _sIg::P32;
      _sI7::P32 = P32[_sIg::P32 + 8];
      _sI8::P32 = P32[_sIg::P32 + 12];
      _sI9::P32 = P32[_sIg::P32 + 16];
      _sIe::P32 = P32[_sIg::P32 + 20];
      P32[Sp - 24] = _sI7::P32;
      P32[Sp - 20] = _sI8::P32;
      P32[Sp - 16] = _sI9::P32;
      P32[Sp - 12] = _sIe::P32;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  cO8:
      goto cO6;
  cO6:
      _sIg::P32 = R1;
      if ((Sp + -24) < SpLim) goto cO9; else goto cOa;
  cO9:
      R1 = _sIg::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cOa:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _sIg::P32;
      P32[Sp - 24] = P32[_sIg::P32 + 8];
      P32[Sp - 20] = P32[_sIg::P32 + 12];
      P32[Sp - 16] = P32[_sIg::P32 + 16];
      P32[Sp - 12] = P32[_sIg::P32 + 20];
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(cO6, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cO8, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cO9, {}),
 (cOa, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure})]



==================== after setInfoTableStackMap ====================
sat_sIg_entry() //  [R1]
        { info_tbl: [(cO8,
                      label: sat_sIg_info
                      rep:HeapRep 4 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cO8:
          goto cO6;
      cO6:
          _sIg::P32 = R1;
          if ((Sp + -24) < SpLim) goto cO9; else goto cOa;
      cO9:
          R1 = _sIg::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cOa:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _sIg::P32;
          P32[Sp - 24] = P32[_sIg::P32 + 8];
          P32[Sp - 20] = P32[_sIg::P32 + 12];
          P32[Sp - 16] = P32[_sIg::P32 + 16];
          P32[Sp - 12] = P32[_sIg::P32 + 20];
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_sIg_entry() //  [R1]
        { info_tbl: [(cO6,
                      label: sat_sIg_info
                      rep:HeapRep 4 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cO6:
          _sIg::P32 = R1;
          if ((Sp + -24) < SpLim) goto cO9; else goto cOa;
      cO9:
          R1 = _sIg::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cOa:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _sIg::P32;
          P32[Sp - 24] = P32[_sIg::P32 + 8];
          P32[Sp - 20] = P32[_sIg::P32 + 12];
          P32[Sp - 16] = P32[_sIg::P32 + 16];
          P32[Sp - 12] = P32[_sIg::P32 + 20];
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cOi:
      _sI7::P32 = P32[(old + 20)];
      _sI8::P32 = P32[(old + 16)];
      _sI9::P32 = P32[(old + 12)];
      _sIa::P32 = P32[(old + 8)];
      goto cNW;
  cNW:
      if (Sp - <highSp> < SpLim) goto cOj; else goto cOk;
  cOj:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
      P32[(old + 20)] = _sI7::P32;
      P32[(old + 16)] = _sI8::P32;
      P32[(old + 12)] = _sI9::P32;
      P32[(old + 8)] = _sIa::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cOk:
      I32[(young<cNY> + 4)] = cNY;
      R1 = _sIa::P32;
      if (R1 & 3 != 0) goto cNY; else goto cNZ;
  cNZ:
      call (I32[R1])(R1) returns to cNY, args: 4, res: 4, upd: 4;
  cNY:
      _sIb::P32 = R1;
      _cOe::P32 = _sIb::P32 & 3;
      if (_cOe::P32 >= 2) goto cOd; else goto cOc;
  cOd:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cOr; else goto cOq;
  cOr:
      HpAlloc = 48;
      goto cOp;
  cOp:
      R1 = _sIb::P32;
      call stg_gc_unpt_r1(R1) returns to cNY, args: 4, res: 4, upd: 4;
  cOq:
      _sIc::P32 = P32[_sIb::P32 + 2];
      _sId::P32 = P32[_sIb::P32 + 6];
      _sIe::P32 = P32[_sIb::P32 + 10];
      I32[Hp - 44] = sat_sIg_info;
      P32[Hp - 36] = _sI7::P32;
      P32[Hp - 32] = _sI8::P32;
      P32[Hp - 28] = _sI9::P32;
      P32[Hp - 24] = _sIe::P32;
      _cO4::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIc::P32;
      P32[Hp - 12] = _sId::P32;
      _cOn::P32 = Hp - 19;
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _cOn::P32;
      P32[Hp] = _cO4::P32;
      _cOo::P32 = Hp - 7;
      R1 = _cOo::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cOc:
      R1 = GHC.Err.undefined_closure;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cOi:
      _sI7::P32 = P32[(old + 20)];
      _sI8::P32 = P32[(old + 16)];
      _sI9::P32 = P32[(old + 12)];
      _sIa::P32 = P32[(old + 8)];
      goto cNW;
  cNW:
      if (Sp - <highSp> < SpLim) goto cOj; else goto cOk;
  cOj:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
      P32[(old + 20)] = _sI7::P32;
      P32[(old + 16)] = _sI8::P32;
      P32[(old + 12)] = _sI9::P32;
      P32[(old + 8)] = _sIa::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cOk:
      I32[(young<cNY> + 4)] = cNY;
      R1 = _sIa::P32;
      if (R1 & 3 != 0) goto cNY; else goto cNZ;
  cNZ:
      call (I32[R1])(R1) returns to cNY, args: 4, res: 4, upd: 4;
  cNY:
      _sIb::P32 = R1;
      _cOe::P32 = _sIb::P32 & 3;
      if (_cOe::P32 >= 2) goto cOd; else goto cOc;
  cOd:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cOr; else goto cOq;
  cOr:
      HpAlloc = 48;
      goto cOp;
  cOp:
      R1 = _sIb::P32;
      call stg_gc_unpt_r1(R1) returns to cNY, args: 4, res: 4, upd: 4;
  cOq:
      _sIc::P32 = P32[_sIb::P32 + 2];
      _sId::P32 = P32[_sIb::P32 + 6];
      _sIe::P32 = P32[_sIb::P32 + 10];
      I32[Hp - 44] = sat_sIg_info;
      P32[Hp - 36] = _sI7::P32;
      P32[Hp - 32] = _sI8::P32;
      P32[Hp - 28] = _sI9::P32;
      P32[Hp - 24] = _sIe::P32;
      _cO4::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIc::P32;
      P32[Hp - 12] = _sId::P32;
      _cOn::P32 = Hp - 19;
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _cOn::P32;
      P32[Hp] = _cO4::P32;
      _cOo::P32 = Hp - 7;
      R1 = _cOo::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cOc:
      R1 = GHC.Err.undefined_closure;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cOi:
      _sI7::P32 = P32[(old + 20)];
      _sI8::P32 = P32[(old + 16)];
      _sI9::P32 = P32[(old + 12)];
      _sIa::P32 = P32[(old + 8)];
      goto cNW;
  cNW:
      if (Sp - <highSp> < SpLim) goto cOj; else goto cOk;
  cOj:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
      P32[(old + 20)] = _sI7::P32;
      P32[(old + 16)] = _sI8::P32;
      P32[(old + 12)] = _sI9::P32;
      P32[(old + 8)] = _sIa::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cOk:
      I32[(young<cNY> + 4)] = cNY;
      R1 = _sIa::P32;
      if (R1 & 3 != 0) goto cNY; else goto cNZ;
  cNZ:
      call (I32[R1])(R1) returns to cNY, args: 4, res: 4, upd: 4;
  cNY:
      _sIb::P32 = R1;
      _cOe::P32 = _sIb::P32 & 3;
      if (_cOe::P32 >= 2) goto cOd; else goto cOc;
  cOd:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cOr; else goto cOq;
  cOr:
      HpAlloc = 48;
      goto cOp;
  cOp:
      R1 = _sIb::P32;
      call stg_gc_unpt_r1(R1) returns to cNY, args: 4, res: 4, upd: 4;
  cOq:
      _sIc::P32 = P32[_sIb::P32 + 2];
      _sId::P32 = P32[_sIb::P32 + 6];
      _sIe::P32 = P32[_sIb::P32 + 10];
      I32[Hp - 44] = sat_sIg_info;
      P32[Hp - 36] = _sI7::P32;
      P32[Hp - 32] = _sI8::P32;
      P32[Hp - 28] = _sI9::P32;
      P32[Hp - 24] = _sIe::P32;
      _cO4::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIc::P32;
      P32[Hp - 12] = _sId::P32;
      _cOn::P32 = Hp - 19;
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _cOn::P32;
      P32[Hp] = _cO4::P32;
      _cOo::P32 = Hp - 7;
      R1 = _cOo::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cOc:
      R1 = GHC.Err.undefined_closure;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cOi:
      _sI7::P32 = P32[Sp];
      _sI8::P32 = P32[Sp + 4];
      _sI9::P32 = P32[Sp + 8];
      _sIa::P32 = P32[Sp + 12];
      goto cNW;
  cNW:
      if (Sp - 4 < SpLim) goto cOj; else goto cOk;
  cOj:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cOk:
      I32[Sp - 4] = cNY;
      R1 = _sIa::P32;
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto cNY; else goto cNZ;
  cNZ:
      call (I32[R1])(R1) returns to cNY, args: 4, res: 4, upd: 4;
  cNY:
      _sI7::P32 = P32[Sp + 4];
      _sI8::P32 = P32[Sp + 8];
      _sI9::P32 = P32[Sp + 12];
      _sIb::P32 = R1;
      _cOe::P32 = _sIb::P32 & 3;
      if (_cOe::P32 >= 2) goto cOd; else goto cOc;
  cOd:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cOr; else goto cOq;
  cOr:
      HpAlloc = 48;
      goto cOp;
  cOp:
      R1 = _sIb::P32;
      call stg_gc_unpt_r1(R1) returns to cNY, args: 4, res: 4, upd: 4;
  cOq:
      _sIc::P32 = P32[_sIb::P32 + 2];
      _sId::P32 = P32[_sIb::P32 + 6];
      _sIe::P32 = P32[_sIb::P32 + 10];
      I32[Hp - 44] = sat_sIg_info;
      P32[Hp - 36] = _sI7::P32;
      P32[Hp - 32] = _sI8::P32;
      P32[Hp - 28] = _sI9::P32;
      P32[Hp - 24] = _sIe::P32;
      _cO4::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIc::P32;
      P32[Hp - 12] = _sId::P32;
      _cOn::P32 = Hp - 19;
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _cOn::P32;
      P32[Hp] = _cO4::P32;
      _cOo::P32 = Hp - 7;
      R1 = _cOo::P32;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cOc:
      R1 = GHC.Err.undefined_closure;
      Sp = Sp + 20;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cOi:
      goto cNW;
  cNW:
      if ((Sp + -4) < SpLim) goto cOj; else goto cOk;
  cOj:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cOk:
      I32[Sp - 4] = cNY;
      R1 = P32[Sp + 12];
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto cNY; else goto cNZ;
  cNZ:
      call (I32[R1])(R1) returns to cNY, args: 4, res: 4, upd: 4;
  cNY:
      _sIb::P32 = R1;
      if (_sIb::P32 & 3 >= 2) goto cOd; else goto cOc;
  cOd:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cOr; else goto cOq;
  cOr:
      HpAlloc = 48;
      goto cOp;
  cOp:
      R1 = _sIb::P32;
      call stg_gc_unpt_r1(R1) returns to cNY, args: 4, res: 4, upd: 4;
  cOq:
      _sIc::P32 = P32[_sIb::P32 + 2];
      _sId::P32 = P32[_sIb::P32 + 6];
      _sIe::P32 = P32[_sIb::P32 + 10];
      I32[Hp - 44] = sat_sIg_info;
      P32[Hp - 36] = P32[Sp + 4];
      P32[Hp - 32] = P32[Sp + 8];
      P32[Hp - 28] = P32[Sp + 12];
      P32[Hp - 24] = _sIe::P32;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIc::P32;
      P32[Hp - 12] = _sId::P32;
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = Hp - 19;
      P32[Hp] = Hp - 44;
      R1 = Hp - 7;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cOc:
      R1 = GHC.Err.undefined_closure;
      Sp = Sp + 20;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cNW,
  {GHC.Err.undefined_closure,
   T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure,
   sat_sIg_closure}),
 (cNY, {GHC.Err.undefined_closure, sat_sIg_closure}),
 (cNZ, {GHC.Err.undefined_closure, sat_sIg_closure}),
 (cOc, {GHC.Err.undefined_closure}),
 (cOd, {GHC.Err.undefined_closure, sat_sIg_closure}),
 (cOi,
  {GHC.Err.undefined_closure,
   T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure,
   sat_sIg_closure}),
 (cOj, {T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure}),
 (cOk, {GHC.Err.undefined_closure, sat_sIg_closure}),
 (cOp, {GHC.Err.undefined_closure, sat_sIg_closure}),
 (cOq, {sat_sIg_closure}),
 (cOr, {GHC.Err.undefined_closure, sat_sIg_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_$cextractMin_entry() //  []
        { info_tbl: [(cNY,
                      label: block_cNY_info
                      rep:StackRep [False, False, False, True]),
                     (cOi,
                      label: T2902_B_PairingSum.$fSumPSumab_$cextractMin_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cOi:
          goto cNW;
      cNW:
          if ((Sp + -4) < SpLim) goto cOj; else goto cOk;
      cOj:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cOk:
          I32[Sp - 4] = cNY;
          R1 = P32[Sp + 12];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto cNY; else goto cNZ;
      cNZ:
          call (I32[R1])(R1) returns to cNY, args: 4, res: 4, upd: 4;
      cNY:
          _sIb::P32 = R1;
          if (_sIb::P32 & 3 >= 2) goto cOd; else goto cOc;
      cOd:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cOr; else goto cOq;
      cOr:
          HpAlloc = 48;
          goto cOp;
      cOp:
          R1 = _sIb::P32;
          call stg_gc_unpt_r1(R1) returns to cNY, args: 4, res: 4, upd: 4;
      cOq:
          _sIc::P32 = P32[_sIb::P32 + 2];
          _sId::P32 = P32[_sIb::P32 + 6];
          _sIe::P32 = P32[_sIb::P32 + 10];
          I32[Hp - 44] = sat_sIg_info;
          P32[Hp - 36] = P32[Sp + 4];
          P32[Hp - 32] = P32[Sp + 8];
          P32[Hp - 28] = P32[Sp + 12];
          P32[Hp - 24] = _sIe::P32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = _sIc::P32;
          P32[Hp - 12] = _sId::P32;
          I32[Hp - 8] = (,)_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 44;
          R1 = Hp - 7;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cOc:
          R1 = GHC.Err.undefined_closure;
          Sp = Sp + 20;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_$cextractMin_entry() //  []
        { info_tbl: [(cNW,
                      label: T2902_B_PairingSum.$fSumPSumab_$cextractMin_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                     (cNY,
                      label: block_cNY_info
                      rep:StackRep [False, False, False, True])]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cNW:
          if ((Sp + -4) < SpLim) goto cOj; else goto cOk;
      cOj:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cOk:
          I32[Sp - 4] = cNY;
          R1 = P32[Sp + 12];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto cNY; else goto cNZ;
      cNZ:
          call (I32[R1])(R1) returns to cNY, args: 4, res: 4, upd: 4;
      cNY:
          _sIb::P32 = R1;
          if (_sIb::P32 & 3 >= 2) goto cOd; else goto cOc;
      cOd:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cOr; else goto cOq;
      cOr:
          HpAlloc = 48;
          goto cOp;
      cOp:
          R1 = _sIb::P32;
          call stg_gc_unpt_r1(R1) returns to cNY, args: 4, res: 4, upd: 4;
      cOq:
          _sIc::P32 = P32[_sIb::P32 + 2];
          _sId::P32 = P32[_sIb::P32 + 6];
          _sIe::P32 = P32[_sIb::P32 + 10];
          I32[Hp - 44] = sat_sIg_info;
          P32[Hp - 36] = P32[Sp + 4];
          P32[Hp - 32] = P32[Sp + 8];
          P32[Hp - 28] = P32[Sp + 12];
          P32[Hp - 24] = _sIe::P32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = _sIc::P32;
          P32[Hp - 12] = _sId::P32;
          I32[Hp - 8] = (,)_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 44;
          R1 = Hp - 7;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cOc:
          R1 = GHC.Err.undefined_closure;
          Sp = Sp + 20;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cextractMin_info;
         const 0;
 },
 sat_sIg_entry() //  [R1]
         { info_tbl: [(cO6,
                       label: sat_sIg_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cO6:
           _sIg::P32 = R1;
           if ((Sp + -24) < SpLim) goto cO9; else goto cOa;
       cO9:
           R1 = _sIg::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cOa:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _sIg::P32;
           P32[Sp - 24] = P32[_sIg::P32 + 8];
           P32[Sp - 20] = P32[_sIg::P32 + 12];
           P32[Sp - 16] = P32[_sIg::P32 + 16];
           P32[Sp - 12] = P32[_sIg::P32 + 20];
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$cextractMin_entry() //  []
         { info_tbl: [(cNW,
                       label: T2902_B_PairingSum.$fSumPSumab_$cextractMin_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cNY,
                       label: block_cNY_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cNW:
           if ((Sp + -4) < SpLim) goto cOj; else goto cOk;
       cOj:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cOk:
           I32[Sp - 4] = cNY;
           R1 = P32[Sp + 12];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto cNY; else goto cNZ;
       cNZ:
           call (I32[R1])(R1) returns to cNY, args: 4, res: 4, upd: 4;
       cNY:
           _sIb::P32 = R1;
           if (_sIb::P32 & 3 >= 2) goto cOd; else goto cOc;
       cOd:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cOr; else goto cOq;
       cOr:
           HpAlloc = 48;
           goto cOp;
       cOp:
           R1 = _sIb::P32;
           call stg_gc_unpt_r1(R1) returns to cNY, args: 4, res: 4, upd: 4;
       cOq:
           _sIc::P32 = P32[_sIb::P32 + 2];
           _sId::P32 = P32[_sIb::P32 + 6];
           _sIe::P32 = P32[_sIb::P32 + 10];
           I32[Hp - 44] = sat_sIg_info;
           P32[Hp - 36] = P32[Sp + 4];
           P32[Hp - 32] = P32[Sp + 8];
           P32[Hp - 28] = P32[Sp + 12];
           P32[Hp - 24] = _sIe::P32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _sIc::P32;
           P32[Hp - 12] = _sId::P32;
           I32[Hp - 8] = (,)_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 44;
           R1 = Hp - 7;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cOc:
           R1 = GHC.Err.undefined_closure;
           Sp = Sp + 20;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cextractMin_info;
         const 0;
 },
 sat_sIg_entry() //  [R1]
         { info_tbl: [(cO6,
                       label: sat_sIg_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cO6:
           _sIg::P32 = R1;
           if ((Sp + -24) < SpLim) goto cO9; else goto cOa;
       cO9:
           R1 = _sIg::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cOa:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _sIg::P32;
           P32[Sp - 24] = P32[_sIg::P32 + 8];
           P32[Sp - 20] = P32[_sIg::P32 + 12];
           P32[Sp - 16] = P32[_sIg::P32 + 16];
           P32[Sp - 12] = P32[_sIg::P32 + 20];
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$cextractMin_entry() //  []
         { info_tbl: [(cNW,
                       label: T2902_B_PairingSum.$fSumPSumab_$cextractMin_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cNY,
                       label: block_cNY_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cNW:
           if ((Sp + -4) < SpLim) goto cOj; else goto cOk;
       cOj:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cOk:
           I32[Sp - 4] = cNY;
           R1 = P32[Sp + 12];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto cNY; else goto cNZ;
       cNZ:
           call (I32[R1])(R1) returns to cNY, args: 4, res: 4, upd: 4;
       cNY:
           _sIb::P32 = R1;
           if (_sIb::P32 & 3 >= 2) goto cOd; else goto cOc;
       cOd:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cOr; else goto cOq;
       cOr:
           HpAlloc = 48;
           goto cOp;
       cOp:
           R1 = _sIb::P32;
           call stg_gc_unpt_r1(R1) returns to cNY, args: 4, res: 4, upd: 4;
       cOq:
           _sIc::P32 = P32[_sIb::P32 + 2];
           _sId::P32 = P32[_sIb::P32 + 6];
           _sIe::P32 = P32[_sIb::P32 + 10];
           I32[Hp - 44] = sat_sIg_info;
           P32[Hp - 36] = P32[Sp + 4];
           P32[Hp - 32] = P32[Sp + 8];
           P32[Hp - 28] = P32[Sp + 12];
           P32[Hp - 24] = _sIe::P32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _sIc::P32;
           P32[Hp - 12] = _sId::P32;
           I32[Hp - 8] = (,)_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 44;
           R1 = Hp - 7;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cOc:
           R1 = GHC.Err.undefined_closure;
           Sp = Sp + 20;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$ctoList_closure:
         const T2902_B_PairingSum.$fSumPSumab_$ctoList_info;
         const 0;
 },
 sat_sIr_entry() //  [R1]
         { info_tbl: [(cPb,
                       label: sat_sIr_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cPb:
           _sIr::P32 = R1;
           goto cP7;
       cP7:
           if (Sp - <highSp> < SpLim) goto cPc; else goto cPd;
       cPc:
           R1 = _sIr::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cPd:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _sIr::P32;
           _sIh::P32 = P32[_sIr::P32 + 8];
           _sIi::P32 = P32[_sIr::P32 + 12];
           _sIj::P32 = P32[_sIr::P32 + 16];
           _sIo::P32 = P32[_sIr::P32 + 20];
           I32[(young<cP9> + 4)] = cP9;
           P32[(young<cP9> + 20)] = _sIh::P32;
           P32[(young<cP9> + 16)] = _sIi::P32;
           P32[(young<cP9> + 12)] = _sIj::P32;
           P32[(young<cP9> + 8)] = _sIo::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP9, args: 20, res: 4, upd: 12;
       cP9:
           _sIq::P32 = R1;
           P32[(old + 28)] = _sIh::P32;
           P32[(old + 24)] = _sIi::P32;
           P32[(old + 20)] = _sIj::P32;
           P32[(old + 16)] = _sIq::P32;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$ctoList_entry() //  []
         { info_tbl: [(cPo,
                       label: T2902_B_PairingSum.$fSumPSumab_$ctoList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cPo:
           _sIh::P32 = P32[(old + 20)];
           _sIi::P32 = P32[(old + 16)];
           _sIj::P32 = P32[(old + 12)];
           _sIk::P32 = P32[(old + 8)];
           goto cOX;
       cOX:
           if (Sp - <highSp> < SpLim) goto cPp; else goto cPq;
       cPp:
           R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
           P32[(old + 20)] = _sIh::P32;
           P32[(old + 16)] = _sIi::P32;
           P32[(old + 12)] = _sIj::P32;
           P32[(old + 8)] = _sIk::P32;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cPq:
           I32[(young<cOZ> + 4)] = cOZ;
           R1 = _sIk::P32;
           if (R1 & 3 != 0) goto cOZ; else goto cP0;
       cP0:
           call (I32[R1])(R1) returns to cOZ, args: 4, res: 4, upd: 4;
       cOZ:
           _sIl::P32 = R1;
           _cPk::P32 = _sIl::P32 & 3;
           if (_cPk::P32 >= 2) goto cPm; else goto cPn;
       cPm:
           goto cPj;
       cPj:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cPx; else goto cPw;
       cPx:
           HpAlloc = 48;
           goto cPv;
       cPv:
           R1 = _sIl::P32;
           call stg_gc_unpt_r1(R1) returns to cOZ, args: 4, res: 4, upd: 4;
       cPw:
           _sIm::P32 = P32[_sIl::P32 + 2];
           _sIn::P32 = P32[_sIl::P32 + 6];
           _sIo::P32 = P32[_sIl::P32 + 10];
           I32[Hp - 44] = sat_sIr_info;
           P32[Hp - 36] = _sIh::P32;
           P32[Hp - 32] = _sIi::P32;
           P32[Hp - 28] = _sIj::P32;
           P32[Hp - 24] = _sIo::P32;
           _cP5::P32 = Hp - 44;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _sIm::P32;
           P32[Hp - 12] = _sIn::P32;
           _cPt::P32 = Hp - 19;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = _cPt::P32;
           P32[Hp] = _cP5::P32;
           _cPu::P32 = Hp - 6;
           R1 = _cPu::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
       cPn:
           goto cPi;
       cPi:
           R1 = []_closure+1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cPb:
      _sIr::P32 = R1;
      goto cP7;
  cP7:
      if (Sp - <highSp> < SpLim) goto cPc; else goto cPd;
  cPc:
      R1 = _sIr::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cPd:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sIr::P32;
      _sIh::P32 = P32[_sIr::P32 + 8];
      _sIi::P32 = P32[_sIr::P32 + 12];
      _sIj::P32 = P32[_sIr::P32 + 16];
      _sIo::P32 = P32[_sIr::P32 + 20];
      I32[(young<cP9> + 4)] = cP9;
      P32[(young<cP9> + 20)] = _sIh::P32;
      P32[(young<cP9> + 16)] = _sIi::P32;
      P32[(young<cP9> + 12)] = _sIj::P32;
      P32[(young<cP9> + 8)] = _sIo::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP9, args: 20, res: 4, upd: 12;
  cP9:
      _sIq::P32 = R1;
      P32[(old + 28)] = _sIh::P32;
      P32[(old + 24)] = _sIi::P32;
      P32[(old + 20)] = _sIj::P32;
      P32[(old + 16)] = _sIq::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  cPb:
      _sIr::P32 = R1;
      goto cP7;
  cP7:
      if (Sp - <highSp> < SpLim) goto cPc; else goto cPd;
  cPc:
      R1 = _sIr::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cPd:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sIr::P32;
      _sIh::P32 = P32[_sIr::P32 + 8];
      _sIi::P32 = P32[_sIr::P32 + 12];
      _sIj::P32 = P32[_sIr::P32 + 16];
      _sIo::P32 = P32[_sIr::P32 + 20];
      I32[(young<cP9> + 4)] = cP9;
      P32[(young<cP9> + 20)] = _sIh::P32;
      P32[(young<cP9> + 16)] = _sIi::P32;
      P32[(young<cP9> + 12)] = _sIj::P32;
      P32[(young<cP9> + 8)] = _sIo::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP9, args: 20, res: 4, upd: 12;
  cP9:
      _sIq::P32 = R1;
      P32[(old + 28)] = _sIh::P32;
      P32[(old + 24)] = _sIi::P32;
      P32[(old + 20)] = _sIj::P32;
      P32[(old + 16)] = _sIq::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  cPb:
      _sIr::P32 = R1;
      goto cP7;
  cP7:
      if (Sp - <highSp> < SpLim) goto cPc; else goto cPd;
  cPc:
      R1 = _sIr::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cPd:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sIr::P32;
      _sIh::P32 = P32[_sIr::P32 + 8];
      _sIi::P32 = P32[_sIr::P32 + 12];
      _sIj::P32 = P32[_sIr::P32 + 16];
      _sIo::P32 = P32[_sIr::P32 + 20];
      I32[(young<cP9> + 4)] = cP9;
      P32[(young<cP9> + 20)] = _sIh::P32;
      P32[(young<cP9> + 16)] = _sIi::P32;
      P32[(young<cP9> + 12)] = _sIj::P32;
      P32[(young<cP9> + 8)] = _sIo::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP9, args: 20, res: 4, upd: 12;
  cP9:
      _sIq::P32 = R1;
      P32[(old + 28)] = _sIh::P32;
      P32[(old + 24)] = _sIi::P32;
      P32[(old + 20)] = _sIj::P32;
      P32[(old + 16)] = _sIq::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  cPb:
      _sIr::P32 = R1;
      goto cP7;
  cP7:
      if (Sp - 40 < SpLim) goto cPc; else goto cPd;
  cPc:
      R1 = _sIr::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cPd:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _sIr::P32;
      _sIh::P32 = P32[_sIr::P32 + 8];
      _sIi::P32 = P32[_sIr::P32 + 12];
      _sIj::P32 = P32[_sIr::P32 + 16];
      _sIo::P32 = P32[_sIr::P32 + 20];
      I32[Sp - 24] = cP9;
      P32[Sp - 40] = _sIh::P32;
      P32[Sp - 36] = _sIi::P32;
      P32[Sp - 32] = _sIj::P32;
      P32[Sp - 28] = _sIo::P32;
      P32[Sp - 20] = _sIh::P32;
      P32[Sp - 16] = _sIi::P32;
      P32[Sp - 12] = _sIj::P32;
      Sp = Sp - 40;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP9, args: 20, res: 4, upd: 12;
  cP9:
      _sIh::P32 = P32[Sp + 4];
      _sIi::P32 = P32[Sp + 8];
      _sIj::P32 = P32[Sp + 12];
      _sIq::P32 = R1;
      P32[Sp] = _sIh::P32;
      P32[Sp + 4] = _sIi::P32;
      P32[Sp + 8] = _sIj::P32;
      P32[Sp + 12] = _sIq::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  cPb:
      goto cP7;
  cP7:
      _sIr::P32 = R1;
      if ((Sp + -40) < SpLim) goto cPc; else goto cPd;
  cPc:
      R1 = _sIr::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cPd:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _sIr::P32;
      I32[Sp - 24] = cP9;
      _sIh::P32 = P32[_sIr::P32 + 8];
      P32[Sp - 40] = _sIh::P32;
      _sIi::P32 = P32[_sIr::P32 + 12];
      P32[Sp - 36] = _sIi::P32;
      _sIj::P32 = P32[_sIr::P32 + 16];
      P32[Sp - 32] = _sIj::P32;
      P32[Sp - 28] = P32[_sIr::P32 + 20];
      P32[Sp - 20] = _sIh::P32;
      P32[Sp - 16] = _sIi::P32;
      P32[Sp - 12] = _sIj::P32;
      Sp = Sp - 40;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP9, args: 20, res: 4, upd: 12;
  cP9:
      P32[Sp] = P32[Sp + 4];
      P32[Sp + 4] = P32[Sp + 8];
      P32[Sp + 8] = P32[Sp + 12];
      P32[Sp + 12] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(cP7,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cP9, {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure}),
 (cPb,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cPc, {}),
 (cPd,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunions_closure})]



==================== after setInfoTableStackMap ====================
sat_sIr_entry() //  [R1]
        { info_tbl: [(cP9,
                      label: block_cP9_info
                      rep:StackRep [False, False, False]),
                     (cPb,
                      label: sat_sIr_info
                      rep:HeapRep 4 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cPb:
          goto cP7;
      cP7:
          _sIr::P32 = R1;
          if ((Sp + -40) < SpLim) goto cPc; else goto cPd;
      cPc:
          R1 = _sIr::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cPd:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _sIr::P32;
          I32[Sp - 24] = cP9;
          _sIh::P32 = P32[_sIr::P32 + 8];
          P32[Sp - 40] = _sIh::P32;
          _sIi::P32 = P32[_sIr::P32 + 12];
          P32[Sp - 36] = _sIi::P32;
          _sIj::P32 = P32[_sIr::P32 + 16];
          P32[Sp - 32] = _sIj::P32;
          P32[Sp - 28] = P32[_sIr::P32 + 20];
          P32[Sp - 20] = _sIh::P32;
          P32[Sp - 16] = _sIi::P32;
          P32[Sp - 12] = _sIj::P32;
          Sp = Sp - 40;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP9, args: 20, res: 4, upd: 12;
      cP9:
          P32[Sp] = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp + 8];
          P32[Sp + 8] = P32[Sp + 12];
          P32[Sp + 12] = R1;
          call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_sIr_entry() //  [R1]
        { info_tbl: [(cP7,
                      label: sat_sIr_info
                      rep:HeapRep 4 ptrs { Thunk }),
                     (cP9,
                      label: block_cP9_info
                      rep:StackRep [False, False, False])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cP7:
          _sIr::P32 = R1;
          if ((Sp + -40) < SpLim) goto cPc; else goto cPd;
      cPc:
          R1 = _sIr::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cPd:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _sIr::P32;
          I32[Sp - 24] = cP9;
          _sIh::P32 = P32[_sIr::P32 + 8];
          P32[Sp - 40] = _sIh::P32;
          _sIi::P32 = P32[_sIr::P32 + 12];
          P32[Sp - 36] = _sIi::P32;
          _sIj::P32 = P32[_sIr::P32 + 16];
          P32[Sp - 32] = _sIj::P32;
          P32[Sp - 28] = P32[_sIr::P32 + 20];
          P32[Sp - 20] = _sIh::P32;
          P32[Sp - 16] = _sIi::P32;
          P32[Sp - 12] = _sIj::P32;
          Sp = Sp - 40;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP9, args: 20, res: 4, upd: 12;
      cP9:
          P32[Sp] = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp + 8];
          P32[Sp + 8] = P32[Sp + 12];
          P32[Sp + 12] = R1;
          call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cPo:
      _sIh::P32 = P32[(old + 20)];
      _sIi::P32 = P32[(old + 16)];
      _sIj::P32 = P32[(old + 12)];
      _sIk::P32 = P32[(old + 8)];
      goto cOX;
  cOX:
      if (Sp - <highSp> < SpLim) goto cPp; else goto cPq;
  cPp:
      R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
      P32[(old + 20)] = _sIh::P32;
      P32[(old + 16)] = _sIi::P32;
      P32[(old + 12)] = _sIj::P32;
      P32[(old + 8)] = _sIk::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cPq:
      I32[(young<cOZ> + 4)] = cOZ;
      R1 = _sIk::P32;
      if (R1 & 3 != 0) goto cOZ; else goto cP0;
  cP0:
      call (I32[R1])(R1) returns to cOZ, args: 4, res: 4, upd: 4;
  cOZ:
      _sIl::P32 = R1;
      _cPk::P32 = _sIl::P32 & 3;
      if (_cPk::P32 >= 2) goto cPj; else goto cPi;
  cPj:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cPx; else goto cPw;
  cPx:
      HpAlloc = 48;
      goto cPv;
  cPv:
      R1 = _sIl::P32;
      call stg_gc_unpt_r1(R1) returns to cOZ, args: 4, res: 4, upd: 4;
  cPw:
      _sIm::P32 = P32[_sIl::P32 + 2];
      _sIn::P32 = P32[_sIl::P32 + 6];
      _sIo::P32 = P32[_sIl::P32 + 10];
      I32[Hp - 44] = sat_sIr_info;
      P32[Hp - 36] = _sIh::P32;
      P32[Hp - 32] = _sIi::P32;
      P32[Hp - 28] = _sIj::P32;
      P32[Hp - 24] = _sIo::P32;
      _cP5::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIm::P32;
      P32[Hp - 12] = _sIn::P32;
      _cPt::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _cPt::P32;
      P32[Hp] = _cP5::P32;
      _cPu::P32 = Hp - 6;
      R1 = _cPu::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cPi:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cPo:
      _sIh::P32 = P32[(old + 20)];
      _sIi::P32 = P32[(old + 16)];
      _sIj::P32 = P32[(old + 12)];
      _sIk::P32 = P32[(old + 8)];
      goto cOX;
  cOX:
      if (Sp - <highSp> < SpLim) goto cPp; else goto cPq;
  cPp:
      R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
      P32[(old + 20)] = _sIh::P32;
      P32[(old + 16)] = _sIi::P32;
      P32[(old + 12)] = _sIj::P32;
      P32[(old + 8)] = _sIk::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cPq:
      I32[(young<cOZ> + 4)] = cOZ;
      R1 = _sIk::P32;
      if (R1 & 3 != 0) goto cOZ; else goto cP0;
  cP0:
      call (I32[R1])(R1) returns to cOZ, args: 4, res: 4, upd: 4;
  cOZ:
      _sIl::P32 = R1;
      _cPk::P32 = _sIl::P32 & 3;
      if (_cPk::P32 >= 2) goto cPj; else goto cPi;
  cPj:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cPx; else goto cPw;
  cPx:
      HpAlloc = 48;
      goto cPv;
  cPv:
      R1 = _sIl::P32;
      call stg_gc_unpt_r1(R1) returns to cOZ, args: 4, res: 4, upd: 4;
  cPw:
      _sIm::P32 = P32[_sIl::P32 + 2];
      _sIn::P32 = P32[_sIl::P32 + 6];
      _sIo::P32 = P32[_sIl::P32 + 10];
      I32[Hp - 44] = sat_sIr_info;
      P32[Hp - 36] = _sIh::P32;
      P32[Hp - 32] = _sIi::P32;
      P32[Hp - 28] = _sIj::P32;
      P32[Hp - 24] = _sIo::P32;
      _cP5::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIm::P32;
      P32[Hp - 12] = _sIn::P32;
      _cPt::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _cPt::P32;
      P32[Hp] = _cP5::P32;
      _cPu::P32 = Hp - 6;
      R1 = _cPu::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cPi:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cPo:
      _sIh::P32 = P32[(old + 20)];
      _sIi::P32 = P32[(old + 16)];
      _sIj::P32 = P32[(old + 12)];
      _sIk::P32 = P32[(old + 8)];
      goto cOX;
  cOX:
      if (Sp - <highSp> < SpLim) goto cPp; else goto cPq;
  cPp:
      R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
      P32[(old + 20)] = _sIh::P32;
      P32[(old + 16)] = _sIi::P32;
      P32[(old + 12)] = _sIj::P32;
      P32[(old + 8)] = _sIk::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cPq:
      I32[(young<cOZ> + 4)] = cOZ;
      R1 = _sIk::P32;
      if (R1 & 3 != 0) goto cOZ; else goto cP0;
  cP0:
      call (I32[R1])(R1) returns to cOZ, args: 4, res: 4, upd: 4;
  cOZ:
      _sIl::P32 = R1;
      _cPk::P32 = _sIl::P32 & 3;
      if (_cPk::P32 >= 2) goto cPj; else goto cPi;
  cPj:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cPx; else goto cPw;
  cPx:
      HpAlloc = 48;
      goto cPv;
  cPv:
      R1 = _sIl::P32;
      call stg_gc_unpt_r1(R1) returns to cOZ, args: 4, res: 4, upd: 4;
  cPw:
      _sIm::P32 = P32[_sIl::P32 + 2];
      _sIn::P32 = P32[_sIl::P32 + 6];
      _sIo::P32 = P32[_sIl::P32 + 10];
      I32[Hp - 44] = sat_sIr_info;
      P32[Hp - 36] = _sIh::P32;
      P32[Hp - 32] = _sIi::P32;
      P32[Hp - 28] = _sIj::P32;
      P32[Hp - 24] = _sIo::P32;
      _cP5::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIm::P32;
      P32[Hp - 12] = _sIn::P32;
      _cPt::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _cPt::P32;
      P32[Hp] = _cP5::P32;
      _cPu::P32 = Hp - 6;
      R1 = _cPu::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cPi:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cPo:
      _sIh::P32 = P32[Sp];
      _sIi::P32 = P32[Sp + 4];
      _sIj::P32 = P32[Sp + 8];
      _sIk::P32 = P32[Sp + 12];
      goto cOX;
  cOX:
      if (Sp - 4 < SpLim) goto cPp; else goto cPq;
  cPp:
      R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cPq:
      I32[Sp - 4] = cOZ;
      R1 = _sIk::P32;
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto cOZ; else goto cP0;
  cP0:
      call (I32[R1])(R1) returns to cOZ, args: 4, res: 4, upd: 4;
  cOZ:
      _sIh::P32 = P32[Sp + 4];
      _sIi::P32 = P32[Sp + 8];
      _sIj::P32 = P32[Sp + 12];
      _sIl::P32 = R1;
      _cPk::P32 = _sIl::P32 & 3;
      if (_cPk::P32 >= 2) goto cPj; else goto cPi;
  cPj:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cPx; else goto cPw;
  cPx:
      HpAlloc = 48;
      goto cPv;
  cPv:
      R1 = _sIl::P32;
      call stg_gc_unpt_r1(R1) returns to cOZ, args: 4, res: 4, upd: 4;
  cPw:
      _sIm::P32 = P32[_sIl::P32 + 2];
      _sIn::P32 = P32[_sIl::P32 + 6];
      _sIo::P32 = P32[_sIl::P32 + 10];
      I32[Hp - 44] = sat_sIr_info;
      P32[Hp - 36] = _sIh::P32;
      P32[Hp - 32] = _sIi::P32;
      P32[Hp - 28] = _sIj::P32;
      P32[Hp - 24] = _sIo::P32;
      _cP5::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIm::P32;
      P32[Hp - 12] = _sIn::P32;
      _cPt::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _cPt::P32;
      P32[Hp] = _cP5::P32;
      _cPu::P32 = Hp - 6;
      R1 = _cPu::P32;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cPi:
      R1 = []_closure+1;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cPo:
      goto cOX;
  cOX:
      if ((Sp + -4) < SpLim) goto cPp; else goto cPq;
  cPp:
      R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cPq:
      I32[Sp - 4] = cOZ;
      R1 = P32[Sp + 12];
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto cOZ; else goto cP0;
  cP0:
      call (I32[R1])(R1) returns to cOZ, args: 4, res: 4, upd: 4;
  cOZ:
      _sIl::P32 = R1;
      if (_sIl::P32 & 3 >= 2) goto cPj; else goto cPi;
  cPj:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cPx; else goto cPw;
  cPx:
      HpAlloc = 48;
      goto cPv;
  cPv:
      R1 = _sIl::P32;
      call stg_gc_unpt_r1(R1) returns to cOZ, args: 4, res: 4, upd: 4;
  cPw:
      _sIm::P32 = P32[_sIl::P32 + 2];
      _sIn::P32 = P32[_sIl::P32 + 6];
      _sIo::P32 = P32[_sIl::P32 + 10];
      I32[Hp - 44] = sat_sIr_info;
      P32[Hp - 36] = P32[Sp + 4];
      P32[Hp - 32] = P32[Sp + 8];
      P32[Hp - 28] = P32[Sp + 12];
      P32[Hp - 24] = _sIo::P32;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIm::P32;
      P32[Hp - 12] = _sIn::P32;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = Hp - 19;
      P32[Hp] = Hp - 44;
      R1 = Hp - 6;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cPi:
      R1 = []_closure+1;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cOX,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   sat_sIr_closure}),
 (cOZ, {sat_sIr_closure}), (cP0, {sat_sIr_closure}), (cPi, {}),
 (cPj, {sat_sIr_closure}),
 (cPo,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   sat_sIr_closure}),
 (cPp, {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure}),
 (cPq, {sat_sIr_closure}), (cPv, {sat_sIr_closure}),
 (cPw, {sat_sIr_closure}), (cPx, {sat_sIr_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_$ctoList_entry() //  []
        { info_tbl: [(cOZ,
                      label: block_cOZ_info
                      rep:StackRep [False, False, False, True]),
                     (cPo,
                      label: T2902_B_PairingSum.$fSumPSumab_$ctoList_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cPo:
          goto cOX;
      cOX:
          if ((Sp + -4) < SpLim) goto cPp; else goto cPq;
      cPp:
          R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cPq:
          I32[Sp - 4] = cOZ;
          R1 = P32[Sp + 12];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto cOZ; else goto cP0;
      cP0:
          call (I32[R1])(R1) returns to cOZ, args: 4, res: 4, upd: 4;
      cOZ:
          _sIl::P32 = R1;
          if (_sIl::P32 & 3 >= 2) goto cPj; else goto cPi;
      cPj:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cPx; else goto cPw;
      cPx:
          HpAlloc = 48;
          goto cPv;
      cPv:
          R1 = _sIl::P32;
          call stg_gc_unpt_r1(R1) returns to cOZ, args: 4, res: 4, upd: 4;
      cPw:
          _sIm::P32 = P32[_sIl::P32 + 2];
          _sIn::P32 = P32[_sIl::P32 + 6];
          _sIo::P32 = P32[_sIl::P32 + 10];
          I32[Hp - 44] = sat_sIr_info;
          P32[Hp - 36] = P32[Sp + 4];
          P32[Hp - 32] = P32[Sp + 8];
          P32[Hp - 28] = P32[Sp + 12];
          P32[Hp - 24] = _sIo::P32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = _sIm::P32;
          P32[Hp - 12] = _sIn::P32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 44;
          R1 = Hp - 6;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cPi:
          R1 = []_closure+1;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_$ctoList_entry() //  []
        { info_tbl: [(cOX,
                      label: T2902_B_PairingSum.$fSumPSumab_$ctoList_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                     (cOZ,
                      label: block_cOZ_info
                      rep:StackRep [False, False, False, True])]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cOX:
          if ((Sp + -4) < SpLim) goto cPp; else goto cPq;
      cPp:
          R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cPq:
          I32[Sp - 4] = cOZ;
          R1 = P32[Sp + 12];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto cOZ; else goto cP0;
      cP0:
          call (I32[R1])(R1) returns to cOZ, args: 4, res: 4, upd: 4;
      cOZ:
          _sIl::P32 = R1;
          if (_sIl::P32 & 3 >= 2) goto cPj; else goto cPi;
      cPj:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cPx; else goto cPw;
      cPx:
          HpAlloc = 48;
          goto cPv;
      cPv:
          R1 = _sIl::P32;
          call stg_gc_unpt_r1(R1) returns to cOZ, args: 4, res: 4, upd: 4;
      cPw:
          _sIm::P32 = P32[_sIl::P32 + 2];
          _sIn::P32 = P32[_sIl::P32 + 6];
          _sIo::P32 = P32[_sIl::P32 + 10];
          I32[Hp - 44] = sat_sIr_info;
          P32[Hp - 36] = P32[Sp + 4];
          P32[Hp - 32] = P32[Sp + 8];
          P32[Hp - 28] = P32[Sp + 12];
          P32[Hp - 24] = _sIo::P32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = _sIm::P32;
          P32[Hp - 12] = _sIn::P32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 44;
          R1 = Hp - 6;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cPi:
          R1 = []_closure+1;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$ctoList_closure:
         const T2902_B_PairingSum.$fSumPSumab_$ctoList_info;
         const 0;
 },
 sat_sIr_entry() //  [R1]
         { info_tbl: [(cP7,
                       label: sat_sIr_info
                       rep:HeapRep 4 ptrs { Thunk }),
                      (cP9,
                       label: block_cP9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cP7:
           _sIr::P32 = R1;
           if ((Sp + -40) < SpLim) goto cPc; else goto cPd;
       cPc:
           R1 = _sIr::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cPd:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _sIr::P32;
           I32[Sp - 24] = cP9;
           _sIh::P32 = P32[_sIr::P32 + 8];
           P32[Sp - 40] = _sIh::P32;
           _sIi::P32 = P32[_sIr::P32 + 12];
           P32[Sp - 36] = _sIi::P32;
           _sIj::P32 = P32[_sIr::P32 + 16];
           P32[Sp - 32] = _sIj::P32;
           P32[Sp - 28] = P32[_sIr::P32 + 20];
           P32[Sp - 20] = _sIh::P32;
           P32[Sp - 16] = _sIi::P32;
           P32[Sp - 12] = _sIj::P32;
           Sp = Sp - 40;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP9, args: 20, res: 4, upd: 12;
       cP9:
           P32[Sp] = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp + 8];
           P32[Sp + 8] = P32[Sp + 12];
           P32[Sp + 12] = R1;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$ctoList_entry() //  []
         { info_tbl: [(cOX,
                       label: T2902_B_PairingSum.$fSumPSumab_$ctoList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cOZ,
                       label: block_cOZ_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cOX:
           if ((Sp + -4) < SpLim) goto cPp; else goto cPq;
       cPp:
           R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cPq:
           I32[Sp - 4] = cOZ;
           R1 = P32[Sp + 12];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto cOZ; else goto cP0;
       cP0:
           call (I32[R1])(R1) returns to cOZ, args: 4, res: 4, upd: 4;
       cOZ:
           _sIl::P32 = R1;
           if (_sIl::P32 & 3 >= 2) goto cPj; else goto cPi;
       cPj:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cPx; else goto cPw;
       cPx:
           HpAlloc = 48;
           goto cPv;
       cPv:
           R1 = _sIl::P32;
           call stg_gc_unpt_r1(R1) returns to cOZ, args: 4, res: 4, upd: 4;
       cPw:
           _sIm::P32 = P32[_sIl::P32 + 2];
           _sIn::P32 = P32[_sIl::P32 + 6];
           _sIo::P32 = P32[_sIl::P32 + 10];
           I32[Hp - 44] = sat_sIr_info;
           P32[Hp - 36] = P32[Sp + 4];
           P32[Hp - 32] = P32[Sp + 8];
           P32[Hp - 28] = P32[Sp + 12];
           P32[Hp - 24] = _sIo::P32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _sIm::P32;
           P32[Hp - 12] = _sIn::P32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 44;
           R1 = Hp - 6;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cPi:
           R1 = []_closure+1;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$ctoList_closure:
         const T2902_B_PairingSum.$fSumPSumab_$ctoList_info;
         const 0;
 },
 sat_sIr_entry() //  [R1]
         { info_tbl: [(cP7,
                       label: sat_sIr_info
                       rep:HeapRep 4 ptrs { Thunk }),
                      (cP9,
                       label: block_cP9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cP7:
           _sIr::P32 = R1;
           if ((Sp + -40) < SpLim) goto cPc; else goto cPd;
       cPc:
           R1 = _sIr::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cPd:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _sIr::P32;
           I32[Sp - 24] = cP9;
           _sIh::P32 = P32[_sIr::P32 + 8];
           P32[Sp - 40] = _sIh::P32;
           _sIi::P32 = P32[_sIr::P32 + 12];
           P32[Sp - 36] = _sIi::P32;
           _sIj::P32 = P32[_sIr::P32 + 16];
           P32[Sp - 32] = _sIj::P32;
           P32[Sp - 28] = P32[_sIr::P32 + 20];
           P32[Sp - 20] = _sIh::P32;
           P32[Sp - 16] = _sIi::P32;
           P32[Sp - 12] = _sIj::P32;
           Sp = Sp - 40;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP9, args: 20, res: 4, upd: 12;
       cP9:
           P32[Sp] = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp + 8];
           P32[Sp + 8] = P32[Sp + 12];
           P32[Sp + 12] = R1;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$ctoList_entry() //  []
         { info_tbl: [(cOX,
                       label: T2902_B_PairingSum.$fSumPSumab_$ctoList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cOZ,
                       label: block_cOZ_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cOX:
           if ((Sp + -4) < SpLim) goto cPp; else goto cPq;
       cPp:
           R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cPq:
           I32[Sp - 4] = cOZ;
           R1 = P32[Sp + 12];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto cOZ; else goto cP0;
       cP0:
           call (I32[R1])(R1) returns to cOZ, args: 4, res: 4, upd: 4;
       cOZ:
           _sIl::P32 = R1;
           if (_sIl::P32 & 3 >= 2) goto cPj; else goto cPi;
       cPj:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cPx; else goto cPw;
       cPx:
           HpAlloc = 48;
           goto cPv;
       cPv:
           R1 = _sIl::P32;
           call stg_gc_unpt_r1(R1) returns to cOZ, args: 4, res: 4, upd: 4;
       cPw:
           _sIm::P32 = P32[_sIl::P32 + 2];
           _sIn::P32 = P32[_sIl::P32 + 6];
           _sIo::P32 = P32[_sIl::P32 + 10];
           I32[Hp - 44] = sat_sIr_info;
           P32[Hp - 36] = P32[Sp + 4];
           P32[Hp - 32] = P32[Sp + 8];
           P32[Hp - 28] = P32[Sp + 12];
           P32[Hp - 24] = _sIo::P32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _sIm::P32;
           P32[Hp - 12] = _sIn::P32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 44;
           R1 = Hp - 6;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cPi:
           R1 = []_closure+1;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cfromList_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cfromList_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cfromList_entry() //  []
         { info_tbl: [(cQh,
                       label: T2902_B_PairingSum.$fSumPSumab_$cfromList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cQh:
           _sIs::P32 = P32[(old + 20)];
           _sIt::P32 = P32[(old + 16)];
           _sIu::P32 = P32[(old + 12)];
           _sIv::P32 = P32[(old + 8)];
           goto cQ5;
       cQ5:
           if (Sp - <highSp> < SpLim) goto cQi; else goto cQj;
       cQi:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
           P32[(old + 20)] = _sIs::P32;
           P32[(old + 16)] = _sIt::P32;
           P32[(old + 12)] = _sIu::P32;
           P32[(old + 8)] = _sIv::P32;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cQj:
           I32[(young<cQ7> + 4)] = cQ7;
           R1 = _sIv::P32;
           if (R1 & 3 != 0) goto cQ7; else goto cQ8;
       cQ8:
           call (I32[R1])(R1) returns to cQ7, args: 4, res: 4, upd: 4;
       cQ7:
           _sIw::P32 = R1;
           _cQd::P32 = _sIw::P32 & 3;
           if (_cQd::P32 >= 2) goto cQf; else goto cQg;
       cQf:
           goto cQc;
       cQc:
           _sIx::P32 = P32[_sIw::P32 + 2];
           _sIy::P32 = P32[_sIw::P32 + 6];
           I32[(young<cQp> + 4)] = cQp;
           R1 = _sIx::P32;
           if (R1 & 3 != 0) goto cQp; else goto cQq;
       cQq:
           call (I32[R1])(R1) returns to cQp, args: 4, res: 4, upd: 4;
       cQp:
           _sIz::P32 = R1;
           _sIA::P32 = P32[_sIz::P32 + 3];
           _sIB::P32 = P32[_sIz::P32 + 7];
           I32[(young<cQu> + 4)] = cQu;
           P32[(young<cQu> + 20)] = _sIs::P32;
           P32[(young<cQu> + 16)] = _sIt::P32;
           P32[(young<cQu> + 12)] = _sIu::P32;
           P32[(young<cQu> + 8)] = _sIy::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQu, args: 20, res: 4, upd: 4;
       cQu:
           _sIC::P32 = R1;
           P32[(old + 28)] = _sIs::P32;
           P32[(old + 24)] = _sIt::P32;
           P32[(old + 20)] = _sIu::P32;
           P32[(old + 16)] = _sIA::P32;
           P32[(old + 12)] = _sIB::P32;
           P32[(old + 8)] = _sIC::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
       cQg:
           goto cQb;
       cQb:
           R1 = T2902_B_PairingSum.Empty_closure+1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cQh:
      _sIs::P32 = P32[(old + 20)];
      _sIt::P32 = P32[(old + 16)];
      _sIu::P32 = P32[(old + 12)];
      _sIv::P32 = P32[(old + 8)];
      goto cQ5;
  cQ5:
      if (Sp - <highSp> < SpLim) goto cQi; else goto cQj;
  cQi:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
      P32[(old + 20)] = _sIs::P32;
      P32[(old + 16)] = _sIt::P32;
      P32[(old + 12)] = _sIu::P32;
      P32[(old + 8)] = _sIv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cQj:
      I32[(young<cQ7> + 4)] = cQ7;
      R1 = _sIv::P32;
      if (R1 & 3 != 0) goto cQ7; else goto cQ8;
  cQ8:
      call (I32[R1])(R1) returns to cQ7, args: 4, res: 4, upd: 4;
  cQ7:
      _sIw::P32 = R1;
      _cQd::P32 = _sIw::P32 & 3;
      if (_cQd::P32 >= 2) goto cQc; else goto cQb;
  cQc:
      _sIx::P32 = P32[_sIw::P32 + 2];
      _sIy::P32 = P32[_sIw::P32 + 6];
      I32[(young<cQp> + 4)] = cQp;
      R1 = _sIx::P32;
      if (R1 & 3 != 0) goto cQp; else goto cQq;
  cQq:
      call (I32[R1])(R1) returns to cQp, args: 4, res: 4, upd: 4;
  cQp:
      _sIz::P32 = R1;
      _sIA::P32 = P32[_sIz::P32 + 3];
      _sIB::P32 = P32[_sIz::P32 + 7];
      I32[(young<cQu> + 4)] = cQu;
      P32[(young<cQu> + 20)] = _sIs::P32;
      P32[(young<cQu> + 16)] = _sIt::P32;
      P32[(young<cQu> + 12)] = _sIu::P32;
      P32[(young<cQu> + 8)] = _sIy::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQu, args: 20, res: 4, upd: 4;
  cQu:
      _sIC::P32 = R1;
      P32[(old + 28)] = _sIs::P32;
      P32[(old + 24)] = _sIt::P32;
      P32[(old + 20)] = _sIu::P32;
      P32[(old + 16)] = _sIA::P32;
      P32[(old + 12)] = _sIB::P32;
      P32[(old + 8)] = _sIC::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cQb:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cQh:
      _sIs::P32 = P32[(old + 20)];
      _sIt::P32 = P32[(old + 16)];
      _sIu::P32 = P32[(old + 12)];
      _sIv::P32 = P32[(old + 8)];
      goto cQ5;
  cQ5:
      if (Sp - <highSp> < SpLim) goto cQi; else goto cQj;
  cQi:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
      P32[(old + 20)] = _sIs::P32;
      P32[(old + 16)] = _sIt::P32;
      P32[(old + 12)] = _sIu::P32;
      P32[(old + 8)] = _sIv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cQj:
      I32[(young<cQ7> + 4)] = cQ7;
      R1 = _sIv::P32;
      if (R1 & 3 != 0) goto cQ7; else goto cQ8;
  cQ8:
      call (I32[R1])(R1) returns to cQ7, args: 4, res: 4, upd: 4;
  cQ7:
      _sIw::P32 = R1;
      _cQd::P32 = _sIw::P32 & 3;
      if (_cQd::P32 >= 2) goto cQc; else goto cQb;
  cQc:
      _sIx::P32 = P32[_sIw::P32 + 2];
      _sIy::P32 = P32[_sIw::P32 + 6];
      I32[(young<cQp> + 4)] = cQp;
      R1 = _sIx::P32;
      if (R1 & 3 != 0) goto cQp; else goto cQq;
  cQq:
      call (I32[R1])(R1) returns to cQp, args: 4, res: 4, upd: 4;
  cQp:
      _sIz::P32 = R1;
      _sIA::P32 = P32[_sIz::P32 + 3];
      _sIB::P32 = P32[_sIz::P32 + 7];
      I32[(young<cQu> + 4)] = cQu;
      P32[(young<cQu> + 20)] = _sIs::P32;
      P32[(young<cQu> + 16)] = _sIt::P32;
      P32[(young<cQu> + 12)] = _sIu::P32;
      P32[(young<cQu> + 8)] = _sIy::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQu, args: 20, res: 4, upd: 4;
  cQu:
      _sIC::P32 = R1;
      P32[(old + 28)] = _sIs::P32;
      P32[(old + 24)] = _sIt::P32;
      P32[(old + 20)] = _sIu::P32;
      P32[(old + 16)] = _sIA::P32;
      P32[(old + 12)] = _sIB::P32;
      P32[(old + 8)] = _sIC::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cQb:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cQh:
      _sIs::P32 = P32[(old + 20)];
      _sIt::P32 = P32[(old + 16)];
      _sIu::P32 = P32[(old + 12)];
      _sIv::P32 = P32[(old + 8)];
      goto cQ5;
  cQ5:
      if (Sp - <highSp> < SpLim) goto cQi; else goto cQj;
  cQi:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
      P32[(old + 20)] = _sIs::P32;
      P32[(old + 16)] = _sIt::P32;
      P32[(old + 12)] = _sIu::P32;
      P32[(old + 8)] = _sIv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cQj:
      I32[(young<cQ7> + 4)] = cQ7;
      R1 = _sIv::P32;
      if (R1 & 3 != 0) goto cQ7; else goto cQ8;
  cQ8:
      call (I32[R1])(R1) returns to cQ7, args: 4, res: 4, upd: 4;
  cQ7:
      _sIw::P32 = R1;
      _cQd::P32 = _sIw::P32 & 3;
      if (_cQd::P32 >= 2) goto cQc; else goto cQb;
  cQc:
      _sIx::P32 = P32[_sIw::P32 + 2];
      _sIy::P32 = P32[_sIw::P32 + 6];
      I32[(young<cQp> + 4)] = cQp;
      R1 = _sIx::P32;
      if (R1 & 3 != 0) goto cQp; else goto cQq;
  cQq:
      call (I32[R1])(R1) returns to cQp, args: 4, res: 4, upd: 4;
  cQp:
      _sIz::P32 = R1;
      _sIA::P32 = P32[_sIz::P32 + 3];
      _sIB::P32 = P32[_sIz::P32 + 7];
      I32[(young<cQu> + 4)] = cQu;
      P32[(young<cQu> + 20)] = _sIs::P32;
      P32[(young<cQu> + 16)] = _sIt::P32;
      P32[(young<cQu> + 12)] = _sIu::P32;
      P32[(young<cQu> + 8)] = _sIy::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQu, args: 20, res: 4, upd: 4;
  cQu:
      _sIC::P32 = R1;
      P32[(old + 28)] = _sIs::P32;
      P32[(old + 24)] = _sIt::P32;
      P32[(old + 20)] = _sIu::P32;
      P32[(old + 16)] = _sIA::P32;
      P32[(old + 12)] = _sIB::P32;
      P32[(old + 8)] = _sIC::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cQb:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cQh:
      _sIs::P32 = P32[Sp];
      _sIt::P32 = P32[Sp + 4];
      _sIu::P32 = P32[Sp + 8];
      _sIv::P32 = P32[Sp + 12];
      goto cQ5;
  cQ5:
      if (Sp - 24 < SpLim) goto cQi; else goto cQj;
  cQi:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cQj:
      I32[Sp - 4] = cQ7;
      R1 = _sIv::P32;
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto cQ7; else goto cQ8;
  cQ8:
      call (I32[R1])(R1) returns to cQ7, args: 4, res: 4, upd: 4;
  cQ7:
      _sIs::P32 = P32[Sp + 4];
      _sIt::P32 = P32[Sp + 8];
      _sIu::P32 = P32[Sp + 12];
      _sIw::P32 = R1;
      _cQd::P32 = _sIw::P32 & 3;
      if (_cQd::P32 >= 2) goto cQc; else goto cQb;
  cQc:
      _sIx::P32 = P32[_sIw::P32 + 2];
      _sIy::P32 = P32[_sIw::P32 + 6];
      I32[Sp] = cQp;
      R1 = _sIx::P32;
      P32[Sp + 16] = _sIy::P32;
      if (R1 & 3 != 0) goto cQp; else goto cQq;
  cQq:
      call (I32[R1])(R1) returns to cQp, args: 4, res: 4, upd: 4;
  cQp:
      _sIs::P32 = P32[Sp + 4];
      _sIt::P32 = P32[Sp + 8];
      _sIu::P32 = P32[Sp + 12];
      _sIy::P32 = P32[Sp + 16];
      _sIz::P32 = R1;
      _sIA::P32 = P32[_sIz::P32 + 3];
      _sIB::P32 = P32[_sIz::P32 + 7];
      I32[Sp - 4] = cQu;
      P32[Sp - 20] = _sIs::P32;
      P32[Sp - 16] = _sIt::P32;
      P32[Sp - 12] = _sIu::P32;
      P32[Sp - 8] = _sIy::P32;
      P32[Sp] = _sIB::P32;
      P32[Sp + 16] = _sIA::P32;
      Sp = Sp - 20;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQu, args: 20, res: 4, upd: 4;
  cQu:
      _sIs::P32 = P32[Sp + 8];
      _sIt::P32 = P32[Sp + 12];
      _sIu::P32 = P32[Sp + 16];
      _sIA::P32 = P32[Sp + 20];
      _sIB::P32 = P32[Sp + 4];
      _sIC::P32 = R1;
      P32[Sp] = _sIs::P32;
      P32[Sp + 4] = _sIt::P32;
      P32[Sp + 8] = _sIu::P32;
      P32[Sp + 12] = _sIA::P32;
      P32[Sp + 16] = _sIB::P32;
      P32[Sp + 20] = _sIC::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cQb:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cQh:
      goto cQ5;
  cQ5:
      if ((Sp + -24) < SpLim) goto cQi; else goto cQj;
  cQi:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cQj:
      I32[Sp - 4] = cQ7;
      R1 = P32[Sp + 12];
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto cQ7; else goto cQ8;
  cQ8:
      call (I32[R1])(R1) returns to cQ7, args: 4, res: 4, upd: 4;
  cQ7:
      _sIw::P32 = R1;
      if (_sIw::P32 & 3 >= 2) goto cQc; else goto cQb;
  cQc:
      I32[Sp] = cQp;
      R1 = P32[_sIw::P32 + 2];
      P32[Sp + 16] = P32[_sIw::P32 + 6];
      if (R1 & 3 != 0) goto cQp; else goto cQq;
  cQq:
      call (I32[R1])(R1) returns to cQp, args: 4, res: 4, upd: 4;
  cQp:
      I32[Sp - 4] = cQu;
      P32[Sp - 20] = P32[Sp + 4];
      P32[Sp - 16] = P32[Sp + 8];
      P32[Sp - 12] = P32[Sp + 12];
      P32[Sp - 8] = P32[Sp + 16];
      _sIz::P32 = R1;
      P32[Sp] = P32[_sIz::P32 + 7];
      P32[Sp + 16] = P32[_sIz::P32 + 3];
      Sp = Sp - 20;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQu, args: 20, res: 4, upd: 4;
  cQu:
      P32[Sp] = P32[Sp + 8];
      _sIB::P32 = P32[Sp + 4];
      P32[Sp + 4] = P32[Sp + 12];
      P32[Sp + 8] = P32[Sp + 16];
      P32[Sp + 12] = P32[Sp + 20];
      P32[Sp + 16] = _sIB::P32;
      P32[Sp + 20] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cQb:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cQ5,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQ7,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQ8,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQb, {}),
 (cQc,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQh,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQi, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (cQj,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQp,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQq,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQu, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_$cfromList_entry() //  []
        { info_tbl: [(cQ7,
                      label: block_cQ7_info
                      rep:StackRep [False, False, False, True]),
                     (cQh,
                      label: T2902_B_PairingSum.$fSumPSumab_$cfromList_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                     (cQp,
                      label: block_cQp_info
                      rep:StackRep [False, False, False, False]),
                     (cQu,
                      label: block_cQu_info
                      rep:StackRep [False, False, False, False, False])]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cQh:
          goto cQ5;
      cQ5:
          if ((Sp + -24) < SpLim) goto cQi; else goto cQj;
      cQi:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cQj:
          I32[Sp - 4] = cQ7;
          R1 = P32[Sp + 12];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto cQ7; else goto cQ8;
      cQ8:
          call (I32[R1])(R1) returns to cQ7, args: 4, res: 4, upd: 4;
      cQ7:
          _sIw::P32 = R1;
          if (_sIw::P32 & 3 >= 2) goto cQc; else goto cQb;
      cQc:
          I32[Sp] = cQp;
          R1 = P32[_sIw::P32 + 2];
          P32[Sp + 16] = P32[_sIw::P32 + 6];
          if (R1 & 3 != 0) goto cQp; else goto cQq;
      cQq:
          call (I32[R1])(R1) returns to cQp, args: 4, res: 4, upd: 4;
      cQp:
          I32[Sp - 4] = cQu;
          P32[Sp - 20] = P32[Sp + 4];
          P32[Sp - 16] = P32[Sp + 8];
          P32[Sp - 12] = P32[Sp + 12];
          P32[Sp - 8] = P32[Sp + 16];
          _sIz::P32 = R1;
          P32[Sp] = P32[_sIz::P32 + 7];
          P32[Sp + 16] = P32[_sIz::P32 + 3];
          Sp = Sp - 20;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQu, args: 20, res: 4, upd: 4;
      cQu:
          P32[Sp] = P32[Sp + 8];
          _sIB::P32 = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp + 12];
          P32[Sp + 8] = P32[Sp + 16];
          P32[Sp + 12] = P32[Sp + 20];
          P32[Sp + 16] = _sIB::P32;
          P32[Sp + 20] = R1;
          call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
      cQb:
          R1 = T2902_B_PairingSum.Empty_closure+1;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_$cfromList_entry() //  []
        { info_tbl: [(cQ5,
                      label: T2902_B_PairingSum.$fSumPSumab_$cfromList_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                     (cQ7,
                      label: block_cQ7_info
                      rep:StackRep [False, False, False, True]),
                     (cQp,
                      label: block_cQp_info
                      rep:StackRep [False, False, False, False]),
                     (cQu,
                      label: block_cQu_info
                      rep:StackRep [False, False, False, False, False])]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cQ5:
          if ((Sp + -24) < SpLim) goto cQi; else goto cQj;
      cQi:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cQj:
          I32[Sp - 4] = cQ7;
          R1 = P32[Sp + 12];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto cQ7; else goto cQ8;
      cQ8:
          call (I32[R1])(R1) returns to cQ7, args: 4, res: 4, upd: 4;
      cQ7:
          _sIw::P32 = R1;
          if (_sIw::P32 & 3 >= 2) goto cQc; else goto cQb;
      cQc:
          I32[Sp] = cQp;
          R1 = P32[_sIw::P32 + 2];
          P32[Sp + 16] = P32[_sIw::P32 + 6];
          if (R1 & 3 != 0) goto cQp; else goto cQq;
      cQq:
          call (I32[R1])(R1) returns to cQp, args: 4, res: 4, upd: 4;
      cQp:
          I32[Sp - 4] = cQu;
          P32[Sp - 20] = P32[Sp + 4];
          P32[Sp - 16] = P32[Sp + 8];
          P32[Sp - 12] = P32[Sp + 12];
          P32[Sp - 8] = P32[Sp + 16];
          _sIz::P32 = R1;
          P32[Sp] = P32[_sIz::P32 + 7];
          P32[Sp + 16] = P32[_sIz::P32 + 3];
          Sp = Sp - 20;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQu, args: 20, res: 4, upd: 4;
      cQu:
          P32[Sp] = P32[Sp + 8];
          _sIB::P32 = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp + 12];
          P32[Sp + 8] = P32[Sp + 16];
          P32[Sp + 12] = P32[Sp + 20];
          P32[Sp + 16] = _sIB::P32;
          P32[Sp + 20] = R1;
          call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
      cQb:
          R1 = T2902_B_PairingSum.Empty_closure+1;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cfromList_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cfromList_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cfromList_entry() //  []
         { info_tbl: [(cQ5,
                       label: T2902_B_PairingSum.$fSumPSumab_$cfromList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cQ7,
                       label: block_cQ7_info
                       rep:StackRep [False, False, False, True]),
                      (cQp,
                       label: block_cQp_info
                       rep:StackRep [False, False, False, False]),
                      (cQu,
                       label: block_cQu_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cQ5:
           if ((Sp + -24) < SpLim) goto cQi; else goto cQj;
       cQi:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cQj:
           I32[Sp - 4] = cQ7;
           R1 = P32[Sp + 12];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto cQ7; else goto cQ8;
       cQ8:
           call (I32[R1])(R1) returns to cQ7, args: 4, res: 4, upd: 4;
       cQ7:
           _sIw::P32 = R1;
           if (_sIw::P32 & 3 >= 2) goto cQc; else goto cQb;
       cQc:
           I32[Sp] = cQp;
           R1 = P32[_sIw::P32 + 2];
           P32[Sp + 16] = P32[_sIw::P32 + 6];
           if (R1 & 3 != 0) goto cQp; else goto cQq;
       cQq:
           call (I32[R1])(R1) returns to cQp, args: 4, res: 4, upd: 4;
       cQp:
           I32[Sp - 4] = cQu;
           P32[Sp - 20] = P32[Sp + 4];
           P32[Sp - 16] = P32[Sp + 8];
           P32[Sp - 12] = P32[Sp + 12];
           P32[Sp - 8] = P32[Sp + 16];
           _sIz::P32 = R1;
           P32[Sp] = P32[_sIz::P32 + 7];
           P32[Sp + 16] = P32[_sIz::P32 + 3];
           Sp = Sp - 20;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQu, args: 20, res: 4, upd: 4;
       cQu:
           P32[Sp] = P32[Sp + 8];
           _sIB::P32 = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp + 12];
           P32[Sp + 8] = P32[Sp + 16];
           P32[Sp + 12] = P32[Sp + 20];
           P32[Sp + 16] = _sIB::P32;
           P32[Sp + 20] = R1;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
       cQb:
           R1 = T2902_B_PairingSum.Empty_closure+1;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cfromList_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cfromList_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cfromList_entry() //  []
         { info_tbl: [(cQ5,
                       label: T2902_B_PairingSum.$fSumPSumab_$cfromList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cQ7,
                       label: block_cQ7_info
                       rep:StackRep [False, False, False, True]),
                      (cQp,
                       label: block_cQp_info
                       rep:StackRep [False, False, False, False]),
                      (cQu,
                       label: block_cQu_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cQ5:
           if ((Sp + -24) < SpLim) goto cQi; else goto cQj;
       cQi:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cQj:
           I32[Sp - 4] = cQ7;
           R1 = P32[Sp + 12];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto cQ7; else goto cQ8;
       cQ8:
           call (I32[R1])(R1) returns to cQ7, args: 4, res: 4, upd: 4;
       cQ7:
           _sIw::P32 = R1;
           if (_sIw::P32 & 3 >= 2) goto cQc; else goto cQb;
       cQc:
           I32[Sp] = cQp;
           R1 = P32[_sIw::P32 + 2];
           P32[Sp + 16] = P32[_sIw::P32 + 6];
           if (R1 & 3 != 0) goto cQp; else goto cQq;
       cQq:
           call (I32[R1])(R1) returns to cQp, args: 4, res: 4, upd: 4;
       cQp:
           I32[Sp - 4] = cQu;
           P32[Sp - 20] = P32[Sp + 4];
           P32[Sp - 16] = P32[Sp + 8];
           P32[Sp - 12] = P32[Sp + 12];
           P32[Sp - 8] = P32[Sp + 16];
           _sIz::P32 = R1;
           P32[Sp] = P32[_sIz::P32 + 7];
           P32[Sp + 16] = P32[_sIz::P32 + 3];
           Sp = Sp - 20;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQu, args: 20, res: 4, upd: 4;
       cQu:
           P32[Sp] = P32[Sp + 8];
           _sIB::P32 = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp + 12];
           P32[Sp + 8] = P32[Sp + 16];
           P32[Sp + 12] = P32[Sp + 20];
           P32[Sp + 16] = _sIB::P32;
           P32[Sp + 20] = R1;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
       cQb:
           R1 = T2902_B_PairingSum.Empty_closure+1;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_closure:
         const T2902_B_PairingSum.$fSumPSumab_info;
         const 0;
 },
 sat_sIL_entry() //  [R1]
         { info_tbl: [(cR1,
                       label: sat_sIL_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cR1:
           _sIL::P32 = R1;
           _B1::P32 = P32[(old + 8)];
           goto cQZ;
       cQZ:
           if (Sp - <highSp> < SpLim) goto cR2; else goto cR3;
       cR2:
           R1 = _sIL::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cR3:
           _sID::P32 = P32[_sIL::P32 + 3];
           _sIE::P32 = P32[_sIL::P32 + 7];
           _sIF::P32 = P32[_sIL::P32 + 11];
           P32[(old + 20)] = _sID::P32;
           P32[(old + 16)] = _sIE::P32;
           P32[(old + 12)] = _sIF::P32;
           P32[(old + 8)] = _B1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIK_entry() //  [R1]
         { info_tbl: [(cR8,
                       label: sat_sIK_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cR8:
           _sIK::P32 = R1;
           _B1::P32 = P32[(old + 8)];
           goto cR6;
       cR6:
           if (Sp - <highSp> < SpLim) goto cR9; else goto cRa;
       cR9:
           R1 = _sIK::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRa:
           _sID::P32 = P32[_sIK::P32 + 3];
           _sIE::P32 = P32[_sIK::P32 + 7];
           _sIF::P32 = P32[_sIK::P32 + 11];
           P32[(old + 20)] = _sID::P32;
           P32[(old + 16)] = _sIE::P32;
           P32[(old + 12)] = _sIF::P32;
           P32[(old + 8)] = _B1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIJ_entry() //  [R1]
         { info_tbl: [(cRf,
                       label: sat_sIJ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cRf:
           _sIJ::P32 = R1;
           _B1::P32 = P32[(old + 8)];
           goto cRd;
       cRd:
           if (Sp - <highSp> < SpLim) goto cRg; else goto cRh;
       cRg:
           R1 = _sIJ::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRh:
           _sID::P32 = P32[_sIJ::P32 + 3];
           _sIE::P32 = P32[_sIJ::P32 + 7];
           _sIF::P32 = P32[_sIJ::P32 + 11];
           P32[(old + 20)] = _sID::P32;
           P32[(old + 16)] = _sIE::P32;
           P32[(old + 12)] = _sIF::P32;
           P32[(old + 8)] = _B1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sII_entry() //  [R1]
         { info_tbl: [(cRm,
                       label: sat_sII_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cRm:
           _sII::P32 = R1;
           _B1::P32 = P32[(old + 8)];
           goto cRk;
       cRk:
           if (Sp - <highSp> < SpLim) goto cRn; else goto cRo;
       cRn:
           R1 = _sII::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRo:
           _sID::P32 = P32[_sII::P32 + 3];
           _sIE::P32 = P32[_sII::P32 + 7];
           _sIF::P32 = P32[_sII::P32 + 11];
           P32[(old + 20)] = _sID::P32;
           P32[(old + 16)] = _sIE::P32;
           P32[(old + 12)] = _sIF::P32;
           P32[(old + 8)] = _B1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIH_entry() //  [R1]
         { info_tbl: [(cRt,
                       label: sat_sIH_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 12 updfr_space: Just 4
         }
     {offset
       cRt:
           _sIH::P32 = R1;
           _B2::P32 = P32[(old + 12)];
           _B1::P32 = P32[(old + 8)];
           goto cRr;
       cRr:
           if (Sp - <highSp> < SpLim) goto cRu; else goto cRv;
       cRu:
           R1 = _sIH::P32;
           P32[(old + 12)] = _B2::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
       cRv:
           _sID::P32 = P32[_sIH::P32 + 2];
           _sIE::P32 = P32[_sIH::P32 + 6];
           _sIF::P32 = P32[_sIH::P32 + 10];
           P32[(old + 24)] = _sID::P32;
           P32[(old + 20)] = _sIE::P32;
           P32[(old + 16)] = _sIF::P32;
           P32[(old + 12)] = _B2::P32;
           P32[(old + 8)] = _B1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
     }
 },
 sat_sIG_entry() //  [R1]
         { info_tbl: [(cRA,
                       label: sat_sIG_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cRA:
           _sIG::P32 = R1;
           _B3::P32 = P32[(old + 16)];
           _B2::P32 = P32[(old + 12)];
           _B1::P32 = P32[(old + 8)];
           goto cRy;
       cRy:
           if (Sp - <highSp> < SpLim) goto cRB; else goto cRC;
       cRB:
           R1 = _sIG::P32;
           P32[(old + 16)] = _B3::P32;
           P32[(old + 12)] = _B2::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cRC:
           _sID::P32 = P32[_sIG::P32 + 1];
           _sIE::P32 = P32[_sIG::P32 + 5];
           _sIF::P32 = P32[_sIG::P32 + 9];
           P32[(old + 28)] = _sID::P32;
           P32[(old + 24)] = _sIE::P32;
           P32[(old + 20)] = _sIF::P32;
           P32[(old + 16)] = _B3::P32;
           P32[(old + 12)] = _B2::P32;
           P32[(old + 8)] = _B1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_entry() //  []
         { info_tbl: [(cRE,
                       label: T2902_B_PairingSum.$fSumPSumab_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cRE:
           _sID::P32 = P32[(old + 16)];
           _sIE::P32 = P32[(old + 12)];
           _sIF::P32 = P32[(old + 8)];
           goto cQV;
       cQV:
           if (Sp - <highSp> < SpLim) goto cRF; else goto cRG;
       cRG:
           Hp = Hp + 124;
           if (Hp > HpLim) goto cRI; else goto cRH;
       cRI:
           HpAlloc = 124;
           goto cRF;
       cRF:
           R1 = T2902_B_PairingSum.$fSumPSumab_closure;
           P32[(old + 16)] = _sID::P32;
           P32[(old + 12)] = _sIE::P32;
           P32[(old + 8)] = _sIF::P32;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cRH:
           I32[Hp - 120] = sat_sIL_info;
           P32[Hp - 116] = _sID::P32;
           P32[Hp - 112] = _sIE::P32;
           P32[Hp - 108] = _sIF::P32;
           _cQX::P32 = Hp - 119;
           I32[Hp - 104] = sat_sIK_info;
           P32[Hp - 100] = _sID::P32;
           P32[Hp - 96] = _sIE::P32;
           P32[Hp - 92] = _sIF::P32;
           _cR4::P32 = Hp - 103;
           I32[Hp - 88] = sat_sIJ_info;
           P32[Hp - 84] = _sID::P32;
           P32[Hp - 80] = _sIE::P32;
           P32[Hp - 76] = _sIF::P32;
           _cRb::P32 = Hp - 87;
           I32[Hp - 72] = sat_sII_info;
           P32[Hp - 68] = _sID::P32;
           P32[Hp - 64] = _sIE::P32;
           P32[Hp - 60] = _sIF::P32;
           _cRi::P32 = Hp - 71;
           I32[Hp - 56] = sat_sIH_info;
           P32[Hp - 52] = _sID::P32;
           P32[Hp - 48] = _sIE::P32;
           P32[Hp - 44] = _sIF::P32;
           _cRp::P32 = Hp - 54;
           I32[Hp - 40] = sat_sIG_info;
           P32[Hp - 36] = _sID::P32;
           P32[Hp - 32] = _sIE::P32;
           P32[Hp - 28] = _sIF::P32;
           _cRw::P32 = Hp - 37;
           I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
           P32[Hp - 20] = _cRw::P32;
           P32[Hp - 16] = _cRp::P32;
           P32[Hp - 12] = _cRi::P32;
           P32[Hp - 8] = _cRb::P32;
           P32[Hp - 4] = _cR4::P32;
           P32[Hp] = _cQX::P32;
           _cRD::P32 = Hp - 23;
           R1 = _cRD::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cR1:
      _sIL::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cQZ;
  cQZ:
      if (Sp - <highSp> < SpLim) goto cR2; else goto cR3;
  cR2:
      R1 = _sIL::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cR3:
      _sID::P32 = P32[_sIL::P32 + 3];
      _sIE::P32 = P32[_sIL::P32 + 7];
      _sIF::P32 = P32[_sIL::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cR1:
      _sIL::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cQZ;
  cQZ:
      if (Sp - <highSp> < SpLim) goto cR2; else goto cR3;
  cR2:
      R1 = _sIL::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cR3:
      _sID::P32 = P32[_sIL::P32 + 3];
      _sIE::P32 = P32[_sIL::P32 + 7];
      _sIF::P32 = P32[_sIL::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cR1:
      _sIL::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cQZ;
  cQZ:
      if (Sp - <highSp> < SpLim) goto cR2; else goto cR3;
  cR2:
      R1 = _sIL::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cR3:
      _sID::P32 = P32[_sIL::P32 + 3];
      _sIE::P32 = P32[_sIL::P32 + 7];
      _sIF::P32 = P32[_sIL::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cR1:
      _sIL::P32 = R1;
      _B1::P32 = P32[Sp];
      goto cQZ;
  cQZ:
      if (Sp - 12 < SpLim) goto cR2; else goto cR3;
  cR2:
      R1 = _sIL::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cR3:
      _sID::P32 = P32[_sIL::P32 + 3];
      _sIE::P32 = P32[_sIL::P32 + 7];
      _sIF::P32 = P32[_sIL::P32 + 11];
      P32[Sp - 12] = _sID::P32;
      P32[Sp - 8] = _sIE::P32;
      P32[Sp - 4] = _sIF::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cR1:
      goto cQZ;
  cQZ:
      _sIL::P32 = R1;
      if ((Sp + -12) < SpLim) goto cR2; else goto cR3;
  cR2:
      R1 = _sIL::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cR3:
      P32[Sp - 12] = P32[_sIL::P32 + 3];
      P32[Sp - 8] = P32[_sIL::P32 + 7];
      P32[Sp - 4] = P32[_sIL::P32 + 11];
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cQZ, {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure}),
 (cR1, {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure}),
 (cR2, {}),
 (cR3, {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure})]



==================== after setInfoTableStackMap ====================
sat_sIL_entry() //  [R1]
        { info_tbl: [(cR1,
                      label: sat_sIL_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cR1:
          goto cQZ;
      cQZ:
          _sIL::P32 = R1;
          if ((Sp + -12) < SpLim) goto cR2; else goto cR3;
      cR2:
          R1 = _sIL::P32;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cR3:
          P32[Sp - 12] = P32[_sIL::P32 + 3];
          P32[Sp - 8] = P32[_sIL::P32 + 7];
          P32[Sp - 4] = P32[_sIL::P32 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
sat_sIL_entry() //  [R1]
        { info_tbl: [(cQZ,
                      label: sat_sIL_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cQZ:
          _sIL::P32 = R1;
          if ((Sp + -12) < SpLim) goto cR2; else goto cR3;
      cR2:
          R1 = _sIL::P32;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cR3:
          P32[Sp - 12] = P32[_sIL::P32 + 3];
          P32[Sp - 8] = P32[_sIL::P32 + 7];
          P32[Sp - 4] = P32[_sIL::P32 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cR8:
      _sIK::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cR6;
  cR6:
      if (Sp - <highSp> < SpLim) goto cR9; else goto cRa;
  cR9:
      R1 = _sIK::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRa:
      _sID::P32 = P32[_sIK::P32 + 3];
      _sIE::P32 = P32[_sIK::P32 + 7];
      _sIF::P32 = P32[_sIK::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cR8:
      _sIK::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cR6;
  cR6:
      if (Sp - <highSp> < SpLim) goto cR9; else goto cRa;
  cR9:
      R1 = _sIK::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRa:
      _sID::P32 = P32[_sIK::P32 + 3];
      _sIE::P32 = P32[_sIK::P32 + 7];
      _sIF::P32 = P32[_sIK::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cR8:
      _sIK::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cR6;
  cR6:
      if (Sp - <highSp> < SpLim) goto cR9; else goto cRa;
  cR9:
      R1 = _sIK::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRa:
      _sID::P32 = P32[_sIK::P32 + 3];
      _sIE::P32 = P32[_sIK::P32 + 7];
      _sIF::P32 = P32[_sIK::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cR8:
      _sIK::P32 = R1;
      _B1::P32 = P32[Sp];
      goto cR6;
  cR6:
      if (Sp - 12 < SpLim) goto cR9; else goto cRa;
  cR9:
      R1 = _sIK::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRa:
      _sID::P32 = P32[_sIK::P32 + 3];
      _sIE::P32 = P32[_sIK::P32 + 7];
      _sIF::P32 = P32[_sIK::P32 + 11];
      P32[Sp - 12] = _sID::P32;
      P32[Sp - 8] = _sIE::P32;
      P32[Sp - 4] = _sIF::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cR8:
      goto cR6;
  cR6:
      _sIK::P32 = R1;
      if ((Sp + -12) < SpLim) goto cR9; else goto cRa;
  cR9:
      R1 = _sIK::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRa:
      P32[Sp - 12] = P32[_sIK::P32 + 3];
      P32[Sp - 8] = P32[_sIK::P32 + 7];
      P32[Sp - 4] = P32[_sIK::P32 + 11];
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cR6, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (cR8, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (cR9, {}),
 (cRa, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure})]



==================== after setInfoTableStackMap ====================
sat_sIK_entry() //  [R1]
        { info_tbl: [(cR8,
                      label: sat_sIK_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cR8:
          goto cR6;
      cR6:
          _sIK::P32 = R1;
          if ((Sp + -12) < SpLim) goto cR9; else goto cRa;
      cR9:
          R1 = _sIK::P32;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cRa:
          P32[Sp - 12] = P32[_sIK::P32 + 3];
          P32[Sp - 8] = P32[_sIK::P32 + 7];
          P32[Sp - 4] = P32[_sIK::P32 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
sat_sIK_entry() //  [R1]
        { info_tbl: [(cR6,
                      label: sat_sIK_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cR6:
          _sIK::P32 = R1;
          if ((Sp + -12) < SpLim) goto cR9; else goto cRa;
      cR9:
          R1 = _sIK::P32;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cRa:
          P32[Sp - 12] = P32[_sIK::P32 + 3];
          P32[Sp - 8] = P32[_sIK::P32 + 7];
          P32[Sp - 4] = P32[_sIK::P32 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cRf:
      _sIJ::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cRd;
  cRd:
      if (Sp - <highSp> < SpLim) goto cRg; else goto cRh;
  cRg:
      R1 = _sIJ::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRh:
      _sID::P32 = P32[_sIJ::P32 + 3];
      _sIE::P32 = P32[_sIJ::P32 + 7];
      _sIF::P32 = P32[_sIJ::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cRf:
      _sIJ::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cRd;
  cRd:
      if (Sp - <highSp> < SpLim) goto cRg; else goto cRh;
  cRg:
      R1 = _sIJ::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRh:
      _sID::P32 = P32[_sIJ::P32 + 3];
      _sIE::P32 = P32[_sIJ::P32 + 7];
      _sIF::P32 = P32[_sIJ::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cRf:
      _sIJ::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cRd;
  cRd:
      if (Sp - <highSp> < SpLim) goto cRg; else goto cRh;
  cRg:
      R1 = _sIJ::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRh:
      _sID::P32 = P32[_sIJ::P32 + 3];
      _sIE::P32 = P32[_sIJ::P32 + 7];
      _sIF::P32 = P32[_sIJ::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cRf:
      _sIJ::P32 = R1;
      _B1::P32 = P32[Sp];
      goto cRd;
  cRd:
      if (Sp - 12 < SpLim) goto cRg; else goto cRh;
  cRg:
      R1 = _sIJ::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRh:
      _sID::P32 = P32[_sIJ::P32 + 3];
      _sIE::P32 = P32[_sIJ::P32 + 7];
      _sIF::P32 = P32[_sIJ::P32 + 11];
      P32[Sp - 12] = _sID::P32;
      P32[Sp - 8] = _sIE::P32;
      P32[Sp - 4] = _sIF::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cRf:
      goto cRd;
  cRd:
      _sIJ::P32 = R1;
      if ((Sp + -12) < SpLim) goto cRg; else goto cRh;
  cRg:
      R1 = _sIJ::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRh:
      P32[Sp - 12] = P32[_sIJ::P32 + 3];
      P32[Sp - 8] = P32[_sIJ::P32 + 7];
      P32[Sp - 4] = P32[_sIJ::P32 + 11];
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cRd, {T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure}),
 (cRf, {T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure}),
 (cRg, {}),
 (cRh, {T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure})]



==================== after setInfoTableStackMap ====================
sat_sIJ_entry() //  [R1]
        { info_tbl: [(cRf,
                      label: sat_sIJ_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cRf:
          goto cRd;
      cRd:
          _sIJ::P32 = R1;
          if ((Sp + -12) < SpLim) goto cRg; else goto cRh;
      cRg:
          R1 = _sIJ::P32;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cRh:
          P32[Sp - 12] = P32[_sIJ::P32 + 3];
          P32[Sp - 8] = P32[_sIJ::P32 + 7];
          P32[Sp - 4] = P32[_sIJ::P32 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
sat_sIJ_entry() //  [R1]
        { info_tbl: [(cRd,
                      label: sat_sIJ_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cRd:
          _sIJ::P32 = R1;
          if ((Sp + -12) < SpLim) goto cRg; else goto cRh;
      cRg:
          R1 = _sIJ::P32;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cRh:
          P32[Sp - 12] = P32[_sIJ::P32 + 3];
          P32[Sp - 8] = P32[_sIJ::P32 + 7];
          P32[Sp - 4] = P32[_sIJ::P32 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cRm:
      _sII::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cRk;
  cRk:
      if (Sp - <highSp> < SpLim) goto cRn; else goto cRo;
  cRn:
      R1 = _sII::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRo:
      _sID::P32 = P32[_sII::P32 + 3];
      _sIE::P32 = P32[_sII::P32 + 7];
      _sIF::P32 = P32[_sII::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cRm:
      _sII::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cRk;
  cRk:
      if (Sp - <highSp> < SpLim) goto cRn; else goto cRo;
  cRn:
      R1 = _sII::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRo:
      _sID::P32 = P32[_sII::P32 + 3];
      _sIE::P32 = P32[_sII::P32 + 7];
      _sIF::P32 = P32[_sII::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cRm:
      _sII::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cRk;
  cRk:
      if (Sp - <highSp> < SpLim) goto cRn; else goto cRo;
  cRn:
      R1 = _sII::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRo:
      _sID::P32 = P32[_sII::P32 + 3];
      _sIE::P32 = P32[_sII::P32 + 7];
      _sIF::P32 = P32[_sII::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cRm:
      _sII::P32 = R1;
      _B1::P32 = P32[Sp];
      goto cRk;
  cRk:
      if (Sp - 12 < SpLim) goto cRn; else goto cRo;
  cRn:
      R1 = _sII::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRo:
      _sID::P32 = P32[_sII::P32 + 3];
      _sIE::P32 = P32[_sII::P32 + 7];
      _sIF::P32 = P32[_sII::P32 + 11];
      P32[Sp - 12] = _sID::P32;
      P32[Sp - 8] = _sIE::P32;
      P32[Sp - 4] = _sIF::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cRm:
      goto cRk;
  cRk:
      _sII::P32 = R1;
      if ((Sp + -12) < SpLim) goto cRn; else goto cRo;
  cRn:
      R1 = _sII::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRo:
      P32[Sp - 12] = P32[_sII::P32 + 3];
      P32[Sp - 8] = P32[_sII::P32 + 7];
      P32[Sp - 4] = P32[_sII::P32 + 11];
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cRk, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cRm, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cRn, {}),
 (cRo, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure})]



==================== after setInfoTableStackMap ====================
sat_sII_entry() //  [R1]
        { info_tbl: [(cRm,
                      label: sat_sII_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cRm:
          goto cRk;
      cRk:
          _sII::P32 = R1;
          if ((Sp + -12) < SpLim) goto cRn; else goto cRo;
      cRn:
          R1 = _sII::P32;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cRo:
          P32[Sp - 12] = P32[_sII::P32 + 3];
          P32[Sp - 8] = P32[_sII::P32 + 7];
          P32[Sp - 4] = P32[_sII::P32 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
sat_sII_entry() //  [R1]
        { info_tbl: [(cRk,
                      label: sat_sII_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cRk:
          _sII::P32 = R1;
          if ((Sp + -12) < SpLim) goto cRn; else goto cRo;
      cRn:
          R1 = _sII::P32;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cRo:
          P32[Sp - 12] = P32[_sII::P32 + 3];
          P32[Sp - 8] = P32[_sII::P32 + 7];
          P32[Sp - 4] = P32[_sII::P32 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cRt:
      _sIH::P32 = R1;
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRr;
  cRr:
      if (Sp - <highSp> < SpLim) goto cRu; else goto cRv;
  cRu:
      R1 = _sIH::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  cRv:
      _sID::P32 = P32[_sIH::P32 + 2];
      _sIE::P32 = P32[_sIH::P32 + 6];
      _sIF::P32 = P32[_sIH::P32 + 10];
      P32[(old + 24)] = _sID::P32;
      P32[(old + 20)] = _sIE::P32;
      P32[(old + 16)] = _sIF::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cRt:
      _sIH::P32 = R1;
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRr;
  cRr:
      if (Sp - <highSp> < SpLim) goto cRu; else goto cRv;
  cRu:
      R1 = _sIH::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  cRv:
      _sID::P32 = P32[_sIH::P32 + 2];
      _sIE::P32 = P32[_sIH::P32 + 6];
      _sIF::P32 = P32[_sIH::P32 + 10];
      P32[(old + 24)] = _sID::P32;
      P32[(old + 20)] = _sIE::P32;
      P32[(old + 16)] = _sIF::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cRt:
      _sIH::P32 = R1;
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRr;
  cRr:
      if (Sp - <highSp> < SpLim) goto cRu; else goto cRv;
  cRu:
      R1 = _sIH::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  cRv:
      _sID::P32 = P32[_sIH::P32 + 2];
      _sIE::P32 = P32[_sIH::P32 + 6];
      _sIF::P32 = P32[_sIH::P32 + 10];
      P32[(old + 24)] = _sID::P32;
      P32[(old + 20)] = _sIE::P32;
      P32[(old + 16)] = _sIF::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cRt:
      _sIH::P32 = R1;
      _B2::P32 = P32[Sp];
      _B1::P32 = P32[Sp + 4];
      goto cRr;
  cRr:
      if (Sp - 12 < SpLim) goto cRu; else goto cRv;
  cRu:
      R1 = _sIH::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  cRv:
      _sID::P32 = P32[_sIH::P32 + 2];
      _sIE::P32 = P32[_sIH::P32 + 6];
      _sIF::P32 = P32[_sIH::P32 + 10];
      P32[Sp - 12] = _sID::P32;
      P32[Sp - 8] = _sIE::P32;
      P32[Sp - 4] = _sIF::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cRt:
      goto cRr;
  cRr:
      _sIH::P32 = R1;
      if ((Sp + -12) < SpLim) goto cRu; else goto cRv;
  cRu:
      R1 = _sIH::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  cRv:
      P32[Sp - 12] = P32[_sIH::P32 + 2];
      P32[Sp - 8] = P32[_sIH::P32 + 6];
      P32[Sp - 4] = P32[_sIH::P32 + 10];
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cRr, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cRt, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure}), (cRu, {}),
 (cRv, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure})]



==================== after setInfoTableStackMap ====================
sat_sIH_entry() //  [R1]
        { info_tbl: [(cRt,
                      label: sat_sIH_info
                      rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
          stack_info: arg_space: 12 updfr_space: Just 4
        }
    {offset
      cRt:
          goto cRr;
      cRr:
          _sIH::P32 = R1;
          if ((Sp + -12) < SpLim) goto cRu; else goto cRv;
      cRu:
          R1 = _sIH::P32;
          call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
      cRv:
          P32[Sp - 12] = P32[_sIH::P32 + 2];
          P32[Sp - 8] = P32[_sIH::P32 + 6];
          P32[Sp - 4] = P32[_sIH::P32 + 10];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
sat_sIH_entry() //  [R1]
        { info_tbl: [(cRr,
                      label: sat_sIH_info
                      rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
          stack_info: arg_space: 12 updfr_space: Just 4
        }
    {offset
      cRr:
          _sIH::P32 = R1;
          if ((Sp + -12) < SpLim) goto cRu; else goto cRv;
      cRu:
          R1 = _sIH::P32;
          call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
      cRv:
          P32[Sp - 12] = P32[_sIH::P32 + 2];
          P32[Sp - 8] = P32[_sIH::P32 + 6];
          P32[Sp - 4] = P32[_sIH::P32 + 10];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cRA:
      _sIG::P32 = R1;
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRy;
  cRy:
      if (Sp - <highSp> < SpLim) goto cRB; else goto cRC;
  cRB:
      R1 = _sIG::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRC:
      _sID::P32 = P32[_sIG::P32 + 1];
      _sIE::P32 = P32[_sIG::P32 + 5];
      _sIF::P32 = P32[_sIG::P32 + 9];
      P32[(old + 28)] = _sID::P32;
      P32[(old + 24)] = _sIE::P32;
      P32[(old + 20)] = _sIF::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cRA:
      _sIG::P32 = R1;
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRy;
  cRy:
      if (Sp - <highSp> < SpLim) goto cRB; else goto cRC;
  cRB:
      R1 = _sIG::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRC:
      _sID::P32 = P32[_sIG::P32 + 1];
      _sIE::P32 = P32[_sIG::P32 + 5];
      _sIF::P32 = P32[_sIG::P32 + 9];
      P32[(old + 28)] = _sID::P32;
      P32[(old + 24)] = _sIE::P32;
      P32[(old + 20)] = _sIF::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cRA:
      _sIG::P32 = R1;
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRy;
  cRy:
      if (Sp - <highSp> < SpLim) goto cRB; else goto cRC;
  cRB:
      R1 = _sIG::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRC:
      _sID::P32 = P32[_sIG::P32 + 1];
      _sIE::P32 = P32[_sIG::P32 + 5];
      _sIF::P32 = P32[_sIG::P32 + 9];
      P32[(old + 28)] = _sID::P32;
      P32[(old + 24)] = _sIE::P32;
      P32[(old + 20)] = _sIF::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cRA:
      _sIG::P32 = R1;
      _B3::P32 = P32[Sp];
      _B2::P32 = P32[Sp + 4];
      _B1::P32 = P32[Sp + 8];
      goto cRy;
  cRy:
      if (Sp - 12 < SpLim) goto cRB; else goto cRC;
  cRB:
      R1 = _sIG::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRC:
      _sID::P32 = P32[_sIG::P32 + 1];
      _sIE::P32 = P32[_sIG::P32 + 5];
      _sIF::P32 = P32[_sIG::P32 + 9];
      P32[Sp - 12] = _sID::P32;
      P32[Sp - 8] = _sIE::P32;
      P32[Sp - 4] = _sIF::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cRA:
      goto cRy;
  cRy:
      _sIG::P32 = R1;
      if ((Sp + -12) < SpLim) goto cRB; else goto cRC;
  cRB:
      R1 = _sIG::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRC:
      P32[Sp - 12] = P32[_sIG::P32 + 1];
      P32[Sp - 8] = P32[_sIG::P32 + 5];
      P32[Sp - 4] = P32[_sIG::P32 + 9];
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cRy, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cRA, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cRB, {}),
 (cRC, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure})]



==================== after setInfoTableStackMap ====================
sat_sIG_entry() //  [R1]
        { info_tbl: [(cRA,
                      label: sat_sIG_info
                      rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      cRA:
          goto cRy;
      cRy:
          _sIG::P32 = R1;
          if ((Sp + -12) < SpLim) goto cRB; else goto cRC;
      cRB:
          R1 = _sIG::P32;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      cRC:
          P32[Sp - 12] = P32[_sIG::P32 + 1];
          P32[Sp - 8] = P32[_sIG::P32 + 5];
          P32[Sp - 4] = P32[_sIG::P32 + 9];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
sat_sIG_entry() //  [R1]
        { info_tbl: [(cRy,
                      label: sat_sIG_info
                      rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      cRy:
          _sIG::P32 = R1;
          if ((Sp + -12) < SpLim) goto cRB; else goto cRC;
      cRB:
          R1 = _sIG::P32;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      cRC:
          P32[Sp - 12] = P32[_sIG::P32 + 1];
          P32[Sp - 8] = P32[_sIG::P32 + 5];
          P32[Sp - 4] = P32[_sIG::P32 + 9];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cRE:
      _sID::P32 = P32[(old + 16)];
      _sIE::P32 = P32[(old + 12)];
      _sIF::P32 = P32[(old + 8)];
      goto cQV;
  cQV:
      if (Sp - <highSp> < SpLim) goto cRF; else goto cRG;
  cRG:
      Hp = Hp + 124;
      if (Hp > HpLim) goto cRI; else goto cRH;
  cRI:
      HpAlloc = 124;
      goto cRF;
  cRF:
      R1 = T2902_B_PairingSum.$fSumPSumab_closure;
      P32[(old + 16)] = _sID::P32;
      P32[(old + 12)] = _sIE::P32;
      P32[(old + 8)] = _sIF::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRH:
      I32[Hp - 120] = sat_sIL_info;
      P32[Hp - 116] = _sID::P32;
      P32[Hp - 112] = _sIE::P32;
      P32[Hp - 108] = _sIF::P32;
      _cQX::P32 = Hp - 119;
      I32[Hp - 104] = sat_sIK_info;
      P32[Hp - 100] = _sID::P32;
      P32[Hp - 96] = _sIE::P32;
      P32[Hp - 92] = _sIF::P32;
      _cR4::P32 = Hp - 103;
      I32[Hp - 88] = sat_sIJ_info;
      P32[Hp - 84] = _sID::P32;
      P32[Hp - 80] = _sIE::P32;
      P32[Hp - 76] = _sIF::P32;
      _cRb::P32 = Hp - 87;
      I32[Hp - 72] = sat_sII_info;
      P32[Hp - 68] = _sID::P32;
      P32[Hp - 64] = _sIE::P32;
      P32[Hp - 60] = _sIF::P32;
      _cRi::P32 = Hp - 71;
      I32[Hp - 56] = sat_sIH_info;
      P32[Hp - 52] = _sID::P32;
      P32[Hp - 48] = _sIE::P32;
      P32[Hp - 44] = _sIF::P32;
      _cRp::P32 = Hp - 54;
      I32[Hp - 40] = sat_sIG_info;
      P32[Hp - 36] = _sID::P32;
      P32[Hp - 32] = _sIE::P32;
      P32[Hp - 28] = _sIF::P32;
      _cRw::P32 = Hp - 37;
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _cRw::P32;
      P32[Hp - 16] = _cRp::P32;
      P32[Hp - 12] = _cRi::P32;
      P32[Hp - 8] = _cRb::P32;
      P32[Hp - 4] = _cR4::P32;
      P32[Hp] = _cQX::P32;
      _cRD::P32 = Hp - 23;
      R1 = _cRD::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cRE:
      _sID::P32 = P32[(old + 16)];
      _sIE::P32 = P32[(old + 12)];
      _sIF::P32 = P32[(old + 8)];
      goto cQV;
  cQV:
      if (Sp - <highSp> < SpLim) goto cRF; else goto cRG;
  cRG:
      Hp = Hp + 124;
      if (Hp > HpLim) goto cRI; else goto cRH;
  cRI:
      HpAlloc = 124;
      goto cRF;
  cRF:
      R1 = T2902_B_PairingSum.$fSumPSumab_closure;
      P32[(old + 16)] = _sID::P32;
      P32[(old + 12)] = _sIE::P32;
      P32[(old + 8)] = _sIF::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRH:
      I32[Hp - 120] = sat_sIL_info;
      P32[Hp - 116] = _sID::P32;
      P32[Hp - 112] = _sIE::P32;
      P32[Hp - 108] = _sIF::P32;
      _cQX::P32 = Hp - 119;
      I32[Hp - 104] = sat_sIK_info;
      P32[Hp - 100] = _sID::P32;
      P32[Hp - 96] = _sIE::P32;
      P32[Hp - 92] = _sIF::P32;
      _cR4::P32 = Hp - 103;
      I32[Hp - 88] = sat_sIJ_info;
      P32[Hp - 84] = _sID::P32;
      P32[Hp - 80] = _sIE::P32;
      P32[Hp - 76] = _sIF::P32;
      _cRb::P32 = Hp - 87;
      I32[Hp - 72] = sat_sII_info;
      P32[Hp - 68] = _sID::P32;
      P32[Hp - 64] = _sIE::P32;
      P32[Hp - 60] = _sIF::P32;
      _cRi::P32 = Hp - 71;
      I32[Hp - 56] = sat_sIH_info;
      P32[Hp - 52] = _sID::P32;
      P32[Hp - 48] = _sIE::P32;
      P32[Hp - 44] = _sIF::P32;
      _cRp::P32 = Hp - 54;
      I32[Hp - 40] = sat_sIG_info;
      P32[Hp - 36] = _sID::P32;
      P32[Hp - 32] = _sIE::P32;
      P32[Hp - 28] = _sIF::P32;
      _cRw::P32 = Hp - 37;
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _cRw::P32;
      P32[Hp - 16] = _cRp::P32;
      P32[Hp - 12] = _cRi::P32;
      P32[Hp - 8] = _cRb::P32;
      P32[Hp - 4] = _cR4::P32;
      P32[Hp] = _cQX::P32;
      _cRD::P32 = Hp - 23;
      R1 = _cRD::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cRE:
      _sID::P32 = P32[(old + 16)];
      _sIE::P32 = P32[(old + 12)];
      _sIF::P32 = P32[(old + 8)];
      goto cQV;
  cQV:
      if (Sp - <highSp> < SpLim) goto cRF; else goto cRG;
  cRG:
      Hp = Hp + 124;
      if (Hp > HpLim) goto cRI; else goto cRH;
  cRI:
      HpAlloc = 124;
      goto cRF;
  cRF:
      R1 = T2902_B_PairingSum.$fSumPSumab_closure;
      P32[(old + 16)] = _sID::P32;
      P32[(old + 12)] = _sIE::P32;
      P32[(old + 8)] = _sIF::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRH:
      I32[Hp - 120] = sat_sIL_info;
      P32[Hp - 116] = _sID::P32;
      P32[Hp - 112] = _sIE::P32;
      P32[Hp - 108] = _sIF::P32;
      _cQX::P32 = Hp - 119;
      I32[Hp - 104] = sat_sIK_info;
      P32[Hp - 100] = _sID::P32;
      P32[Hp - 96] = _sIE::P32;
      P32[Hp - 92] = _sIF::P32;
      _cR4::P32 = Hp - 103;
      I32[Hp - 88] = sat_sIJ_info;
      P32[Hp - 84] = _sID::P32;
      P32[Hp - 80] = _sIE::P32;
      P32[Hp - 76] = _sIF::P32;
      _cRb::P32 = Hp - 87;
      I32[Hp - 72] = sat_sII_info;
      P32[Hp - 68] = _sID::P32;
      P32[Hp - 64] = _sIE::P32;
      P32[Hp - 60] = _sIF::P32;
      _cRi::P32 = Hp - 71;
      I32[Hp - 56] = sat_sIH_info;
      P32[Hp - 52] = _sID::P32;
      P32[Hp - 48] = _sIE::P32;
      P32[Hp - 44] = _sIF::P32;
      _cRp::P32 = Hp - 54;
      I32[Hp - 40] = sat_sIG_info;
      P32[Hp - 36] = _sID::P32;
      P32[Hp - 32] = _sIE::P32;
      P32[Hp - 28] = _sIF::P32;
      _cRw::P32 = Hp - 37;
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _cRw::P32;
      P32[Hp - 16] = _cRp::P32;
      P32[Hp - 12] = _cRi::P32;
      P32[Hp - 8] = _cRb::P32;
      P32[Hp - 4] = _cR4::P32;
      P32[Hp] = _cQX::P32;
      _cRD::P32 = Hp - 23;
      R1 = _cRD::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cRE:
      _sID::P32 = P32[Sp];
      _sIE::P32 = P32[Sp + 4];
      _sIF::P32 = P32[Sp + 8];
      goto cQV;
  cQV:
      goto cRG;
  cRG:
      Hp = Hp + 124;
      if (Hp > HpLim) goto cRI; else goto cRH;
  cRI:
      HpAlloc = 124;
      goto cRF;
  cRF:
      R1 = T2902_B_PairingSum.$fSumPSumab_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRH:
      I32[Hp - 120] = sat_sIL_info;
      P32[Hp - 116] = _sID::P32;
      P32[Hp - 112] = _sIE::P32;
      P32[Hp - 108] = _sIF::P32;
      _cQX::P32 = Hp - 119;
      I32[Hp - 104] = sat_sIK_info;
      P32[Hp - 100] = _sID::P32;
      P32[Hp - 96] = _sIE::P32;
      P32[Hp - 92] = _sIF::P32;
      _cR4::P32 = Hp - 103;
      I32[Hp - 88] = sat_sIJ_info;
      P32[Hp - 84] = _sID::P32;
      P32[Hp - 80] = _sIE::P32;
      P32[Hp - 76] = _sIF::P32;
      _cRb::P32 = Hp - 87;
      I32[Hp - 72] = sat_sII_info;
      P32[Hp - 68] = _sID::P32;
      P32[Hp - 64] = _sIE::P32;
      P32[Hp - 60] = _sIF::P32;
      _cRi::P32 = Hp - 71;
      I32[Hp - 56] = sat_sIH_info;
      P32[Hp - 52] = _sID::P32;
      P32[Hp - 48] = _sIE::P32;
      P32[Hp - 44] = _sIF::P32;
      _cRp::P32 = Hp - 54;
      I32[Hp - 40] = sat_sIG_info;
      P32[Hp - 36] = _sID::P32;
      P32[Hp - 32] = _sIE::P32;
      P32[Hp - 28] = _sIF::P32;
      _cRw::P32 = Hp - 37;
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _cRw::P32;
      P32[Hp - 16] = _cRp::P32;
      P32[Hp - 12] = _cRi::P32;
      P32[Hp - 8] = _cRb::P32;
      P32[Hp - 4] = _cR4::P32;
      P32[Hp] = _cQX::P32;
      _cRD::P32 = Hp - 23;
      R1 = _cRD::P32;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cRE:
      goto cQV;
  cQV:
      goto cRG;
  cRG:
      Hp = Hp + 124;
      if (Hp > HpLim) goto cRI; else goto cRH;
  cRI:
      HpAlloc = 124;
      goto cRF;
  cRF:
      R1 = T2902_B_PairingSum.$fSumPSumab_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRH:
      I32[Hp - 120] = sat_sIL_info;
      _sID::P32 = P32[Sp];
      P32[Hp - 116] = _sID::P32;
      _sIE::P32 = P32[Sp + 4];
      P32[Hp - 112] = _sIE::P32;
      _sIF::P32 = P32[Sp + 8];
      P32[Hp - 108] = _sIF::P32;
      I32[Hp - 104] = sat_sIK_info;
      P32[Hp - 100] = _sID::P32;
      P32[Hp - 96] = _sIE::P32;
      P32[Hp - 92] = _sIF::P32;
      I32[Hp - 88] = sat_sIJ_info;
      P32[Hp - 84] = _sID::P32;
      P32[Hp - 80] = _sIE::P32;
      P32[Hp - 76] = _sIF::P32;
      I32[Hp - 72] = sat_sII_info;
      P32[Hp - 68] = _sID::P32;
      P32[Hp - 64] = _sIE::P32;
      P32[Hp - 60] = _sIF::P32;
      I32[Hp - 56] = sat_sIH_info;
      P32[Hp - 52] = _sID::P32;
      P32[Hp - 48] = _sIE::P32;
      P32[Hp - 44] = _sIF::P32;
      I32[Hp - 40] = sat_sIG_info;
      P32[Hp - 36] = _sID::P32;
      P32[Hp - 32] = _sIE::P32;
      P32[Hp - 28] = _sIF::P32;
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = Hp - 37;
      P32[Hp - 16] = Hp - 54;
      P32[Hp - 12] = Hp - 71;
      P32[Hp - 8] = Hp - 87;
      P32[Hp - 4] = Hp - 103;
      P32[Hp] = Hp - 119;
      R1 = Hp - 23;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cQV,
  {T2902_B_PairingSum.$fSumPSumab_closure, sat_sIG_closure,
   sat_sIH_closure, sat_sII_closure, sat_sIJ_closure, sat_sIK_closure,
   sat_sIL_closure}),
 (cRE,
  {T2902_B_PairingSum.$fSumPSumab_closure, sat_sIG_closure,
   sat_sIH_closure, sat_sII_closure, sat_sIJ_closure, sat_sIK_closure,
   sat_sIL_closure}),
 (cRF, {T2902_B_PairingSum.$fSumPSumab_closure}),
 (cRG,
  {T2902_B_PairingSum.$fSumPSumab_closure, sat_sIG_closure,
   sat_sIH_closure, sat_sII_closure, sat_sIJ_closure, sat_sIK_closure,
   sat_sIL_closure}),
 (cRH,
  {sat_sIG_closure, sat_sIH_closure, sat_sII_closure,
   sat_sIJ_closure, sat_sIK_closure, sat_sIL_closure}),
 (cRI, {T2902_B_PairingSum.$fSumPSumab_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_entry() //  []
        { info_tbl: [(cRE,
                      label: T2902_B_PairingSum.$fSumPSumab_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      cRE:
          goto cQV;
      cQV:
          goto cRG;
      cRG:
          Hp = Hp + 124;
          if (Hp > HpLim) goto cRI; else goto cRH;
      cRI:
          HpAlloc = 124;
          goto cRF;
      cRF:
          R1 = T2902_B_PairingSum.$fSumPSumab_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      cRH:
          I32[Hp - 120] = sat_sIL_info;
          _sID::P32 = P32[Sp];
          P32[Hp - 116] = _sID::P32;
          _sIE::P32 = P32[Sp + 4];
          P32[Hp - 112] = _sIE::P32;
          _sIF::P32 = P32[Sp + 8];
          P32[Hp - 108] = _sIF::P32;
          I32[Hp - 104] = sat_sIK_info;
          P32[Hp - 100] = _sID::P32;
          P32[Hp - 96] = _sIE::P32;
          P32[Hp - 92] = _sIF::P32;
          I32[Hp - 88] = sat_sIJ_info;
          P32[Hp - 84] = _sID::P32;
          P32[Hp - 80] = _sIE::P32;
          P32[Hp - 76] = _sIF::P32;
          I32[Hp - 72] = sat_sII_info;
          P32[Hp - 68] = _sID::P32;
          P32[Hp - 64] = _sIE::P32;
          P32[Hp - 60] = _sIF::P32;
          I32[Hp - 56] = sat_sIH_info;
          P32[Hp - 52] = _sID::P32;
          P32[Hp - 48] = _sIE::P32;
          P32[Hp - 44] = _sIF::P32;
          I32[Hp - 40] = sat_sIG_info;
          P32[Hp - 36] = _sID::P32;
          P32[Hp - 32] = _sIE::P32;
          P32[Hp - 28] = _sIF::P32;
          I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
          P32[Hp - 20] = Hp - 37;
          P32[Hp - 16] = Hp - 54;
          P32[Hp - 12] = Hp - 71;
          P32[Hp - 8] = Hp - 87;
          P32[Hp - 4] = Hp - 103;
          P32[Hp] = Hp - 119;
          R1 = Hp - 23;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_entry() //  []
        { info_tbl: [(cRG,
                      label: T2902_B_PairingSum.$fSumPSumab_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      cRG:
          Hp = Hp + 124;
          if (Hp > HpLim) goto cRI; else goto cRH;
      cRI:
          HpAlloc = 124;
          goto cRF;
      cRF:
          R1 = T2902_B_PairingSum.$fSumPSumab_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      cRH:
          I32[Hp - 120] = sat_sIL_info;
          _sID::P32 = P32[Sp];
          P32[Hp - 116] = _sID::P32;
          _sIE::P32 = P32[Sp + 4];
          P32[Hp - 112] = _sIE::P32;
          _sIF::P32 = P32[Sp + 8];
          P32[Hp - 108] = _sIF::P32;
          I32[Hp - 104] = sat_sIK_info;
          P32[Hp - 100] = _sID::P32;
          P32[Hp - 96] = _sIE::P32;
          P32[Hp - 92] = _sIF::P32;
          I32[Hp - 88] = sat_sIJ_info;
          P32[Hp - 84] = _sID::P32;
          P32[Hp - 80] = _sIE::P32;
          P32[Hp - 76] = _sIF::P32;
          I32[Hp - 72] = sat_sII_info;
          P32[Hp - 68] = _sID::P32;
          P32[Hp - 64] = _sIE::P32;
          P32[Hp - 60] = _sIF::P32;
          I32[Hp - 56] = sat_sIH_info;
          P32[Hp - 52] = _sID::P32;
          P32[Hp - 48] = _sIE::P32;
          P32[Hp - 44] = _sIF::P32;
          I32[Hp - 40] = sat_sIG_info;
          P32[Hp - 36] = _sID::P32;
          P32[Hp - 32] = _sIE::P32;
          P32[Hp - 28] = _sIF::P32;
          I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
          P32[Hp - 20] = Hp - 37;
          P32[Hp - 16] = Hp - 54;
          P32[Hp - 12] = Hp - 71;
          P32[Hp - 8] = Hp - 87;
          P32[Hp - 4] = Hp - 103;
          P32[Hp] = Hp - 119;
          R1 = Hp - 23;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_closure:
         const T2902_B_PairingSum.$fSumPSumab_info;
         const 0;
 },
 sat_sIL_entry() //  [R1]
         { info_tbl: [(cQZ,
                       label: sat_sIL_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cQZ:
           _sIL::P32 = R1;
           if ((Sp + -12) < SpLim) goto cR2; else goto cR3;
       cR2:
           R1 = _sIL::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cR3:
           P32[Sp - 12] = P32[_sIL::P32 + 3];
           P32[Sp - 8] = P32[_sIL::P32 + 7];
           P32[Sp - 4] = P32[_sIL::P32 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIK_entry() //  [R1]
         { info_tbl: [(cR6,
                       label: sat_sIK_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cR6:
           _sIK::P32 = R1;
           if ((Sp + -12) < SpLim) goto cR9; else goto cRa;
       cR9:
           R1 = _sIK::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRa:
           P32[Sp - 12] = P32[_sIK::P32 + 3];
           P32[Sp - 8] = P32[_sIK::P32 + 7];
           P32[Sp - 4] = P32[_sIK::P32 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIJ_entry() //  [R1]
         { info_tbl: [(cRd,
                       label: sat_sIJ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cRd:
           _sIJ::P32 = R1;
           if ((Sp + -12) < SpLim) goto cRg; else goto cRh;
       cRg:
           R1 = _sIJ::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRh:
           P32[Sp - 12] = P32[_sIJ::P32 + 3];
           P32[Sp - 8] = P32[_sIJ::P32 + 7];
           P32[Sp - 4] = P32[_sIJ::P32 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sII_entry() //  [R1]
         { info_tbl: [(cRk,
                       label: sat_sII_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cRk:
           _sII::P32 = R1;
           if ((Sp + -12) < SpLim) goto cRn; else goto cRo;
       cRn:
           R1 = _sII::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRo:
           P32[Sp - 12] = P32[_sII::P32 + 3];
           P32[Sp - 8] = P32[_sII::P32 + 7];
           P32[Sp - 4] = P32[_sII::P32 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIH_entry() //  [R1]
         { info_tbl: [(cRr,
                       label: sat_sIH_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 12 updfr_space: Just 4
         }
     {offset
       cRr:
           _sIH::P32 = R1;
           if ((Sp + -12) < SpLim) goto cRu; else goto cRv;
       cRu:
           R1 = _sIH::P32;
           call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
       cRv:
           P32[Sp - 12] = P32[_sIH::P32 + 2];
           P32[Sp - 8] = P32[_sIH::P32 + 6];
           P32[Sp - 4] = P32[_sIH::P32 + 10];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
     }
 },
 sat_sIG_entry() //  [R1]
         { info_tbl: [(cRy,
                       label: sat_sIG_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cRy:
           _sIG::P32 = R1;
           if ((Sp + -12) < SpLim) goto cRB; else goto cRC;
       cRB:
           R1 = _sIG::P32;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cRC:
           P32[Sp - 12] = P32[_sIG::P32 + 1];
           P32[Sp - 8] = P32[_sIG::P32 + 5];
           P32[Sp - 4] = P32[_sIG::P32 + 9];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_entry() //  []
         { info_tbl: [(cRG,
                       label: T2902_B_PairingSum.$fSumPSumab_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cRG:
           Hp = Hp + 124;
           if (Hp > HpLim) goto cRI; else goto cRH;
       cRI:
           HpAlloc = 124;
           goto cRF;
       cRF:
           R1 = T2902_B_PairingSum.$fSumPSumab_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cRH:
           I32[Hp - 120] = sat_sIL_info;
           _sID::P32 = P32[Sp];
           P32[Hp - 116] = _sID::P32;
           _sIE::P32 = P32[Sp + 4];
           P32[Hp - 112] = _sIE::P32;
           _sIF::P32 = P32[Sp + 8];
           P32[Hp - 108] = _sIF::P32;
           I32[Hp - 104] = sat_sIK_info;
           P32[Hp - 100] = _sID::P32;
           P32[Hp - 96] = _sIE::P32;
           P32[Hp - 92] = _sIF::P32;
           I32[Hp - 88] = sat_sIJ_info;
           P32[Hp - 84] = _sID::P32;
           P32[Hp - 80] = _sIE::P32;
           P32[Hp - 76] = _sIF::P32;
           I32[Hp - 72] = sat_sII_info;
           P32[Hp - 68] = _sID::P32;
           P32[Hp - 64] = _sIE::P32;
           P32[Hp - 60] = _sIF::P32;
           I32[Hp - 56] = sat_sIH_info;
           P32[Hp - 52] = _sID::P32;
           P32[Hp - 48] = _sIE::P32;
           P32[Hp - 44] = _sIF::P32;
           I32[Hp - 40] = sat_sIG_info;
           P32[Hp - 36] = _sID::P32;
           P32[Hp - 32] = _sIE::P32;
           P32[Hp - 28] = _sIF::P32;
           I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
           P32[Hp - 20] = Hp - 37;
           P32[Hp - 16] = Hp - 54;
           P32[Hp - 12] = Hp - 71;
           P32[Hp - 8] = Hp - 87;
           P32[Hp - 4] = Hp - 103;
           P32[Hp] = Hp - 119;
           R1 = Hp - 23;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_closure:
         const T2902_B_PairingSum.$fSumPSumab_info;
         const 0;
 },
 sat_sIL_entry() //  [R1]
         { info_tbl: [(cQZ,
                       label: sat_sIL_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cQZ:
           _sIL::P32 = R1;
           if ((Sp + -12) < SpLim) goto cR2; else goto cR3;
       cR2:
           R1 = _sIL::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cR3:
           P32[Sp - 12] = P32[_sIL::P32 + 3];
           P32[Sp - 8] = P32[_sIL::P32 + 7];
           P32[Sp - 4] = P32[_sIL::P32 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIK_entry() //  [R1]
         { info_tbl: [(cR6,
                       label: sat_sIK_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cR6:
           _sIK::P32 = R1;
           if ((Sp + -12) < SpLim) goto cR9; else goto cRa;
       cR9:
           R1 = _sIK::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRa:
           P32[Sp - 12] = P32[_sIK::P32 + 3];
           P32[Sp - 8] = P32[_sIK::P32 + 7];
           P32[Sp - 4] = P32[_sIK::P32 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIJ_entry() //  [R1]
         { info_tbl: [(cRd,
                       label: sat_sIJ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cRd:
           _sIJ::P32 = R1;
           if ((Sp + -12) < SpLim) goto cRg; else goto cRh;
       cRg:
           R1 = _sIJ::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRh:
           P32[Sp - 12] = P32[_sIJ::P32 + 3];
           P32[Sp - 8] = P32[_sIJ::P32 + 7];
           P32[Sp - 4] = P32[_sIJ::P32 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sII_entry() //  [R1]
         { info_tbl: [(cRk,
                       label: sat_sII_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cRk:
           _sII::P32 = R1;
           if ((Sp + -12) < SpLim) goto cRn; else goto cRo;
       cRn:
           R1 = _sII::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRo:
           P32[Sp - 12] = P32[_sII::P32 + 3];
           P32[Sp - 8] = P32[_sII::P32 + 7];
           P32[Sp - 4] = P32[_sII::P32 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIH_entry() //  [R1]
         { info_tbl: [(cRr,
                       label: sat_sIH_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 12 updfr_space: Just 4
         }
     {offset
       cRr:
           _sIH::P32 = R1;
           if ((Sp + -12) < SpLim) goto cRu; else goto cRv;
       cRu:
           R1 = _sIH::P32;
           call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
       cRv:
           P32[Sp - 12] = P32[_sIH::P32 + 2];
           P32[Sp - 8] = P32[_sIH::P32 + 6];
           P32[Sp - 4] = P32[_sIH::P32 + 10];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
     }
 },
 sat_sIG_entry() //  [R1]
         { info_tbl: [(cRy,
                       label: sat_sIG_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cRy:
           _sIG::P32 = R1;
           if ((Sp + -12) < SpLim) goto cRB; else goto cRC;
       cRB:
           R1 = _sIG::P32;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cRC:
           P32[Sp - 12] = P32[_sIG::P32 + 1];
           P32[Sp - 8] = P32[_sIG::P32 + 5];
           P32[Sp - 4] = P32[_sIG::P32 + 9];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_entry() //  []
         { info_tbl: [(cRG,
                       label: T2902_B_PairingSum.$fSumPSumab_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cRG:
           Hp = Hp + 124;
           if (Hp > HpLim) goto cRI; else goto cRH;
       cRI:
           HpAlloc = 124;
           goto cRF;
       cRF:
           R1 = T2902_B_PairingSum.$fSumPSumab_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cRH:
           I32[Hp - 120] = sat_sIL_info;
           _sID::P32 = P32[Sp];
           P32[Hp - 116] = _sID::P32;
           _sIE::P32 = P32[Sp + 4];
           P32[Hp - 112] = _sIE::P32;
           _sIF::P32 = P32[Sp + 8];
           P32[Hp - 108] = _sIF::P32;
           I32[Hp - 104] = sat_sIK_info;
           P32[Hp - 100] = _sID::P32;
           P32[Hp - 96] = _sIE::P32;
           P32[Hp - 92] = _sIF::P32;
           I32[Hp - 88] = sat_sIJ_info;
           P32[Hp - 84] = _sID::P32;
           P32[Hp - 80] = _sIE::P32;
           P32[Hp - 76] = _sIF::P32;
           I32[Hp - 72] = sat_sII_info;
           P32[Hp - 68] = _sID::P32;
           P32[Hp - 64] = _sIE::P32;
           P32[Hp - 60] = _sIF::P32;
           I32[Hp - 56] = sat_sIH_info;
           P32[Hp - 52] = _sID::P32;
           P32[Hp - 48] = _sIE::P32;
           P32[Hp - 44] = _sIF::P32;
           I32[Hp - 40] = sat_sIG_info;
           P32[Hp - 36] = _sID::P32;
           P32[Hp - 32] = _sIE::P32;
           P32[Hp - 28] = _sIF::P32;
           I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
           P32[Hp - 20] = Hp - 37;
           P32[Hp - 16] = Hp - 54;
           P32[Hp - 12] = Hp - 71;
           P32[Hp - 8] = Hp - 87;
           P32[Hp - 4] = Hp - 103;
           P32[Hp] = Hp - 119;
           R1 = Hp - 23;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.Empty_closure:
         const T2902_B_PairingSum.Empty_static_info;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.Empty_closure:
         const T2902_B_PairingSum.Empty_static_info;
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.Empty_closure:
         const T2902_B_PairingSum.Empty_static_info;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.Tree_closure:
         const T2902_B_PairingSum.Tree_info;
 },
 T2902_B_PairingSum.Tree_entry() //  []
         { info_tbl: [(cSB,
                       label: T2902_B_PairingSum.Tree_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cSB:
           _B3::P32 = P32[(old + 16)];
           _B2::P32 = P32[(old + 12)];
           _B1::P32 = P32[(old + 8)];
           goto cSy;
       cSy:
           if (Sp - <highSp> < SpLim) goto cSC; else goto cSD;
       cSD:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cSF; else goto cSE;
       cSF:
           HpAlloc = 16;
           goto cSC;
       cSC:
           R1 = T2902_B_PairingSum.Tree_closure;
           P32[(old + 16)] = _B3::P32;
           P32[(old + 12)] = _B2::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cSE:
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = _B3::P32;
           P32[Hp - 4] = _B2::P32;
           P32[Hp] = _B1::P32;
           _cSA::P32 = Hp - 10;
           R1 = _cSA::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cSB:
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cSy;
  cSy:
      if (Sp - <highSp> < SpLim) goto cSC; else goto cSD;
  cSD:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cSF; else goto cSE;
  cSF:
      HpAlloc = 16;
      goto cSC;
  cSC:
      R1 = T2902_B_PairingSum.Tree_closure;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cSE:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _cSA::P32 = Hp - 10;
      R1 = _cSA::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cSB:
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cSy;
  cSy:
      if (Sp - <highSp> < SpLim) goto cSC; else goto cSD;
  cSD:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cSF; else goto cSE;
  cSF:
      HpAlloc = 16;
      goto cSC;
  cSC:
      R1 = T2902_B_PairingSum.Tree_closure;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cSE:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _cSA::P32 = Hp - 10;
      R1 = _cSA::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cSB:
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cSy;
  cSy:
      if (Sp - <highSp> < SpLim) goto cSC; else goto cSD;
  cSD:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cSF; else goto cSE;
  cSF:
      HpAlloc = 16;
      goto cSC;
  cSC:
      R1 = T2902_B_PairingSum.Tree_closure;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cSE:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _cSA::P32 = Hp - 10;
      R1 = _cSA::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cSB:
      _B3::P32 = P32[Sp];
      _B2::P32 = P32[Sp + 4];
      _B1::P32 = P32[Sp + 8];
      goto cSy;
  cSy:
      goto cSD;
  cSD:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cSF; else goto cSE;
  cSF:
      HpAlloc = 16;
      goto cSC;
  cSC:
      R1 = T2902_B_PairingSum.Tree_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cSE:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _cSA::P32 = Hp - 10;
      R1 = _cSA::P32;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cSB:
      goto cSy;
  cSy:
      goto cSD;
  cSD:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cSF; else goto cSE;
  cSF:
      HpAlloc = 16;
      goto cSC;
  cSC:
      R1 = T2902_B_PairingSum.Tree_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cSE:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = P32[Sp];
      P32[Hp - 4] = P32[Sp + 4];
      P32[Hp] = P32[Sp + 8];
      R1 = Hp - 10;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cSy, {}), (cSB, {}), (cSC, {}), (cSD, {}), (cSE, {}), (cSF, {})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.Tree_entry() //  []
        { info_tbl: [(cSB,
                      label: T2902_B_PairingSum.Tree_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      cSB:
          goto cSy;
      cSy:
          goto cSD;
      cSD:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cSF; else goto cSE;
      cSF:
          HpAlloc = 16;
          goto cSC;
      cSC:
          R1 = T2902_B_PairingSum.Tree_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      cSE:
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp];
          P32[Hp - 4] = P32[Sp + 4];
          P32[Hp] = P32[Sp + 8];
          R1 = Hp - 10;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.Tree_entry() //  []
        { info_tbl: [(cSD,
                      label: T2902_B_PairingSum.Tree_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      cSD:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cSF; else goto cSE;
      cSF:
          HpAlloc = 16;
          goto cSC;
      cSC:
          R1 = T2902_B_PairingSum.Tree_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      cSE:
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp];
          P32[Hp - 4] = P32[Sp + 4];
          P32[Hp] = P32[Sp + 8];
          R1 = Hp - 10;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.Tree_closure:
         const T2902_B_PairingSum.Tree_info;
 },
 T2902_B_PairingSum.Tree_entry() //  []
         { info_tbl: [(cSD,
                       label: T2902_B_PairingSum.Tree_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cSD:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cSF; else goto cSE;
       cSF:
           HpAlloc = 16;
           goto cSC;
       cSC:
           R1 = T2902_B_PairingSum.Tree_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cSE:
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp];
           P32[Hp - 4] = P32[Sp + 4];
           P32[Hp] = P32[Sp + 8];
           R1 = Hp - 10;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.Tree_closure:
         const T2902_B_PairingSum.Tree_info;
 },
 T2902_B_PairingSum.Tree_entry() //  []
         { info_tbl: [(cSD,
                       label: T2902_B_PairingSum.Tree_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cSD:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cSF; else goto cSE;
       cSF:
           HpAlloc = 16;
           goto cSC;
       cSC:
           R1 = T2902_B_PairingSum.Tree_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cSE:
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp];
           P32[Hp - 4] = P32[Sp + 4];
           P32[Hp] = P32[Sp + 8];
           R1 = Hp - 10;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[T2902_B_PairingSum.Empty_static_entry() //  []
         { info_tbl: [(cSN,
                       label: T2902_B_PairingSum.Empty_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,69,109,112,116,121]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSN:
           R1 = R1 + 1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cSN:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cSN:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cSN:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cSN:
      R1 = R1 + 1;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cSN:
      R1 = R1 + 1;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cSN, {})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.Empty_static_entry() //  []
        { info_tbl: [(cSN,
                      label: T2902_B_PairingSum.Empty_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,69,109,112,116,121]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cSN:
          R1 = R1 + 1;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.Empty_static_entry() //  []
        { info_tbl: [(cSN,
                      label: T2902_B_PairingSum.Empty_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,69,109,112,116,121]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cSN:
          R1 = R1 + 1;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[T2902_B_PairingSum.Empty_static_entry() //  []
         { info_tbl: [(cSN,
                       label: T2902_B_PairingSum.Empty_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,69,109,112,116,121]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSN:
           R1 = R1 + 1;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[T2902_B_PairingSum.Empty_static_entry() //  []
         { info_tbl: [(cSN,
                       label: T2902_B_PairingSum.Empty_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,69,109,112,116,121]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSN:
           R1 = R1 + 1;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[T2902_B_PairingSum.Tree_con_entry() //  []
         { info_tbl: [(cSS,
                       label: T2902_B_PairingSum.Tree_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSS:
           R1 = R1 + 2;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 },
 T2902_B_PairingSum.Tree_static_entry() //  []
         { info_tbl: [(cST,
                       label: T2902_B_PairingSum.Tree_static_info
                       rep:HeapRep static {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cST:
           R1 = R1 + 2;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cSS:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cSS:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cSS:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cSS:
      R1 = R1 + 2;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cSS:
      R1 = R1 + 2;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cSS, {})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.Tree_con_entry() //  []
        { info_tbl: [(cSS,
                      label: T2902_B_PairingSum.Tree_con_info
                      rep:HeapRep 3 ptrs {
                            Con {tag: 1
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cSS:
          R1 = R1 + 2;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.Tree_con_entry() //  []
        { info_tbl: [(cSS,
                      label: T2902_B_PairingSum.Tree_con_info
                      rep:HeapRep 3 ptrs {
                            Con {tag: 1
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cSS:
          R1 = R1 + 2;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cST:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cST:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cST:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cST:
      R1 = R1 + 2;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cST:
      R1 = R1 + 2;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cST, {})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.Tree_static_entry() //  []
        { info_tbl: [(cST,
                      label: T2902_B_PairingSum.Tree_static_info
                      rep:HeapRep static {
                            Con {tag: 1
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cST:
          R1 = R1 + 2;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.Tree_static_entry() //  []
        { info_tbl: [(cST,
                      label: T2902_B_PairingSum.Tree_static_info
                      rep:HeapRep static {
                            Con {tag: 1
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cST:
          R1 = R1 + 2;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[T2902_B_PairingSum.Tree_con_entry() //  []
         { info_tbl: [(cSS,
                       label: T2902_B_PairingSum.Tree_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSS:
           R1 = R1 + 2;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 },
 T2902_B_PairingSum.Tree_static_entry() //  []
         { info_tbl: [(cST,
                       label: T2902_B_PairingSum.Tree_static_info
                       rep:HeapRep static {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cST:
           R1 = R1 + 2;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[T2902_B_PairingSum.Tree_con_entry() //  []
         { info_tbl: [(cSS,
                       label: T2902_B_PairingSum.Tree_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSS:
           R1 = R1 + 2;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 },
 T2902_B_PairingSum.Tree_static_entry() //  []
         { info_tbl: [(cST,
                       label: T2902_B_PairingSum.Tree_static_info
                       rep:HeapRep static {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cST:
           R1 = R1 + 2;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "relreadonly" {
     SMp_srt:
         const T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
         const T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
         const lvl_rHo_closure;
         const T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
         const GHC.Err.undefined_closure;
         const T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
         const T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
         const T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
         const T2902_B_PairingSum.$fSumPSumab_closure;
 }]


[3 of 3] Compiling Main             ( T2902_B.hs, T2902_B.o )

==================== Cmm produced by new codegen ====================
[section "data" { __stginit_main:Main:
 }]



==================== Post CPS Cmm ====================
[section "data" { __stginit_main:Main:
 }]



==================== Output Cmm ====================
[section "data" { __stginit_main:Main:
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     x_r23P_closure:
         const GHC.Types.I#_static_info;
         const 1;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     x_r23P_closure:
         const GHC.Types.I#_static_info;
         const 1;
 }]



==================== Output Cmm ====================
[section "data" {
     x_r23P_closure:
         const GHC.Types.I#_static_info;
         const 1;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     xs_r23Q_closure:
         const :_static_info;
         const x_r23P_closure+1;
         const xs_r23Q_closure+2;
         const 1;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     xs_r23Q_closure:
         const :_static_info;
         const x_r23P_closure+1;
         const xs_r23Q_closure+2;
         const 1;
 }]



==================== Output Cmm ====================
[section "data" {
     xs_r23Q_closure:
         const :_static_info;
         const x_r23P_closure+1;
         const xs_r23Q_closure+2;
         const 1;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     x1_r23R_closure:
         const GHC.Types.I#_static_info;
         const 2;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     x1_r23R_closure:
         const GHC.Types.I#_static_info;
         const 2;
 }]



==================== Output Cmm ====================
[section "data" {
     x1_r23R_closure:
         const GHC.Types.I#_static_info;
         const 2;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     xs1_r23S_closure:
         const :_static_info;
         const x1_r23R_closure+1;
         const xs1_r23S_closure+2;
         const 1;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     xs1_r23S_closure:
         const :_static_info;
         const x1_r23R_closure+1;
         const xs1_r23S_closure+2;
         const 1;
 }]



==================== Output Cmm ====================
[section "data" {
     xs1_r23S_closure:
         const :_static_info;
         const x1_r23R_closure+1;
         const xs1_r23S_closure+2;
         const 1;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     x2_r23T_closure:
         const GHC.Types.I#_static_info;
         const 3;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     x2_r23T_closure:
         const GHC.Types.I#_static_info;
         const 3;
 }]



==================== Output Cmm ====================
[section "data" {
     x2_r23T_closure:
         const GHC.Types.I#_static_info;
         const 3;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     xs2_r23U_closure:
         const :_static_info;
         const x2_r23T_closure+1;
         const xs2_r23U_closure+2;
         const 1;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     xs2_r23U_closure:
         const :_static_info;
         const x2_r23T_closure+1;
         const xs2_r23U_closure+2;
         const 1;
 }]



==================== Output Cmm ====================
[section "data" {
     xs2_r23U_closure:
         const :_static_info;
         const x2_r23T_closure+1;
         const xs2_r23U_closure+2;
         const 1;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     lvl_r23V_closure:
         const lvl_r23V_info;
 },
 lvl_r23V_entry() //  []
         { info_tbl: [(c25p,
                       label: lvl_r23V_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       c25p:
           _s243::P32 = P32[(old + 16)];
           _s244::P32 = P32[(old + 12)];
           _s245::P32 = P32[(old + 8)];
           goto c25d;
       c25d:
           if (Sp - <highSp> < SpLim) goto c25q; else goto c25r;
       c25q:
           R1 = lvl_r23V_closure;
           P32[(old + 16)] = _s243::P32;
           P32[(old + 12)] = _s244::P32;
           P32[(old + 8)] = _s245::P32;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       c25r:
           I32[(young<c25f> + 4)] = c25f;
           R1 = _s245::P32;
           if (R1 & 3 != 0) goto c25f; else goto c25g;
       c25g:
           call (I32[R1])(R1) returns to c25f, args: 4, res: 4, upd: 4;
       c25f:
           _s246::P32 = R1;
           _c25l::P32 = _s246::P32 & 3;
           if (_c25l::P32 >= 2) goto c25n; else goto c25o;
       c25n:
           goto c25k;
       c25k:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c25C; else goto c25B;
       c25C:
           HpAlloc = 40;
           goto c25A;
       c25A:
           R1 = _s246::P32;
           call stg_gc_unpt_r1(R1) returns to c25f, args: 4, res: 4, upd: 4;
       c25B:
           _s247::P32 = P32[_s246::P32 + 2];
           _s248::P32 = P32[_s246::P32 + 6];
           I32[Hp - 36] = stg_ap_2_upd_info;
           P32[Hp - 28] = _s244::P32;
           P32[Hp - 24] = _s248::P32;
           _c25x::P32 = Hp - 36;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _s243::P32;
           P32[Hp - 12] = _s247::P32;
           _c25y::P32 = Hp - 19;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = _c25y::P32;
           P32[Hp] = _c25x::P32;
           _c25z::P32 = Hp - 6;
           R1 = _c25z::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
       c25o:
           goto c25j;
       c25j:
           R1 = []_closure+1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c25p:
      _s243::P32 = P32[(old + 16)];
      _s244::P32 = P32[(old + 12)];
      _s245::P32 = P32[(old + 8)];
      goto c25d;
  c25d:
      if (Sp - <highSp> < SpLim) goto c25q; else goto c25r;
  c25q:
      R1 = lvl_r23V_closure;
      P32[(old + 16)] = _s243::P32;
      P32[(old + 12)] = _s244::P32;
      P32[(old + 8)] = _s245::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c25r:
      I32[(young<c25f> + 4)] = c25f;
      R1 = _s245::P32;
      if (R1 & 3 != 0) goto c25f; else goto c25g;
  c25g:
      call (I32[R1])(R1) returns to c25f, args: 4, res: 4, upd: 4;
  c25f:
      _s246::P32 = R1;
      _c25l::P32 = _s246::P32 & 3;
      if (_c25l::P32 >= 2) goto c25k; else goto c25j;
  c25k:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c25C; else goto c25B;
  c25C:
      HpAlloc = 40;
      goto c25A;
  c25A:
      R1 = _s246::P32;
      call stg_gc_unpt_r1(R1) returns to c25f, args: 4, res: 4, upd: 4;
  c25B:
      _s247::P32 = P32[_s246::P32 + 2];
      _s248::P32 = P32[_s246::P32 + 6];
      I32[Hp - 36] = stg_ap_2_upd_info;
      P32[Hp - 28] = _s244::P32;
      P32[Hp - 24] = _s248::P32;
      _c25x::P32 = Hp - 36;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _s243::P32;
      P32[Hp - 12] = _s247::P32;
      _c25y::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c25y::P32;
      P32[Hp] = _c25x::P32;
      _c25z::P32 = Hp - 6;
      R1 = _c25z::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c25j:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c25p:
      _s243::P32 = P32[(old + 16)];
      _s244::P32 = P32[(old + 12)];
      _s245::P32 = P32[(old + 8)];
      goto c25d;
  c25d:
      if (Sp - <highSp> < SpLim) goto c25q; else goto c25r;
  c25q:
      R1 = lvl_r23V_closure;
      P32[(old + 16)] = _s243::P32;
      P32[(old + 12)] = _s244::P32;
      P32[(old + 8)] = _s245::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c25r:
      I32[(young<c25f> + 4)] = c25f;
      R1 = _s245::P32;
      if (R1 & 3 != 0) goto c25f; else goto c25g;
  c25g:
      call (I32[R1])(R1) returns to c25f, args: 4, res: 4, upd: 4;
  c25f:
      _s246::P32 = R1;
      _c25l::P32 = _s246::P32 & 3;
      if (_c25l::P32 >= 2) goto c25k; else goto c25j;
  c25k:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c25C; else goto c25B;
  c25C:
      HpAlloc = 40;
      goto c25A;
  c25A:
      R1 = _s246::P32;
      call stg_gc_unpt_r1(R1) returns to c25f, args: 4, res: 4, upd: 4;
  c25B:
      _s247::P32 = P32[_s246::P32 + 2];
      _s248::P32 = P32[_s246::P32 + 6];
      I32[Hp - 36] = stg_ap_2_upd_info;
      P32[Hp - 28] = _s244::P32;
      P32[Hp - 24] = _s248::P32;
      _c25x::P32 = Hp - 36;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _s243::P32;
      P32[Hp - 12] = _s247::P32;
      _c25y::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c25y::P32;
      P32[Hp] = _c25x::P32;
      _c25z::P32 = Hp - 6;
      R1 = _c25z::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c25j:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c25p:
      _s243::P32 = P32[(old + 16)];
      _s244::P32 = P32[(old + 12)];
      _s245::P32 = P32[(old + 8)];
      goto c25d;
  c25d:
      if (Sp - <highSp> < SpLim) goto c25q; else goto c25r;
  c25q:
      R1 = lvl_r23V_closure;
      P32[(old + 16)] = _s243::P32;
      P32[(old + 12)] = _s244::P32;
      P32[(old + 8)] = _s245::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c25r:
      I32[(young<c25f> + 4)] = c25f;
      R1 = _s245::P32;
      if (R1 & 3 != 0) goto c25f; else goto c25g;
  c25g:
      call (I32[R1])(R1) returns to c25f, args: 4, res: 4, upd: 4;
  c25f:
      _s246::P32 = R1;
      _c25l::P32 = _s246::P32 & 3;
      if (_c25l::P32 >= 2) goto c25k; else goto c25j;
  c25k:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c25C; else goto c25B;
  c25C:
      HpAlloc = 40;
      goto c25A;
  c25A:
      R1 = _s246::P32;
      call stg_gc_unpt_r1(R1) returns to c25f, args: 4, res: 4, upd: 4;
  c25B:
      _s247::P32 = P32[_s246::P32 + 2];
      _s248::P32 = P32[_s246::P32 + 6];
      I32[Hp - 36] = stg_ap_2_upd_info;
      P32[Hp - 28] = _s244::P32;
      P32[Hp - 24] = _s248::P32;
      _c25x::P32 = Hp - 36;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _s243::P32;
      P32[Hp - 12] = _s247::P32;
      _c25y::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c25y::P32;
      P32[Hp] = _c25x::P32;
      _c25z::P32 = Hp - 6;
      R1 = _c25z::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c25j:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c25p:
      _s243::P32 = P32[Sp];
      _s244::P32 = P32[Sp + 4];
      _s245::P32 = P32[Sp + 8];
      goto c25d;
  c25d:
      if (Sp - 4 < SpLim) goto c25q; else goto c25r;
  c25q:
      R1 = lvl_r23V_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c25r:
      I32[Sp - 4] = c25f;
      R1 = _s245::P32;
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto c25f; else goto c25g;
  c25g:
      call (I32[R1])(R1) returns to c25f, args: 4, res: 4, upd: 4;
  c25f:
      _s243::P32 = P32[Sp + 4];
      _s244::P32 = P32[Sp + 8];
      _s246::P32 = R1;
      _c25l::P32 = _s246::P32 & 3;
      if (_c25l::P32 >= 2) goto c25k; else goto c25j;
  c25k:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c25C; else goto c25B;
  c25C:
      HpAlloc = 40;
      goto c25A;
  c25A:
      R1 = _s246::P32;
      call stg_gc_unpt_r1(R1) returns to c25f, args: 4, res: 4, upd: 4;
  c25B:
      _s247::P32 = P32[_s246::P32 + 2];
      _s248::P32 = P32[_s246::P32 + 6];
      I32[Hp - 36] = stg_ap_2_upd_info;
      P32[Hp - 28] = _s244::P32;
      P32[Hp - 24] = _s248::P32;
      _c25x::P32 = Hp - 36;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _s243::P32;
      P32[Hp - 12] = _s247::P32;
      _c25y::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c25y::P32;
      P32[Hp] = _c25x::P32;
      _c25z::P32 = Hp - 6;
      R1 = _c25z::P32;
      Sp = Sp + 16;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  c25j:
      R1 = []_closure+1;
      Sp = Sp + 16;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c25p:
      goto c25d;
  c25d:
      if ((Sp + -4) < SpLim) goto c25q; else goto c25r;
  c25q:
      R1 = lvl_r23V_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c25r:
      I32[Sp - 4] = c25f;
      R1 = P32[Sp + 8];
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto c25f; else goto c25g;
  c25g:
      call (I32[R1])(R1) returns to c25f, args: 4, res: 4, upd: 4;
  c25f:
      _s246::P32 = R1;
      if (_s246::P32 & 3 >= 2) goto c25k; else goto c25j;
  c25k:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c25C; else goto c25B;
  c25C:
      HpAlloc = 40;
      goto c25A;
  c25A:
      R1 = _s246::P32;
      call stg_gc_unpt_r1(R1) returns to c25f, args: 4, res: 4, upd: 4;
  c25B:
      _s247::P32 = P32[_s246::P32 + 2];
      _s248::P32 = P32[_s246::P32 + 6];
      I32[Hp - 36] = stg_ap_2_upd_info;
      P32[Hp - 28] = P32[Sp + 8];
      P32[Hp - 24] = _s248::P32;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = P32[Sp + 4];
      P32[Hp - 12] = _s247::P32;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = Hp - 19;
      P32[Hp] = Hp - 36;
      R1 = Hp - 6;
      Sp = Sp + 16;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  c25j:
      R1 = []_closure+1;
      Sp = Sp + 16;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c25d, {}), (c25f, {}), (c25g, {}), (c25j, {}), (c25k, {}),
 (c25p, {}), (c25q, {}), (c25r, {}), (c25A, {}), (c25B, {}),
 (c25C, {})]



==================== after setInfoTableStackMap ====================
lvl_r23V_entry() //  []
        { info_tbl: [(c25f,
                      label: block_c25f_info
                      rep:StackRep [False, False, True]),
                     (c25p,
                      label: lvl_r23V_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      c25p:
          goto c25d;
      c25d:
          if ((Sp + -4) < SpLim) goto c25q; else goto c25r;
      c25q:
          R1 = lvl_r23V_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      c25r:
          I32[Sp - 4] = c25f;
          R1 = P32[Sp + 8];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto c25f; else goto c25g;
      c25g:
          call (I32[R1])(R1) returns to c25f, args: 4, res: 4, upd: 4;
      c25f:
          _s246::P32 = R1;
          if (_s246::P32 & 3 >= 2) goto c25k; else goto c25j;
      c25k:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c25C; else goto c25B;
      c25C:
          HpAlloc = 40;
          goto c25A;
      c25A:
          R1 = _s246::P32;
          call stg_gc_unpt_r1(R1) returns to c25f, args: 4, res: 4, upd: 4;
      c25B:
          _s247::P32 = P32[_s246::P32 + 2];
          _s248::P32 = P32[_s246::P32 + 6];
          I32[Hp - 36] = stg_ap_2_upd_info;
          P32[Hp - 28] = P32[Sp + 8];
          P32[Hp - 24] = _s248::P32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = P32[Sp + 4];
          P32[Hp - 12] = _s247::P32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 36;
          R1 = Hp - 6;
          Sp = Sp + 16;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      c25j:
          R1 = []_closure+1;
          Sp = Sp + 16;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
lvl_r23V_entry() //  []
        { info_tbl: [(c25d,
                      label: lvl_r23V_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} }),
                     (c25f,
                      label: block_c25f_info
                      rep:StackRep [False, False, True])]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      c25d:
          if ((Sp + -4) < SpLim) goto c25q; else goto c25r;
      c25q:
          R1 = lvl_r23V_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      c25r:
          I32[Sp - 4] = c25f;
          R1 = P32[Sp + 8];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto c25f; else goto c25g;
      c25g:
          call (I32[R1])(R1) returns to c25f, args: 4, res: 4, upd: 4;
      c25f:
          _s246::P32 = R1;
          if (_s246::P32 & 3 >= 2) goto c25k; else goto c25j;
      c25k:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c25C; else goto c25B;
      c25C:
          HpAlloc = 40;
          goto c25A;
      c25A:
          R1 = _s246::P32;
          call stg_gc_unpt_r1(R1) returns to c25f, args: 4, res: 4, upd: 4;
      c25B:
          _s247::P32 = P32[_s246::P32 + 2];
          _s248::P32 = P32[_s246::P32 + 6];
          I32[Hp - 36] = stg_ap_2_upd_info;
          P32[Hp - 28] = P32[Sp + 8];
          P32[Hp - 24] = _s248::P32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = P32[Sp + 4];
          P32[Hp - 12] = _s247::P32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 36;
          R1 = Hp - 6;
          Sp = Sp + 16;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      c25j:
          R1 = []_closure+1;
          Sp = Sp + 16;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     lvl_r23V_closure:
         const lvl_r23V_info;
 },
 lvl_r23V_entry() //  []
         { info_tbl: [(c25d,
                       label: lvl_r23V_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} }),
                      (c25f,
                       label: block_c25f_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       c25d:
           if ((Sp + -4) < SpLim) goto c25q; else goto c25r;
       c25q:
           R1 = lvl_r23V_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       c25r:
           I32[Sp - 4] = c25f;
           R1 = P32[Sp + 8];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto c25f; else goto c25g;
       c25g:
           call (I32[R1])(R1) returns to c25f, args: 4, res: 4, upd: 4;
       c25f:
           _s246::P32 = R1;
           if (_s246::P32 & 3 >= 2) goto c25k; else goto c25j;
       c25k:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c25C; else goto c25B;
       c25C:
           HpAlloc = 40;
           goto c25A;
       c25A:
           R1 = _s246::P32;
           call stg_gc_unpt_r1(R1) returns to c25f, args: 4, res: 4, upd: 4;
       c25B:
           _s247::P32 = P32[_s246::P32 + 2];
           _s248::P32 = P32[_s246::P32 + 6];
           I32[Hp - 36] = stg_ap_2_upd_info;
           P32[Hp - 28] = P32[Sp + 8];
           P32[Hp - 24] = _s248::P32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = P32[Sp + 4];
           P32[Hp - 12] = _s247::P32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 36;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       c25j:
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     lvl_r23V_closure:
         const lvl_r23V_info;
 },
 lvl_r23V_entry() //  []
         { info_tbl: [(c25d,
                       label: lvl_r23V_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} }),
                      (c25f,
                       label: block_c25f_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       c25d:
           if ((Sp + -4) < SpLim) goto c25q; else goto c25r;
       c25q:
           R1 = lvl_r23V_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       c25r:
           I32[Sp - 4] = c25f;
           R1 = P32[Sp + 8];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto c25f; else goto c25g;
       c25g:
           call (I32[R1])(R1) returns to c25f, args: 4, res: 4, upd: 4;
       c25f:
           _s246::P32 = R1;
           if (_s246::P32 & 3 >= 2) goto c25k; else goto c25j;
       c25k:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c25C; else goto c25B;
       c25C:
           HpAlloc = 40;
           goto c25A;
       c25A:
           R1 = _s246::P32;
           call stg_gc_unpt_r1(R1) returns to c25f, args: 4, res: 4, upd: 4;
       c25B:
           _s247::P32 = P32[_s246::P32 + 2];
           _s248::P32 = P32[_s246::P32 + 6];
           I32[Hp - 36] = stg_ap_2_upd_info;
           P32[Hp - 28] = P32[Sp + 8];
           P32[Hp - 24] = _s248::P32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = P32[Sp + 4];
           P32[Hp - 12] = _s247::P32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 36;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       c25j:
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     n_r23W_closure:
         const n_r23W_info;
 },
 n_r23W_entry() //  []
         { info_tbl: [(c25S,
                       label: n_r23W_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c25S:
           _s24b::P32 = P32[(old + 8)];
           goto c25Q;
       c25Q:
           if (Sp - <highSp> < SpLim) goto c25T; else goto c25U;
       c25T:
           R1 = n_r23W_closure;
           P32[(old + 8)] = _s24b::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       c25U:
           R1 = []_closure+1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c25S:
      _s24b::P32 = P32[(old + 8)];
      goto c25Q;
  c25Q:
      if (Sp - <highSp> < SpLim) goto c25T; else goto c25U;
  c25T:
      R1 = n_r23W_closure;
      P32[(old + 8)] = _s24b::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c25U:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c25S:
      _s24b::P32 = P32[(old + 8)];
      goto c25Q;
  c25Q:
      if (Sp - <highSp> < SpLim) goto c25T; else goto c25U;
  c25T:
      R1 = n_r23W_closure;
      P32[(old + 8)] = _s24b::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c25U:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c25S:
      _s24b::P32 = P32[(old + 8)];
      goto c25Q;
  c25Q:
      if (Sp - <highSp> < SpLim) goto c25T; else goto c25U;
  c25T:
      R1 = n_r23W_closure;
      P32[(old + 8)] = _s24b::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c25U:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c25S:
      _s24b::P32 = P32[Sp];
      goto c25Q;
  c25Q:
      goto c25U;
  c25U:
      R1 = []_closure+1;
      Sp = Sp + 4;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c25S:
      goto c25Q;
  c25Q:
      goto c25U;
  c25U:
      R1 = []_closure+1;
      Sp = Sp + 4;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c25Q, {}), (c25S, {}), (c25U, {})]



==================== after setInfoTableStackMap ====================
n_r23W_entry() //  []
        { info_tbl: [(c25S,
                      label: n_r23W_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      c25S:
          goto c25Q;
      c25Q:
          goto c25U;
      c25U:
          R1 = []_closure+1;
          Sp = Sp + 4;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
n_r23W_entry() //  []
        { info_tbl: [(c25U,
                      label: n_r23W_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      c25U:
          R1 = []_closure+1;
          Sp = Sp + 4;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     n_r23W_closure:
         const n_r23W_info;
 },
 n_r23W_entry() //  []
         { info_tbl: [(c25U,
                       label: n_r23W_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c25U:
           R1 = []_closure+1;
           Sp = Sp + 4;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     n_r23W_closure:
         const n_r23W_info;
 },
 n_r23W_entry() //  []
         { info_tbl: [(c25U,
                       label: n_r23W_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c25U:
           R1 = []_closure+1;
           Sp = Sp + 4;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     n1_r23X_closure:
         const n1_r23X_info;
 },
 n1_r23X_entry() //  []
         { info_tbl: [(c263,
                       label: n1_r23X_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c263:
           _B1::P32 = P32[(old + 8)];
           goto c261;
       c261:
           if (Sp - <highSp> < SpLim) goto c264; else goto c265;
       c264:
           R1 = n1_r23X_closure;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       c265:
           P32[(old + 8)] = _B1::P32;
           call n_r23W_info() args: 8, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c263:
      _B1::P32 = P32[(old + 8)];
      goto c261;
  c261:
      if (Sp - <highSp> < SpLim) goto c264; else goto c265;
  c264:
      R1 = n1_r23X_closure;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c265:
      P32[(old + 8)] = _B1::P32;
      call n_r23W_info() args: 8, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c263:
      _B1::P32 = P32[(old + 8)];
      goto c261;
  c261:
      if (Sp - <highSp> < SpLim) goto c264; else goto c265;
  c264:
      R1 = n1_r23X_closure;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c265:
      P32[(old + 8)] = _B1::P32;
      call n_r23W_info() args: 8, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c263:
      _B1::P32 = P32[(old + 8)];
      goto c261;
  c261:
      if (Sp - <highSp> < SpLim) goto c264; else goto c265;
  c264:
      R1 = n1_r23X_closure;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c265:
      P32[(old + 8)] = _B1::P32;
      call n_r23W_info() args: 8, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c263:
      _B1::P32 = P32[Sp];
      goto c261;
  c261:
      goto c265;
  c265:
      call n_r23W_info() args: 8, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c263:
      goto c261;
  c261:
      goto c265;
  c265:
      call n_r23W_info() args: 8, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c261, {}), (c263, {}), (c265, {})]



==================== after setInfoTableStackMap ====================
n1_r23X_entry() //  []
        { info_tbl: [(c263,
                      label: n1_r23X_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      c263:
          goto c261;
      c261:
          goto c265;
      c265:
          call n_r23W_info() args: 8, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
n1_r23X_entry() //  []
        { info_tbl: [(c265,
                      label: n1_r23X_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      c265:
          call n_r23W_info() args: 8, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     n1_r23X_closure:
         const n1_r23X_info;
 },
 n1_r23X_entry() //  []
         { info_tbl: [(c265,
                       label: n1_r23X_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c265:
           call n_r23W_info() args: 8, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     n1_r23X_closure:
         const n1_r23X_info;
 },
 n1_r23X_entry() //  []
         { info_tbl: [(c265,
                       label: n1_r23X_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c265:
           call n_r23W_info() args: 8, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     lvl1_r23Y_closure:
         const lvl1_r23Y_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r23Y_entry() //  [R1]
         { info_tbl: [(c26h,
                       label: lvl1_r23Y_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c26h:
           _r23Y::P32 = R1;
           goto c26c;
       c26c:
           if (Sp - <highSp> < SpLim) goto c26i; else goto c26j;
       c26j:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c26l; else goto c26k;
       c26l:
           HpAlloc = 8;
           goto c26i;
       c26i:
           R1 = _r23Y::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c26k:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c26e::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _r23Y::P32, Hp - 4);
           if (_c26e::I32 == 0) goto c26g; else goto c26f;
       c26g:
           call (I32[_r23Y::P32])() args: 4, res: 0, upd: 4;
       c26f:
           I32[(old + 12)] = stg_bh_upd_frame_info;
           P32[(old + 8)] = Hp - 4;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = GHC.Types.[]_closure+1;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c26h:
      _r23Y::P32 = R1;
      goto c26c;
  c26c:
      if (Sp - <highSp> < SpLim) goto c26i; else goto c26j;
  c26j:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c26l; else goto c26k;
  c26l:
      HpAlloc = 8;
      goto c26i;
  c26i:
      R1 = _r23Y::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26k:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c26e::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r23Y::P32, Hp - 4);
      if (_c26e::I32 == 0) goto c26g; else goto c26f;
  c26g:
      call (I32[_r23Y::P32])() args: 4, res: 0, upd: 4;
  c26f:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c26h:
      _r23Y::P32 = R1;
      goto c26c;
  c26c:
      if (Sp - <highSp> < SpLim) goto c26i; else goto c26j;
  c26j:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c26l; else goto c26k;
  c26l:
      HpAlloc = 8;
      goto c26i;
  c26i:
      R1 = _r23Y::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26k:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c26e::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r23Y::P32, Hp - 4);
      if (_c26e::I32 == 0) goto c26g; else goto c26f;
  c26g:
      call (I32[_r23Y::P32])() args: 4, res: 0, upd: 4;
  c26f:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c26h:
      _r23Y::P32 = R1;
      goto c26c;
  c26c:
      if (Sp - <highSp> < SpLim) goto c26i; else goto c26j;
  c26j:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c26l; else goto c26k;
  c26l:
      HpAlloc = 8;
      goto c26i;
  c26i:
      R1 = _r23Y::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26k:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c26e::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r23Y::P32, Hp - 4);
      if (_c26e::I32 == 0) goto c26g; else goto c26f;
  c26g:
      call (I32[_r23Y::P32])() args: 4, res: 0, upd: 4;
  c26f:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c26h:
      _r23Y::P32 = R1;
      goto c26c;
  c26c:
      if (Sp - 24 < SpLim) goto c26i; else goto c26j;
  c26j:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c26l; else goto c26k;
  c26l:
      HpAlloc = 8;
      goto c26i;
  c26i:
      R1 = _r23Y::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26k:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c26e::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r23Y::P32, Hp - 4);
      if (_c26e::I32 == 0) goto c26g; else goto c26f;
  c26g:
      call (I32[_r23Y::P32])() args: 4, res: 0, upd: 4;
  c26f:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = GHC.Types.[]_closure+1;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c26h:
      goto c26c;
  c26c:
      _r23Y::P32 = R1;
      if ((Sp + -24) < SpLim) goto c26i; else goto c26j;
  c26j:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c26l; else goto c26k;
  c26l:
      HpAlloc = 8;
      goto c26i;
  c26i:
      R1 = _r23Y::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26k:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c26e::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r23Y::P32, Hp - 4);
      if (_c26e::I32 == 0) goto c26g; else goto c26f;
  c26g:
      call (I32[_r23Y::P32])() args: 4, res: 0, upd: 4;
  c26f:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = GHC.Types.[]_closure+1;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c26c, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c26f, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c26g, {}),
 (c26h, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c26i, {}),
 (c26j, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c26k, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c26l, {})]



==================== after setInfoTableStackMap ====================
lvl1_r23Y_entry() //  [R1]
        { info_tbl: [(c26h,
                      label: lvl1_r23Y_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c26h:
          goto c26c;
      c26c:
          _r23Y::P32 = R1;
          if ((Sp + -24) < SpLim) goto c26i; else goto c26j;
      c26j:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c26l; else goto c26k;
      c26l:
          HpAlloc = 8;
          goto c26i;
      c26i:
          R1 = _r23Y::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c26k:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c26e::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, _r23Y::P32, Hp - 4);
          if (_c26e::I32 == 0) goto c26g; else goto c26f;
      c26g:
          call (I32[_r23Y::P32])() args: 4, res: 0, upd: 4;
      c26f:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = GHC.Types.[]_closure+1;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
lvl1_r23Y_entry() //  [R1]
        { info_tbl: [(c26c,
                      label: lvl1_r23Y_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c26c:
          _r23Y::P32 = R1;
          if ((Sp + -24) < SpLim) goto c26i; else goto c26j;
      c26j:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c26l; else goto c26k;
      c26l:
          HpAlloc = 8;
          goto c26i;
      c26i:
          R1 = _r23Y::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c26k:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c26e::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, _r23Y::P32, Hp - 4);
          if (_c26e::I32 == 0) goto c26g; else goto c26f;
      c26g:
          call (I32[_r23Y::P32])() args: 4, res: 0, upd: 4;
      c26f:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = GHC.Types.[]_closure+1;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     lvl1_r23Y_closure:
         const lvl1_r23Y_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r23Y_entry() //  [R1]
         { info_tbl: [(c26c,
                       label: lvl1_r23Y_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c26c:
           _r23Y::P32 = R1;
           if ((Sp + -24) < SpLim) goto c26i; else goto c26j;
       c26j:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c26l; else goto c26k;
       c26l:
           HpAlloc = 8;
           goto c26i;
       c26i:
           R1 = _r23Y::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c26k:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c26e::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _r23Y::P32, Hp - 4);
           if (_c26e::I32 == 0) goto c26g; else goto c26f;
       c26g:
           call (I32[_r23Y::P32])() args: 4, res: 0, upd: 4;
       c26f:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     lvl1_r23Y_closure:
         const lvl1_r23Y_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r23Y_entry() //  [R1]
         { info_tbl: [(c26c,
                       label: lvl1_r23Y_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c26c:
           _r23Y::P32 = R1;
           if ((Sp + -24) < SpLim) goto c26i; else goto c26j;
       c26j:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c26l; else goto c26k;
       c26l:
           HpAlloc = 8;
           goto c26i;
       c26i:
           R1 = _r23Y::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c26k:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c26e::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _r23Y::P32, Hp - 4);
           if (_c26e::I32 == 0) goto c26g; else goto c26f;
       c26g:
           call (I32[_r23Y::P32])() args: 4, res: 0, upd: 4;
       c26f:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     go_r23Z_closure:
         const go_r23Z_info;
 },
 sat_s24l_entry() //  [R1]
         { info_tbl: [(c271,
                       label: sat_s24l_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c271:
           _s24l::P32 = R1;
           goto c26V;
       c26V:
           if (Sp - <highSp> < SpLim) goto c272; else goto c273;
       c272:
           R1 = _s24l::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c273:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _s24l::P32;
           _s24g::P32 = P32[_s24l::P32 + 8];
           _s24c::I32 = I32[_s24l::P32 + 12];
           _s24j::I32 = _s24c::I32;
           if (_s24j::I32 != 20) goto c26Z; else goto c270;
       c26Z:
           _c275::I32 = _s24j::I32 + 1;
           _s24k::I32 = _c275::I32;
           I32[(old + 20)] = _s24k::I32;
           P32[(old + 16)] = _s24g::P32;
           call go_r23Z_info() args: 20, res: 0, upd: 12;
       c270:
           R1 = []_closure+1;
           call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
     }
 },
 go_r23Z_entry() //  []
         { info_tbl: [(c27d,
                       label: go_r23Z_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 11} })]
           stack_info: arg_space: 12 updfr_space: Just 4
         }
     {offset
       c27d:
           _s24c::I32 = I32[(old + 12)];
           _s24d::P32 = P32[(old + 8)];
           goto c26L;
       c26L:
           if (Sp - <highSp> < SpLim) goto c27e; else goto c27f;
       c27e:
           R1 = go_r23Z_closure;
           I32[(old + 12)] = _s24c::I32;
           P32[(old + 8)] = _s24d::P32;
           call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
       c27f:
           I32[(young<c26N> + 4)] = c26N;
           R1 = _s24d::P32;
           if (R1 & 3 != 0) goto c26N; else goto c26O;
       c26O:
           call (I32[R1])(R1) returns to c26N, args: 4, res: 4, upd: 4;
       c26N:
           _s24e::P32 = R1;
           _c279::P32 = _s24e::P32 & 3;
           if (_c279::P32 >= 2) goto c27b; else goto c27c;
       c27b:
           goto c278;
       c278:
           Hp = Hp + 48;
           if (Hp > HpLim) goto c27n; else goto c27m;
       c27n:
           HpAlloc = 48;
           goto c27l;
       c27l:
           R1 = _s24e::P32;
           call stg_gc_unpt_r1(R1) returns to c26N, args: 4, res: 4, upd: 4;
       c27m:
           _s24f::P32 = P32[_s24e::P32 + 2];
           _s24g::P32 = P32[_s24e::P32 + 6];
           I32[Hp - 44] = sat_s24l_info;
           P32[Hp - 36] = _s24g::P32;
           I32[Hp - 32] = _s24c::I32;
           _c26T::P32 = Hp - 44;
           I32[Hp - 28] = GHC.Types.I#_con_info;
           I32[Hp - 24] = _s24c::I32;
           _c27i::P32 = Hp - 27;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _c27i::P32;
           P32[Hp - 12] = _s24f::P32;
           _c27j::P32 = Hp - 19;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = _c27j::P32;
           P32[Hp] = _c26T::P32;
           _c27k::P32 = Hp - 6;
           R1 = _c27k::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
       c27c:
           goto c277;
       c277:
           R1 = []_closure+1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c271:
      _s24l::P32 = R1;
      goto c26V;
  c26V:
      if (Sp - <highSp> < SpLim) goto c272; else goto c273;
  c272:
      R1 = _s24l::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c273:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24l::P32;
      _s24g::P32 = P32[_s24l::P32 + 8];
      _s24c::I32 = I32[_s24l::P32 + 12];
      _s24j::I32 = _s24c::I32;
      if (_s24j::I32 != 20) goto c26Z; else goto c270;
  c26Z:
      _c275::I32 = _s24j::I32 + 1;
      _s24k::I32 = _c275::I32;
      I32[(old + 20)] = _s24k::I32;
      P32[(old + 16)] = _s24g::P32;
      call go_r23Z_info() args: 20, res: 0, upd: 12;
  c270:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c271:
      _s24l::P32 = R1;
      goto c26V;
  c26V:
      if (Sp - <highSp> < SpLim) goto c272; else goto c273;
  c272:
      R1 = _s24l::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c273:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24l::P32;
      _s24g::P32 = P32[_s24l::P32 + 8];
      _s24c::I32 = I32[_s24l::P32 + 12];
      _s24j::I32 = _s24c::I32;
      if (_s24j::I32 != 20) goto c26Z; else goto c270;
  c26Z:
      _c275::I32 = _s24j::I32 + 1;
      _s24k::I32 = _c275::I32;
      I32[(old + 20)] = _s24k::I32;
      P32[(old + 16)] = _s24g::P32;
      call go_r23Z_info() args: 20, res: 0, upd: 12;
  c270:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c271:
      _s24l::P32 = R1;
      goto c26V;
  c26V:
      if (Sp - <highSp> < SpLim) goto c272; else goto c273;
  c272:
      R1 = _s24l::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c273:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24l::P32;
      _s24g::P32 = P32[_s24l::P32 + 8];
      _s24c::I32 = I32[_s24l::P32 + 12];
      _s24j::I32 = _s24c::I32;
      if (_s24j::I32 != 20) goto c26Z; else goto c270;
  c26Z:
      _c275::I32 = _s24j::I32 + 1;
      _s24k::I32 = _c275::I32;
      I32[(old + 20)] = _s24k::I32;
      P32[(old + 16)] = _s24g::P32;
      call go_r23Z_info() args: 20, res: 0, upd: 12;
  c270:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c271:
      _s24l::P32 = R1;
      goto c26V;
  c26V:
      if (Sp - 16 < SpLim) goto c272; else goto c273;
  c272:
      R1 = _s24l::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c273:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _s24l::P32;
      _s24g::P32 = P32[_s24l::P32 + 8];
      _s24c::I32 = I32[_s24l::P32 + 12];
      _s24j::I32 = _s24c::I32;
      if (_s24j::I32 != 20) goto c26Z; else goto c270;
  c26Z:
      _c275::I32 = _s24j::I32 + 1;
      _s24k::I32 = _c275::I32;
      I32[Sp - 16] = _s24k::I32;
      P32[Sp - 12] = _s24g::P32;
      Sp = Sp - 16;
      call go_r23Z_info() args: 20, res: 0, upd: 12;
  c270:
      R1 = []_closure+1;
      Sp = Sp - 8;
      call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c271:
      goto c26V;
  c26V:
      _s24l::P32 = R1;
      if ((Sp + -16) < SpLim) goto c272; else goto c273;
  c272:
      R1 = _s24l::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c273:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _s24l::P32;
      _s24j::I32 = I32[_s24l::P32 + 12];
      if (_s24j::I32 != 20) goto c26Z; else goto c270;
  c26Z:
      I32[Sp - 16] = _s24j::I32 + 1;
      P32[Sp - 12] = P32[_s24l::P32 + 8];
      Sp = Sp - 16;
      call go_r23Z_info() args: 20, res: 0, upd: 12;
  c270:
      R1 = []_closure+1;
      Sp = Sp - 8;
      call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c26V, {}), (c26Z, {}), (c270, {}), (c271, {}), (c272, {}),
 (c273, {})]



==================== after setInfoTableStackMap ====================
sat_s24l_entry() //  [R1]
        { info_tbl: [(c271,
                      label: sat_s24l_info
                      rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c271:
          goto c26V;
      c26V:
          _s24l::P32 = R1;
          if ((Sp + -16) < SpLim) goto c272; else goto c273;
      c272:
          R1 = _s24l::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c273:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _s24l::P32;
          _s24j::I32 = I32[_s24l::P32 + 12];
          if (_s24j::I32 != 20) goto c26Z; else goto c270;
      c26Z:
          I32[Sp - 16] = _s24j::I32 + 1;
          P32[Sp - 12] = P32[_s24l::P32 + 8];
          Sp = Sp - 16;
          call go_r23Z_info() args: 20, res: 0, upd: 12;
      c270:
          R1 = []_closure+1;
          Sp = Sp - 8;
          call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_s24l_entry() //  [R1]
        { info_tbl: [(c26V,
                      label: sat_s24l_info
                      rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c26V:
          _s24l::P32 = R1;
          if ((Sp + -16) < SpLim) goto c272; else goto c273;
      c272:
          R1 = _s24l::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c273:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _s24l::P32;
          _s24j::I32 = I32[_s24l::P32 + 12];
          if (_s24j::I32 != 20) goto c26Z; else goto c270;
      c26Z:
          I32[Sp - 16] = _s24j::I32 + 1;
          P32[Sp - 12] = P32[_s24l::P32 + 8];
          Sp = Sp - 16;
          call go_r23Z_info() args: 20, res: 0, upd: 12;
      c270:
          R1 = []_closure+1;
          Sp = Sp - 8;
          call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  c27d:
      _s24c::I32 = I32[(old + 12)];
      _s24d::P32 = P32[(old + 8)];
      goto c26L;
  c26L:
      if (Sp - <highSp> < SpLim) goto c27e; else goto c27f;
  c27e:
      R1 = go_r23Z_closure;
      I32[(old + 12)] = _s24c::I32;
      P32[(old + 8)] = _s24d::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c27f:
      I32[(young<c26N> + 4)] = c26N;
      R1 = _s24d::P32;
      if (R1 & 3 != 0) goto c26N; else goto c26O;
  c26O:
      call (I32[R1])(R1) returns to c26N, args: 4, res: 4, upd: 4;
  c26N:
      _s24e::P32 = R1;
      _c279::P32 = _s24e::P32 & 3;
      if (_c279::P32 >= 2) goto c278; else goto c277;
  c278:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c27n; else goto c27m;
  c27n:
      HpAlloc = 48;
      goto c27l;
  c27l:
      R1 = _s24e::P32;
      call stg_gc_unpt_r1(R1) returns to c26N, args: 4, res: 4, upd: 4;
  c27m:
      _s24f::P32 = P32[_s24e::P32 + 2];
      _s24g::P32 = P32[_s24e::P32 + 6];
      I32[Hp - 44] = sat_s24l_info;
      P32[Hp - 36] = _s24g::P32;
      I32[Hp - 32] = _s24c::I32;
      _c26T::P32 = Hp - 44;
      I32[Hp - 28] = GHC.Types.I#_con_info;
      I32[Hp - 24] = _s24c::I32;
      _c27i::P32 = Hp - 27;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _c27i::P32;
      P32[Hp - 12] = _s24f::P32;
      _c27j::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c27j::P32;
      P32[Hp] = _c26T::P32;
      _c27k::P32 = Hp - 6;
      R1 = _c27k::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c277:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c27d:
      _s24c::I32 = I32[(old + 12)];
      _s24d::P32 = P32[(old + 8)];
      goto c26L;
  c26L:
      if (Sp - <highSp> < SpLim) goto c27e; else goto c27f;
  c27e:
      R1 = go_r23Z_closure;
      I32[(old + 12)] = _s24c::I32;
      P32[(old + 8)] = _s24d::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c27f:
      I32[(young<c26N> + 4)] = c26N;
      R1 = _s24d::P32;
      if (R1 & 3 != 0) goto c26N; else goto c26O;
  c26O:
      call (I32[R1])(R1) returns to c26N, args: 4, res: 4, upd: 4;
  c26N:
      _s24e::P32 = R1;
      _c279::P32 = _s24e::P32 & 3;
      if (_c279::P32 >= 2) goto c278; else goto c277;
  c278:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c27n; else goto c27m;
  c27n:
      HpAlloc = 48;
      goto c27l;
  c27l:
      R1 = _s24e::P32;
      call stg_gc_unpt_r1(R1) returns to c26N, args: 4, res: 4, upd: 4;
  c27m:
      _s24f::P32 = P32[_s24e::P32 + 2];
      _s24g::P32 = P32[_s24e::P32 + 6];
      I32[Hp - 44] = sat_s24l_info;
      P32[Hp - 36] = _s24g::P32;
      I32[Hp - 32] = _s24c::I32;
      _c26T::P32 = Hp - 44;
      I32[Hp - 28] = GHC.Types.I#_con_info;
      I32[Hp - 24] = _s24c::I32;
      _c27i::P32 = Hp - 27;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _c27i::P32;
      P32[Hp - 12] = _s24f::P32;
      _c27j::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c27j::P32;
      P32[Hp] = _c26T::P32;
      _c27k::P32 = Hp - 6;
      R1 = _c27k::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c277:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c27d:
      _s24c::I32 = I32[(old + 12)];
      _s24d::P32 = P32[(old + 8)];
      goto c26L;
  c26L:
      if (Sp - <highSp> < SpLim) goto c27e; else goto c27f;
  c27e:
      R1 = go_r23Z_closure;
      I32[(old + 12)] = _s24c::I32;
      P32[(old + 8)] = _s24d::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c27f:
      I32[(young<c26N> + 4)] = c26N;
      R1 = _s24d::P32;
      if (R1 & 3 != 0) goto c26N; else goto c26O;
  c26O:
      call (I32[R1])(R1) returns to c26N, args: 4, res: 4, upd: 4;
  c26N:
      _s24e::P32 = R1;
      _c279::P32 = _s24e::P32 & 3;
      if (_c279::P32 >= 2) goto c278; else goto c277;
  c278:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c27n; else goto c27m;
  c27n:
      HpAlloc = 48;
      goto c27l;
  c27l:
      R1 = _s24e::P32;
      call stg_gc_unpt_r1(R1) returns to c26N, args: 4, res: 4, upd: 4;
  c27m:
      _s24f::P32 = P32[_s24e::P32 + 2];
      _s24g::P32 = P32[_s24e::P32 + 6];
      I32[Hp - 44] = sat_s24l_info;
      P32[Hp - 36] = _s24g::P32;
      I32[Hp - 32] = _s24c::I32;
      _c26T::P32 = Hp - 44;
      I32[Hp - 28] = GHC.Types.I#_con_info;
      I32[Hp - 24] = _s24c::I32;
      _c27i::P32 = Hp - 27;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _c27i::P32;
      P32[Hp - 12] = _s24f::P32;
      _c27j::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c27j::P32;
      P32[Hp] = _c26T::P32;
      _c27k::P32 = Hp - 6;
      R1 = _c27k::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c277:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c27d:
      _s24c::I32 = I32[Sp];
      _s24d::P32 = P32[Sp + 4];
      goto c26L;
  c26L:
      if (Sp - 4 < SpLim) goto c27e; else goto c27f;
  c27e:
      R1 = go_r23Z_closure;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c27f:
      I32[Sp - 4] = c26N;
      R1 = _s24d::P32;
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto c26N; else goto c26O;
  c26O:
      call (I32[R1])(R1) returns to c26N, args: 4, res: 4, upd: 4;
  c26N:
      _s24c::I32 = I32[Sp + 4];
      _s24e::P32 = R1;
      _c279::P32 = _s24e::P32 & 3;
      if (_c279::P32 >= 2) goto c278; else goto c277;
  c278:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c27n; else goto c27m;
  c27n:
      HpAlloc = 48;
      goto c27l;
  c27l:
      R1 = _s24e::P32;
      call stg_gc_unpt_r1(R1) returns to c26N, args: 4, res: 4, upd: 4;
  c27m:
      _s24f::P32 = P32[_s24e::P32 + 2];
      _s24g::P32 = P32[_s24e::P32 + 6];
      I32[Hp - 44] = sat_s24l_info;
      P32[Hp - 36] = _s24g::P32;
      I32[Hp - 32] = _s24c::I32;
      _c26T::P32 = Hp - 44;
      I32[Hp - 28] = GHC.Types.I#_con_info;
      I32[Hp - 24] = _s24c::I32;
      _c27i::P32 = Hp - 27;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _c27i::P32;
      P32[Hp - 12] = _s24f::P32;
      _c27j::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c27j::P32;
      P32[Hp] = _c26T::P32;
      _c27k::P32 = Hp - 6;
      R1 = _c27k::P32;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  c277:
      R1 = []_closure+1;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c27d:
      goto c26L;
  c26L:
      if ((Sp + -4) < SpLim) goto c27e; else goto c27f;
  c27e:
      R1 = go_r23Z_closure;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c27f:
      I32[Sp - 4] = c26N;
      R1 = P32[Sp + 4];
      Sp = Sp - 4;
      if (R1 & 3 != 0) goto c26N; else goto c26O;
  c26O:
      call (I32[R1])(R1) returns to c26N, args: 4, res: 4, upd: 4;
  c26N:
      _s24e::P32 = R1;
      if (_s24e::P32 & 3 >= 2) goto c278; else goto c277;
  c278:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c27n; else goto c27m;
  c27n:
      HpAlloc = 48;
      goto c27l;
  c27l:
      R1 = _s24e::P32;
      call stg_gc_unpt_r1(R1) returns to c26N, args: 4, res: 4, upd: 4;
  c27m:
      _s24f::P32 = P32[_s24e::P32 + 2];
      _s24g::P32 = P32[_s24e::P32 + 6];
      I32[Hp - 44] = sat_s24l_info;
      P32[Hp - 36] = _s24g::P32;
      _s24c::I32 = I32[Sp + 4];
      I32[Hp - 32] = _s24c::I32;
      I32[Hp - 28] = GHC.Types.I#_con_info;
      I32[Hp - 24] = _s24c::I32;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = Hp - 27;
      P32[Hp - 12] = _s24f::P32;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = Hp - 19;
      P32[Hp] = Hp - 44;
      R1 = Hp - 6;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  c277:
      R1 = []_closure+1;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c26L, {sat_s24l_closure}), (c26N, {sat_s24l_closure}),
 (c26O, {sat_s24l_closure}), (c277, {}), (c278, {sat_s24l_closure}),
 (c27d, {sat_s24l_closure}), (c27e, {}), (c27f, {sat_s24l_closure}),
 (c27l, {sat_s24l_closure}), (c27m, {sat_s24l_closure}),
 (c27n, {sat_s24l_closure})]



==================== after setInfoTableStackMap ====================
go_r23Z_entry() //  []
        { info_tbl: [(c26N,
                      label: block_c26N_info
                      rep:StackRep [True, True]),
                     (c27d,
                      label: go_r23Z_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 11} })]
          stack_info: arg_space: 12 updfr_space: Just 4
        }
    {offset
      c27d:
          goto c26L;
      c26L:
          if ((Sp + -4) < SpLim) goto c27e; else goto c27f;
      c27e:
          R1 = go_r23Z_closure;
          call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
      c27f:
          I32[Sp - 4] = c26N;
          R1 = P32[Sp + 4];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto c26N; else goto c26O;
      c26O:
          call (I32[R1])(R1) returns to c26N, args: 4, res: 4, upd: 4;
      c26N:
          _s24e::P32 = R1;
          if (_s24e::P32 & 3 >= 2) goto c278; else goto c277;
      c278:
          Hp = Hp + 48;
          if (Hp > HpLim) goto c27n; else goto c27m;
      c27n:
          HpAlloc = 48;
          goto c27l;
      c27l:
          R1 = _s24e::P32;
          call stg_gc_unpt_r1(R1) returns to c26N, args: 4, res: 4, upd: 4;
      c27m:
          _s24f::P32 = P32[_s24e::P32 + 2];
          _s24g::P32 = P32[_s24e::P32 + 6];
          I32[Hp - 44] = sat_s24l_info;
          P32[Hp - 36] = _s24g::P32;
          _s24c::I32 = I32[Sp + 4];
          I32[Hp - 32] = _s24c::I32;
          I32[Hp - 28] = GHC.Types.I#_con_info;
          I32[Hp - 24] = _s24c::I32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = Hp - 27;
          P32[Hp - 12] = _s24f::P32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 44;
          R1 = Hp - 6;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      c277:
          R1 = []_closure+1;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
go_r23Z_entry() //  []
        { info_tbl: [(c26L,
                      label: go_r23Z_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 11} }),
                     (c26N,
                      label: block_c26N_info
                      rep:StackRep [True, True])]
          stack_info: arg_space: 12 updfr_space: Just 4
        }
    {offset
      c26L:
          if ((Sp + -4) < SpLim) goto c27e; else goto c27f;
      c27e:
          R1 = go_r23Z_closure;
          call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
      c27f:
          I32[Sp - 4] = c26N;
          R1 = P32[Sp + 4];
          Sp = Sp - 4;
          if (R1 & 3 != 0) goto c26N; else goto c26O;
      c26O:
          call (I32[R1])(R1) returns to c26N, args: 4, res: 4, upd: 4;
      c26N:
          _s24e::P32 = R1;
          if (_s24e::P32 & 3 >= 2) goto c278; else goto c277;
      c278:
          Hp = Hp + 48;
          if (Hp > HpLim) goto c27n; else goto c27m;
      c27n:
          HpAlloc = 48;
          goto c27l;
      c27l:
          R1 = _s24e::P32;
          call stg_gc_unpt_r1(R1) returns to c26N, args: 4, res: 4, upd: 4;
      c27m:
          _s24f::P32 = P32[_s24e::P32 + 2];
          _s24g::P32 = P32[_s24e::P32 + 6];
          I32[Hp - 44] = sat_s24l_info;
          P32[Hp - 36] = _s24g::P32;
          _s24c::I32 = I32[Sp + 4];
          I32[Hp - 32] = _s24c::I32;
          I32[Hp - 28] = GHC.Types.I#_con_info;
          I32[Hp - 24] = _s24c::I32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = Hp - 27;
          P32[Hp - 12] = _s24f::P32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 44;
          R1 = Hp - 6;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      c277:
          R1 = []_closure+1;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     go_r23Z_closure:
         const go_r23Z_info;
 },
 sat_s24l_entry() //  [R1]
         { info_tbl: [(c26V,
                       label: sat_s24l_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c26V:
           _s24l::P32 = R1;
           if ((Sp + -16) < SpLim) goto c272; else goto c273;
       c272:
           R1 = _s24l::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c273:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _s24l::P32;
           _s24j::I32 = I32[_s24l::P32 + 12];
           if (_s24j::I32 != 20) goto c26Z; else goto c270;
       c26Z:
           I32[Sp - 16] = _s24j::I32 + 1;
           P32[Sp - 12] = P32[_s24l::P32 + 8];
           Sp = Sp - 16;
           call go_r23Z_info() args: 20, res: 0, upd: 12;
       c270:
           R1 = []_closure+1;
           Sp = Sp - 8;
           call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
     }
 },
 go_r23Z_entry() //  []
         { info_tbl: [(c26L,
                       label: go_r23Z_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 11} }),
                      (c26N,
                       label: block_c26N_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 12 updfr_space: Just 4
         }
     {offset
       c26L:
           if ((Sp + -4) < SpLim) goto c27e; else goto c27f;
       c27e:
           R1 = go_r23Z_closure;
           call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
       c27f:
           I32[Sp - 4] = c26N;
           R1 = P32[Sp + 4];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto c26N; else goto c26O;
       c26O:
           call (I32[R1])(R1) returns to c26N, args: 4, res: 4, upd: 4;
       c26N:
           _s24e::P32 = R1;
           if (_s24e::P32 & 3 >= 2) goto c278; else goto c277;
       c278:
           Hp = Hp + 48;
           if (Hp > HpLim) goto c27n; else goto c27m;
       c27n:
           HpAlloc = 48;
           goto c27l;
       c27l:
           R1 = _s24e::P32;
           call stg_gc_unpt_r1(R1) returns to c26N, args: 4, res: 4, upd: 4;
       c27m:
           _s24f::P32 = P32[_s24e::P32 + 2];
           _s24g::P32 = P32[_s24e::P32 + 6];
           I32[Hp - 44] = sat_s24l_info;
           P32[Hp - 36] = _s24g::P32;
           _s24c::I32 = I32[Sp + 4];
           I32[Hp - 32] = _s24c::I32;
           I32[Hp - 28] = GHC.Types.I#_con_info;
           I32[Hp - 24] = _s24c::I32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = Hp - 27;
           P32[Hp - 12] = _s24f::P32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 44;
           R1 = Hp - 6;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       c277:
           R1 = []_closure+1;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     go_r23Z_closure:
         const go_r23Z_info;
 },
 sat_s24l_entry() //  [R1]
         { info_tbl: [(c26V,
                       label: sat_s24l_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c26V:
           _s24l::P32 = R1;
           if ((Sp + -16) < SpLim) goto c272; else goto c273;
       c272:
           R1 = _s24l::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c273:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _s24l::P32;
           _s24j::I32 = I32[_s24l::P32 + 12];
           if (_s24j::I32 != 20) goto c26Z; else goto c270;
       c26Z:
           I32[Sp - 16] = _s24j::I32 + 1;
           P32[Sp - 12] = P32[_s24l::P32 + 8];
           Sp = Sp - 16;
           call go_r23Z_info() args: 20, res: 0, upd: 12;
       c270:
           R1 = []_closure+1;
           Sp = Sp - 8;
           call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
     }
 },
 go_r23Z_entry() //  []
         { info_tbl: [(c26L,
                       label: go_r23Z_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 11} }),
                      (c26N,
                       label: block_c26N_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 12 updfr_space: Just 4
         }
     {offset
       c26L:
           if ((Sp + -4) < SpLim) goto c27e; else goto c27f;
       c27e:
           R1 = go_r23Z_closure;
           call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
       c27f:
           I32[Sp - 4] = c26N;
           R1 = P32[Sp + 4];
           Sp = Sp - 4;
           if (R1 & 3 != 0) goto c26N; else goto c26O;
       c26O:
           call (I32[R1])(R1) returns to c26N, args: 4, res: 4, upd: 4;
       c26N:
           _s24e::P32 = R1;
           if (_s24e::P32 & 3 >= 2) goto c278; else goto c277;
       c278:
           Hp = Hp + 48;
           if (Hp > HpLim) goto c27n; else goto c27m;
       c27n:
           HpAlloc = 48;
           goto c27l;
       c27l:
           R1 = _s24e::P32;
           call stg_gc_unpt_r1(R1) returns to c26N, args: 4, res: 4, upd: 4;
       c27m:
           _s24f::P32 = P32[_s24e::P32 + 2];
           _s24g::P32 = P32[_s24e::P32 + 6];
           I32[Hp - 44] = sat_s24l_info;
           P32[Hp - 36] = _s24g::P32;
           _s24c::I32 = I32[Sp + 4];
           I32[Hp - 32] = _s24c::I32;
           I32[Hp - 28] = GHC.Types.I#_con_info;
           I32[Hp - 24] = _s24c::I32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = Hp - 27;
           P32[Hp - 12] = _s24f::P32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 44;
           R1 = Hp - 6;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       c277:
           R1 = []_closure+1;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main_go_closure:
         const Main.main_go_info;
         const 0;
 },
 sat_s24G_entry() //  [R1]
         { info_tbl: [(c293,
                       label: sat_s24G_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c293:
           _s24G::P32 = R1;
           goto c28X;
       c28X:
           if (Sp - <highSp> < SpLim) goto c294; else goto c295;
       c294:
           R1 = _s24G::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c295:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _s24G::P32;
           _s24m::I32 = I32[_s24G::P32 + 8];
           _s24E::I32 = _s24m::I32;
           if (_s24E::I32 != 20) goto c291; else goto c292;
       c291:
           _c297::I32 = _s24E::I32 + 1;
           _s24F::I32 = _c297::I32;
           I32[(old + 16)] = _s24F::I32;
           call Main.main_go_info() args: 16, res: 0, upd: 12;
       c292:
           R1 = []_closure+1;
           call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
     }
 },
 sat_s24z_entry() //  [R1]
         { info_tbl: [(c298,
                       label: sat_s24z_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c298:
           _s24z::P32 = R1;
           goto c28e;
       c28e:
           if (Sp - <highSp> < SpLim) goto c299; else goto c29q;
       c299:
           R1 = _s24z::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c29q:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _s24z::P32;
           _s24m::I32 = I32[_s24z::P32 + 8];
           _c28g::I32 = 3 + _s24m::I32;
           _s24v::I32 = _c28g::I32;
           _c28j::I32 = %MO_S_Ge_W32(_s24v::I32, _s24m::I32);
           if (_c28j::I32 >= 1) goto c29s; else goto c29t;
       c29s:
           goto c29l;
       c29l:
           I32[(young<c29k> + 4)] = c29k;
           P32[(young<c29k> + 32)] = lvl_r23V_closure+3;
           P32[(young<c29k> + 28)] = n1_r23X_closure+1;
           I32[(young<c29k> + 24)] = _s24m::I32;
           I32[(young<c29k> + 20)] = _s24v::I32;
           I32[(young<c29k> + 16)] = 20;
           I32[(young<c29k> + 12)] = stg_ap_p_info;
           P32[(young<c29k> + 8)] = xs2_r23U_closure+2;
           call GHC.Enum.efdtIntUpFB_info() returns to c29k, args: 32, res: 4, upd: 12;
       c29k:
           _s24y::P32 = R1;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = _s24y::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
       c29t:
           goto c29e;
       c29e:
           I32[(young<c29c> + 4)] = c29c;
           P32[(young<c29c> + 32)] = lvl_r23V_closure+3;
           P32[(young<c29c> + 28)] = n1_r23X_closure+1;
           I32[(young<c29c> + 24)] = _s24m::I32;
           I32[(young<c29c> + 20)] = _s24v::I32;
           I32[(young<c29c> + 16)] = 20;
           I32[(young<c29c> + 12)] = stg_ap_p_info;
           P32[(young<c29c> + 8)] = xs2_r23U_closure+2;
           call GHC.Enum.efdtIntDnFB_info() returns to c29c, args: 32, res: 4, upd: 12;
       c29c:
           _s24x::P32 = R1;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = _s24x::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24u_entry() //  [R1]
         { info_tbl: [(c29u,
                       label: sat_s24u_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c29u:
           _s24u::P32 = R1;
           goto c28C;
       c28C:
           if (Sp - <highSp> < SpLim) goto c29v; else goto c29M;
       c29v:
           R1 = _s24u::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c29M:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _s24u::P32;
           _s24m::I32 = I32[_s24u::P32 + 8];
           _c28E::I32 = 2 + _s24m::I32;
           _s24q::I32 = _c28E::I32;
           _c28H::I32 = %MO_S_Ge_W32(_s24q::I32, _s24m::I32);
           if (_c28H::I32 >= 1) goto c29O; else goto c29P;
       c29O:
           goto c29H;
       c29H:
           I32[(young<c29G> + 4)] = c29G;
           P32[(young<c29G> + 32)] = lvl_r23V_closure+3;
           P32[(young<c29G> + 28)] = n_r23W_closure+1;
           I32[(young<c29G> + 24)] = _s24m::I32;
           I32[(young<c29G> + 20)] = _s24q::I32;
           I32[(young<c29G> + 16)] = 20;
           I32[(young<c29G> + 12)] = stg_ap_p_info;
           P32[(young<c29G> + 8)] = xs1_r23S_closure+2;
           call GHC.Enum.efdtIntUpFB_info() returns to c29G, args: 32, res: 4, upd: 12;
       c29G:
           _s24t::P32 = R1;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = _s24t::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
       c29P:
           goto c29A;
       c29A:
           I32[(young<c29y> + 4)] = c29y;
           P32[(young<c29y> + 32)] = lvl_r23V_closure+3;
           P32[(young<c29y> + 28)] = n_r23W_closure+1;
           I32[(young<c29y> + 24)] = _s24m::I32;
           I32[(young<c29y> + 20)] = _s24q::I32;
           I32[(young<c29y> + 16)] = 20;
           I32[(young<c29y> + 12)] = stg_ap_p_info;
           P32[(young<c29y> + 8)] = xs1_r23S_closure+2;
           call GHC.Enum.efdtIntDnFB_info() returns to c29y, args: 32, res: 4, upd: 12;
       c29y:
           _s24s::P32 = R1;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = _s24s::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24p_entry() //  [R1]
         { info_tbl: [(c29X,
                       label: sat_s24p_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c29X:
           _s24p::P32 = R1;
           goto c28U;
       c28U:
           if (Sp - <highSp> < SpLim) goto c29Y; else goto c2a5;
       c29Y:
           R1 = _s24p::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2a5:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _s24p::P32;
           _s24m::I32 = I32[_s24p::P32 + 8];
           _c28W::I32 = %MO_S_Gt_W32(_s24m::I32, 20);
           if (_c28W::I32 >= 1) goto c29V; else goto c29W;
       c29V:
           goto c29T;
       c29T:
           R1 = lvl1_r23Y_closure;
           call (I32[R1])(R1) args: 12, res: 0, upd: 12;
       c29W:
           goto c29S;
       c29S:
           I32[(young<c2a0> + 4)] = c2a0;
           I32[(young<c2a0> + 12)] = _s24m::I32;
           P32[(young<c2a0> + 8)] = xs_r23Q_closure+2;
           call go_r23Z_info() returns to c2a0, args: 12, res: 4, upd: 12;
       c2a0:
           _s24o::P32 = R1;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = _s24o::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24D_entry() //  [R1]
         { info_tbl: [(c2a7,
                       label: sat_s24D_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2a7:
           _s24D::P32 = R1;
           goto c28a;
       c28a:
           if (Sp - <highSp> < SpLim) goto c2a8; else goto c2a9;
       c2a9:
           Hp = Hp + 72;
           if (Hp > HpLim) goto c2ab; else goto c2aa;
       c2ab:
           HpAlloc = 72;
           goto c2a8;
       c2a8:
           R1 = _s24D::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2aa:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _s24D::P32;
           _s24m::I32 = I32[_s24D::P32 + 8];
           I32[Hp - 68] = sat_s24z_info;
           I32[Hp - 60] = _s24m::I32;
           _c28c::P32 = Hp - 68;
           I32[Hp - 56] = :_con_info;
           P32[Hp - 52] = _c28c::P32;
           P32[Hp - 48] = GHC.Types.[]_closure+1;
           _c28z::P32 = Hp - 54;
           I32[Hp - 44] = sat_s24u_info;
           I32[Hp - 36] = _s24m::I32;
           _c28A::P32 = Hp - 44;
           I32[Hp - 32] = :_con_info;
           P32[Hp - 28] = _c28A::P32;
           P32[Hp - 24] = _c28z::P32;
           _c28R::P32 = Hp - 30;
           I32[Hp - 20] = sat_s24p_info;
           I32[Hp - 12] = _s24m::I32;
           _c28S::P32 = Hp - 20;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = _c28S::P32;
           P32[Hp] = _c28R::P32;
           _c2a6::P32 = Hp - 6;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = _c2a6::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 },
 Main.main_go_entry() //  []
         { info_tbl: [(c2ad,
                       label: Main.main_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c2ad:
           _s24m::I32 = I32[(old + 8)];
           goto c284;
       c284:
           if (Sp - <highSp> < SpLim) goto c2ae; else goto c2af;
       c2af:
           Hp = Hp + 36;
           if (Hp > HpLim) goto c2ah; else goto c2ag;
       c2ah:
           HpAlloc = 36;
           goto c2ae;
       c2ae:
           R1 = Main.main_go_closure;
           I32[(old + 8)] = _s24m::I32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       c2ag:
           I32[Hp - 32] = sat_s24G_info;
           I32[Hp - 24] = _s24m::I32;
           _c286::P32 = Hp - 32;
           I32[Hp - 20] = sat_s24D_info;
           I32[Hp - 12] = _s24m::I32;
           _c288::P32 = Hp - 20;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = _c288::P32;
           P32[Hp] = _c286::P32;
           _c2ac::P32 = Hp - 6;
           R1 = _c2ac::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c293:
      _s24G::P32 = R1;
      goto c28X;
  c28X:
      if (Sp - <highSp> < SpLim) goto c294; else goto c295;
  c294:
      R1 = _s24G::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c295:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24G::P32;
      _s24m::I32 = I32[_s24G::P32 + 8];
      _s24E::I32 = _s24m::I32;
      if (_s24E::I32 != 20) goto c291; else goto c292;
  c291:
      _c297::I32 = _s24E::I32 + 1;
      _s24F::I32 = _c297::I32;
      I32[(old + 16)] = _s24F::I32;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
  c292:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c293:
      _s24G::P32 = R1;
      goto c28X;
  c28X:
      if (Sp - <highSp> < SpLim) goto c294; else goto c295;
  c294:
      R1 = _s24G::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c295:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24G::P32;
      _s24m::I32 = I32[_s24G::P32 + 8];
      _s24E::I32 = _s24m::I32;
      if (_s24E::I32 != 20) goto c291; else goto c292;
  c291:
      _c297::I32 = _s24E::I32 + 1;
      _s24F::I32 = _c297::I32;
      I32[(old + 16)] = _s24F::I32;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
  c292:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c293:
      _s24G::P32 = R1;
      goto c28X;
  c28X:
      if (Sp - <highSp> < SpLim) goto c294; else goto c295;
  c294:
      R1 = _s24G::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c295:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24G::P32;
      _s24m::I32 = I32[_s24G::P32 + 8];
      _s24E::I32 = _s24m::I32;
      if (_s24E::I32 != 20) goto c291; else goto c292;
  c291:
      _c297::I32 = _s24E::I32 + 1;
      _s24F::I32 = _c297::I32;
      I32[(old + 16)] = _s24F::I32;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
  c292:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c293:
      _s24G::P32 = R1;
      goto c28X;
  c28X:
      if (Sp - 12 < SpLim) goto c294; else goto c295;
  c294:
      R1 = _s24G::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c295:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _s24G::P32;
      _s24m::I32 = I32[_s24G::P32 + 8];
      _s24E::I32 = _s24m::I32;
      if (_s24E::I32 != 20) goto c291; else goto c292;
  c291:
      _c297::I32 = _s24E::I32 + 1;
      _s24F::I32 = _c297::I32;
      I32[Sp - 12] = _s24F::I32;
      Sp = Sp - 12;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
  c292:
      R1 = []_closure+1;
      Sp = Sp - 8;
      call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c293:
      goto c28X;
  c28X:
      _s24G::P32 = R1;
      if ((Sp + -12) < SpLim) goto c294; else goto c295;
  c294:
      R1 = _s24G::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c295:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _s24G::P32;
      _s24E::I32 = I32[_s24G::P32 + 8];
      if (_s24E::I32 != 20) goto c291; else goto c292;
  c291:
      I32[Sp - 12] = _s24E::I32 + 1;
      Sp = Sp - 12;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
  c292:
      R1 = []_closure+1;
      Sp = Sp - 8;
      call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c28X, {Main.main_go_closure}), (c291, {Main.main_go_closure}),
 (c292, {}), (c293, {Main.main_go_closure}), (c294, {}),
 (c295, {Main.main_go_closure})]



==================== after setInfoTableStackMap ====================
sat_s24G_entry() //  [R1]
        { info_tbl: [(c293,
                      label: sat_s24G_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c293:
          goto c28X;
      c28X:
          _s24G::P32 = R1;
          if ((Sp + -12) < SpLim) goto c294; else goto c295;
      c294:
          R1 = _s24G::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c295:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _s24G::P32;
          _s24E::I32 = I32[_s24G::P32 + 8];
          if (_s24E::I32 != 20) goto c291; else goto c292;
      c291:
          I32[Sp - 12] = _s24E::I32 + 1;
          Sp = Sp - 12;
          call Main.main_go_info() args: 16, res: 0, upd: 12;
      c292:
          R1 = []_closure+1;
          Sp = Sp - 8;
          call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_s24G_entry() //  [R1]
        { info_tbl: [(c28X,
                      label: sat_s24G_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c28X:
          _s24G::P32 = R1;
          if ((Sp + -12) < SpLim) goto c294; else goto c295;
      c294:
          R1 = _s24G::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c295:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _s24G::P32;
          _s24E::I32 = I32[_s24G::P32 + 8];
          if (_s24E::I32 != 20) goto c291; else goto c292;
      c291:
          I32[Sp - 12] = _s24E::I32 + 1;
          Sp = Sp - 12;
          call Main.main_go_info() args: 16, res: 0, upd: 12;
      c292:
          R1 = []_closure+1;
          Sp = Sp - 8;
          call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  c298:
      _s24z::P32 = R1;
      goto c28e;
  c28e:
      if (Sp - <highSp> < SpLim) goto c299; else goto c29q;
  c299:
      R1 = _s24z::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29q:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24z::P32;
      _s24m::I32 = I32[_s24z::P32 + 8];
      _c28g::I32 = 3 + _s24m::I32;
      _s24v::I32 = _c28g::I32;
      _c28j::I32 = %MO_S_Ge_W32(_s24v::I32, _s24m::I32);
      if (_c28j::I32 >= 1) goto c29l; else goto c29e;
  c29l:
      I32[(young<c29k> + 4)] = c29k;
      P32[(young<c29k> + 32)] = lvl_r23V_closure+3;
      P32[(young<c29k> + 28)] = n1_r23X_closure+1;
      I32[(young<c29k> + 24)] = _s24m::I32;
      I32[(young<c29k> + 20)] = _s24v::I32;
      I32[(young<c29k> + 16)] = 20;
      I32[(young<c29k> + 12)] = stg_ap_p_info;
      P32[(young<c29k> + 8)] = xs2_r23U_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29k, args: 32, res: 4, upd: 12;
  c29k:
      _s24y::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24y::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29e:
      I32[(young<c29c> + 4)] = c29c;
      P32[(young<c29c> + 32)] = lvl_r23V_closure+3;
      P32[(young<c29c> + 28)] = n1_r23X_closure+1;
      I32[(young<c29c> + 24)] = _s24m::I32;
      I32[(young<c29c> + 20)] = _s24v::I32;
      I32[(young<c29c> + 16)] = 20;
      I32[(young<c29c> + 12)] = stg_ap_p_info;
      P32[(young<c29c> + 8)] = xs2_r23U_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c29c, args: 32, res: 4, upd: 12;
  c29c:
      _s24x::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24x::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c298:
      _s24z::P32 = R1;
      goto c28e;
  c28e:
      if (Sp - <highSp> < SpLim) goto c299; else goto c29q;
  c299:
      R1 = _s24z::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29q:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24z::P32;
      _s24m::I32 = I32[_s24z::P32 + 8];
      _c28g::I32 = 3 + _s24m::I32;
      _s24v::I32 = _c28g::I32;
      _c28j::I32 = %MO_S_Ge_W32(_s24v::I32, _s24m::I32);
      if (_c28j::I32 >= 1) goto c29l; else goto c29e;
  c29l:
      I32[(young<c29k> + 4)] = c29k;
      P32[(young<c29k> + 32)] = lvl_r23V_closure+3;
      P32[(young<c29k> + 28)] = n1_r23X_closure+1;
      I32[(young<c29k> + 24)] = _s24m::I32;
      I32[(young<c29k> + 20)] = _s24v::I32;
      I32[(young<c29k> + 16)] = 20;
      I32[(young<c29k> + 12)] = stg_ap_p_info;
      P32[(young<c29k> + 8)] = xs2_r23U_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29k, args: 32, res: 4, upd: 12;
  c29k:
      _s24y::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24y::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29e:
      I32[(young<c29c> + 4)] = c29c;
      P32[(young<c29c> + 32)] = lvl_r23V_closure+3;
      P32[(young<c29c> + 28)] = n1_r23X_closure+1;
      I32[(young<c29c> + 24)] = _s24m::I32;
      I32[(young<c29c> + 20)] = _s24v::I32;
      I32[(young<c29c> + 16)] = 20;
      I32[(young<c29c> + 12)] = stg_ap_p_info;
      P32[(young<c29c> + 8)] = xs2_r23U_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c29c, args: 32, res: 4, upd: 12;
  c29c:
      _s24x::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24x::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c298:
      _s24z::P32 = R1;
      goto c28e;
  c28e:
      if (Sp - <highSp> < SpLim) goto c299; else goto c29q;
  c299:
      R1 = _s24z::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29q:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24z::P32;
      _s24m::I32 = I32[_s24z::P32 + 8];
      _c28g::I32 = 3 + _s24m::I32;
      _s24v::I32 = _c28g::I32;
      _c28j::I32 = %MO_S_Ge_W32(_s24v::I32, _s24m::I32);
      if (_c28j::I32 >= 1) goto c29l; else goto c29e;
  c29l:
      I32[(young<c29k> + 4)] = c29k;
      P32[(young<c29k> + 32)] = lvl_r23V_closure+3;
      P32[(young<c29k> + 28)] = n1_r23X_closure+1;
      I32[(young<c29k> + 24)] = _s24m::I32;
      I32[(young<c29k> + 20)] = _s24v::I32;
      I32[(young<c29k> + 16)] = 20;
      I32[(young<c29k> + 12)] = stg_ap_p_info;
      P32[(young<c29k> + 8)] = xs2_r23U_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29k, args: 32, res: 4, upd: 12;
  c29k:
      _s24y::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24y::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29e:
      I32[(young<c29c> + 4)] = c29c;
      P32[(young<c29c> + 32)] = lvl_r23V_closure+3;
      P32[(young<c29c> + 28)] = n1_r23X_closure+1;
      I32[(young<c29c> + 24)] = _s24m::I32;
      I32[(young<c29c> + 20)] = _s24v::I32;
      I32[(young<c29c> + 16)] = 20;
      I32[(young<c29c> + 12)] = stg_ap_p_info;
      P32[(young<c29c> + 8)] = xs2_r23U_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c29c, args: 32, res: 4, upd: 12;
  c29c:
      _s24x::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24x::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c298:
      _s24z::P32 = R1;
      goto c28e;
  c28e:
      if (Sp - 40 < SpLim) goto c299; else goto c29q;
  c299:
      R1 = _s24z::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29q:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _s24z::P32;
      _s24m::I32 = I32[_s24z::P32 + 8];
      _c28g::I32 = 3 + _s24m::I32;
      _s24v::I32 = _c28g::I32;
      _c28j::I32 = %MO_S_Ge_W32(_s24v::I32, _s24m::I32);
      if (_c28j::I32 >= 1) goto c29l; else goto c29e;
  c29l:
      I32[Sp - 12] = c29k;
      P32[Sp - 40] = lvl_r23V_closure+3;
      P32[Sp - 36] = n1_r23X_closure+1;
      I32[Sp - 32] = _s24m::I32;
      I32[Sp - 28] = _s24v::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs2_r23U_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntUpFB_info() returns to c29k, args: 32, res: 4, upd: 12;
  c29k:
      _s24y::P32 = R1;
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = _s24y::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29e:
      I32[Sp - 12] = c29c;
      P32[Sp - 40] = lvl_r23V_closure+3;
      P32[Sp - 36] = n1_r23X_closure+1;
      I32[Sp - 32] = _s24m::I32;
      I32[Sp - 28] = _s24v::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs2_r23U_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntDnFB_info() returns to c29c, args: 32, res: 4, upd: 12;
  c29c:
      _s24x::P32 = R1;
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = _s24x::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c298:
      goto c28e;
  c28e:
      _s24z::P32 = R1;
      if ((Sp + -40) < SpLim) goto c299; else goto c29q;
  c299:
      R1 = _s24z::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29q:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _s24z::P32;
      _s24m::I32 = I32[_s24z::P32 + 8];
      _s24v::I32 = _s24m::I32 + 3;
      if (%MO_S_Ge_W32(_s24v::I32,
                       _s24m::I32)) goto c29l; else goto c29e;
  c29l:
      I32[Sp - 12] = c29k;
      P32[Sp - 40] = lvl_r23V_closure+3;
      P32[Sp - 36] = n1_r23X_closure+1;
      I32[Sp - 32] = _s24m::I32;
      I32[Sp - 28] = _s24v::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs2_r23U_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntUpFB_info() returns to c29k, args: 32, res: 4, upd: 12;
  c29k:
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29e:
      I32[Sp - 12] = c29c;
      P32[Sp - 40] = lvl_r23V_closure+3;
      P32[Sp - 36] = n1_r23X_closure+1;
      I32[Sp - 32] = _s24m::I32;
      I32[Sp - 28] = _s24v::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs2_r23U_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntDnFB_info() returns to c29c, args: 32, res: 4, upd: 12;
  c29c:
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c28e, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c298, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c299, {}),
 (c29c, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29e, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29k, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29l, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29q, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure})]



==================== after setInfoTableStackMap ====================
sat_s24z_entry() //  [R1]
        { info_tbl: [(c298,
                      label: sat_s24z_info
                      rep:HeapRep 1 nonptrs { Thunk }),
                     (c29c,
                      label: block_c29c_info
                      rep:StackRep []),
                     (c29k,
                      label: block_c29k_info
                      rep:StackRep [])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c298:
          goto c28e;
      c28e:
          _s24z::P32 = R1;
          if ((Sp + -40) < SpLim) goto c299; else goto c29q;
      c299:
          R1 = _s24z::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c29q:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _s24z::P32;
          _s24m::I32 = I32[_s24z::P32 + 8];
          _s24v::I32 = _s24m::I32 + 3;
          if (%MO_S_Ge_W32(_s24v::I32,
                           _s24m::I32)) goto c29l; else goto c29e;
      c29l:
          I32[Sp - 12] = c29k;
          P32[Sp - 40] = lvl_r23V_closure+3;
          P32[Sp - 36] = n1_r23X_closure+1;
          I32[Sp - 32] = _s24m::I32;
          I32[Sp - 28] = _s24v::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs2_r23U_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntUpFB_info() returns to c29k, args: 32, res: 4, upd: 12;
      c29k:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
      c29e:
          I32[Sp - 12] = c29c;
          P32[Sp - 40] = lvl_r23V_closure+3;
          P32[Sp - 36] = n1_r23X_closure+1;
          I32[Sp - 32] = _s24m::I32;
          I32[Sp - 28] = _s24v::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs2_r23U_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntDnFB_info() returns to c29c, args: 32, res: 4, upd: 12;
      c29c:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_s24z_entry() //  [R1]
        { info_tbl: [(c28e,
                      label: sat_s24z_info
                      rep:HeapRep 1 nonptrs { Thunk }),
                     (c29c,
                      label: block_c29c_info
                      rep:StackRep []),
                     (c29k,
                      label: block_c29k_info
                      rep:StackRep [])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c28e:
          _s24z::P32 = R1;
          if ((Sp + -40) < SpLim) goto c299; else goto c29q;
      c299:
          R1 = _s24z::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c29q:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _s24z::P32;
          _s24m::I32 = I32[_s24z::P32 + 8];
          _s24v::I32 = _s24m::I32 + 3;
          if (%MO_S_Ge_W32(_s24v::I32,
                           _s24m::I32)) goto c29l; else goto c29e;
      c29l:
          I32[Sp - 12] = c29k;
          P32[Sp - 40] = lvl_r23V_closure+3;
          P32[Sp - 36] = n1_r23X_closure+1;
          I32[Sp - 32] = _s24m::I32;
          I32[Sp - 28] = _s24v::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs2_r23U_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntUpFB_info() returns to c29k, args: 32, res: 4, upd: 12;
      c29k:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
      c29e:
          I32[Sp - 12] = c29c;
          P32[Sp - 40] = lvl_r23V_closure+3;
          P32[Sp - 36] = n1_r23X_closure+1;
          I32[Sp - 32] = _s24m::I32;
          I32[Sp - 28] = _s24v::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs2_r23U_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntDnFB_info() returns to c29c, args: 32, res: 4, upd: 12;
      c29c:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  c29u:
      _s24u::P32 = R1;
      goto c28C;
  c28C:
      if (Sp - <highSp> < SpLim) goto c29v; else goto c29M;
  c29v:
      R1 = _s24u::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29M:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24u::P32;
      _s24m::I32 = I32[_s24u::P32 + 8];
      _c28E::I32 = 2 + _s24m::I32;
      _s24q::I32 = _c28E::I32;
      _c28H::I32 = %MO_S_Ge_W32(_s24q::I32, _s24m::I32);
      if (_c28H::I32 >= 1) goto c29H; else goto c29A;
  c29H:
      I32[(young<c29G> + 4)] = c29G;
      P32[(young<c29G> + 32)] = lvl_r23V_closure+3;
      P32[(young<c29G> + 28)] = n_r23W_closure+1;
      I32[(young<c29G> + 24)] = _s24m::I32;
      I32[(young<c29G> + 20)] = _s24q::I32;
      I32[(young<c29G> + 16)] = 20;
      I32[(young<c29G> + 12)] = stg_ap_p_info;
      P32[(young<c29G> + 8)] = xs1_r23S_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29G, args: 32, res: 4, upd: 12;
  c29G:
      _s24t::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24t::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29A:
      I32[(young<c29y> + 4)] = c29y;
      P32[(young<c29y> + 32)] = lvl_r23V_closure+3;
      P32[(young<c29y> + 28)] = n_r23W_closure+1;
      I32[(young<c29y> + 24)] = _s24m::I32;
      I32[(young<c29y> + 20)] = _s24q::I32;
      I32[(young<c29y> + 16)] = 20;
      I32[(young<c29y> + 12)] = stg_ap_p_info;
      P32[(young<c29y> + 8)] = xs1_r23S_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c29y, args: 32, res: 4, upd: 12;
  c29y:
      _s24s::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24s::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c29u:
      _s24u::P32 = R1;
      goto c28C;
  c28C:
      if (Sp - <highSp> < SpLim) goto c29v; else goto c29M;
  c29v:
      R1 = _s24u::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29M:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24u::P32;
      _s24m::I32 = I32[_s24u::P32 + 8];
      _c28E::I32 = 2 + _s24m::I32;
      _s24q::I32 = _c28E::I32;
      _c28H::I32 = %MO_S_Ge_W32(_s24q::I32, _s24m::I32);
      if (_c28H::I32 >= 1) goto c29H; else goto c29A;
  c29H:
      I32[(young<c29G> + 4)] = c29G;
      P32[(young<c29G> + 32)] = lvl_r23V_closure+3;
      P32[(young<c29G> + 28)] = n_r23W_closure+1;
      I32[(young<c29G> + 24)] = _s24m::I32;
      I32[(young<c29G> + 20)] = _s24q::I32;
      I32[(young<c29G> + 16)] = 20;
      I32[(young<c29G> + 12)] = stg_ap_p_info;
      P32[(young<c29G> + 8)] = xs1_r23S_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29G, args: 32, res: 4, upd: 12;
  c29G:
      _s24t::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24t::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29A:
      I32[(young<c29y> + 4)] = c29y;
      P32[(young<c29y> + 32)] = lvl_r23V_closure+3;
      P32[(young<c29y> + 28)] = n_r23W_closure+1;
      I32[(young<c29y> + 24)] = _s24m::I32;
      I32[(young<c29y> + 20)] = _s24q::I32;
      I32[(young<c29y> + 16)] = 20;
      I32[(young<c29y> + 12)] = stg_ap_p_info;
      P32[(young<c29y> + 8)] = xs1_r23S_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c29y, args: 32, res: 4, upd: 12;
  c29y:
      _s24s::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24s::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c29u:
      _s24u::P32 = R1;
      goto c28C;
  c28C:
      if (Sp - <highSp> < SpLim) goto c29v; else goto c29M;
  c29v:
      R1 = _s24u::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29M:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24u::P32;
      _s24m::I32 = I32[_s24u::P32 + 8];
      _c28E::I32 = 2 + _s24m::I32;
      _s24q::I32 = _c28E::I32;
      _c28H::I32 = %MO_S_Ge_W32(_s24q::I32, _s24m::I32);
      if (_c28H::I32 >= 1) goto c29H; else goto c29A;
  c29H:
      I32[(young<c29G> + 4)] = c29G;
      P32[(young<c29G> + 32)] = lvl_r23V_closure+3;
      P32[(young<c29G> + 28)] = n_r23W_closure+1;
      I32[(young<c29G> + 24)] = _s24m::I32;
      I32[(young<c29G> + 20)] = _s24q::I32;
      I32[(young<c29G> + 16)] = 20;
      I32[(young<c29G> + 12)] = stg_ap_p_info;
      P32[(young<c29G> + 8)] = xs1_r23S_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29G, args: 32, res: 4, upd: 12;
  c29G:
      _s24t::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24t::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29A:
      I32[(young<c29y> + 4)] = c29y;
      P32[(young<c29y> + 32)] = lvl_r23V_closure+3;
      P32[(young<c29y> + 28)] = n_r23W_closure+1;
      I32[(young<c29y> + 24)] = _s24m::I32;
      I32[(young<c29y> + 20)] = _s24q::I32;
      I32[(young<c29y> + 16)] = 20;
      I32[(young<c29y> + 12)] = stg_ap_p_info;
      P32[(young<c29y> + 8)] = xs1_r23S_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c29y, args: 32, res: 4, upd: 12;
  c29y:
      _s24s::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24s::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c29u:
      _s24u::P32 = R1;
      goto c28C;
  c28C:
      if (Sp - 40 < SpLim) goto c29v; else goto c29M;
  c29v:
      R1 = _s24u::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29M:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _s24u::P32;
      _s24m::I32 = I32[_s24u::P32 + 8];
      _c28E::I32 = 2 + _s24m::I32;
      _s24q::I32 = _c28E::I32;
      _c28H::I32 = %MO_S_Ge_W32(_s24q::I32, _s24m::I32);
      if (_c28H::I32 >= 1) goto c29H; else goto c29A;
  c29H:
      I32[Sp - 12] = c29G;
      P32[Sp - 40] = lvl_r23V_closure+3;
      P32[Sp - 36] = n_r23W_closure+1;
      I32[Sp - 32] = _s24m::I32;
      I32[Sp - 28] = _s24q::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs1_r23S_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntUpFB_info() returns to c29G, args: 32, res: 4, upd: 12;
  c29G:
      _s24t::P32 = R1;
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = _s24t::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29A:
      I32[Sp - 12] = c29y;
      P32[Sp - 40] = lvl_r23V_closure+3;
      P32[Sp - 36] = n_r23W_closure+1;
      I32[Sp - 32] = _s24m::I32;
      I32[Sp - 28] = _s24q::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs1_r23S_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntDnFB_info() returns to c29y, args: 32, res: 4, upd: 12;
  c29y:
      _s24s::P32 = R1;
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = _s24s::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c29u:
      goto c28C;
  c28C:
      _s24u::P32 = R1;
      if ((Sp + -40) < SpLim) goto c29v; else goto c29M;
  c29v:
      R1 = _s24u::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29M:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _s24u::P32;
      _s24m::I32 = I32[_s24u::P32 + 8];
      _s24q::I32 = _s24m::I32 + 2;
      if (%MO_S_Ge_W32(_s24q::I32,
                       _s24m::I32)) goto c29H; else goto c29A;
  c29H:
      I32[Sp - 12] = c29G;
      P32[Sp - 40] = lvl_r23V_closure+3;
      P32[Sp - 36] = n_r23W_closure+1;
      I32[Sp - 32] = _s24m::I32;
      I32[Sp - 28] = _s24q::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs1_r23S_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntUpFB_info() returns to c29G, args: 32, res: 4, upd: 12;
  c29G:
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29A:
      I32[Sp - 12] = c29y;
      P32[Sp - 40] = lvl_r23V_closure+3;
      P32[Sp - 36] = n_r23W_closure+1;
      I32[Sp - 32] = _s24m::I32;
      I32[Sp - 28] = _s24q::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs1_r23S_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntDnFB_info() returns to c29y, args: 32, res: 4, upd: 12;
  c29y:
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c28C, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29u, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29v, {}),
 (c29y, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29A, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29G, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29H, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29M, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure})]



==================== after setInfoTableStackMap ====================
sat_s24u_entry() //  [R1]
        { info_tbl: [(c29u,
                      label: sat_s24u_info
                      rep:HeapRep 1 nonptrs { Thunk }),
                     (c29y,
                      label: block_c29y_info
                      rep:StackRep []),
                     (c29G,
                      label: block_c29G_info
                      rep:StackRep [])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c29u:
          goto c28C;
      c28C:
          _s24u::P32 = R1;
          if ((Sp + -40) < SpLim) goto c29v; else goto c29M;
      c29v:
          R1 = _s24u::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c29M:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _s24u::P32;
          _s24m::I32 = I32[_s24u::P32 + 8];
          _s24q::I32 = _s24m::I32 + 2;
          if (%MO_S_Ge_W32(_s24q::I32,
                           _s24m::I32)) goto c29H; else goto c29A;
      c29H:
          I32[Sp - 12] = c29G;
          P32[Sp - 40] = lvl_r23V_closure+3;
          P32[Sp - 36] = n_r23W_closure+1;
          I32[Sp - 32] = _s24m::I32;
          I32[Sp - 28] = _s24q::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs1_r23S_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntUpFB_info() returns to c29G, args: 32, res: 4, upd: 12;
      c29G:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
      c29A:
          I32[Sp - 12] = c29y;
          P32[Sp - 40] = lvl_r23V_closure+3;
          P32[Sp - 36] = n_r23W_closure+1;
          I32[Sp - 32] = _s24m::I32;
          I32[Sp - 28] = _s24q::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs1_r23S_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntDnFB_info() returns to c29y, args: 32, res: 4, upd: 12;
      c29y:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_s24u_entry() //  [R1]
        { info_tbl: [(c28C,
                      label: sat_s24u_info
                      rep:HeapRep 1 nonptrs { Thunk }),
                     (c29y,
                      label: block_c29y_info
                      rep:StackRep []),
                     (c29G,
                      label: block_c29G_info
                      rep:StackRep [])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c28C:
          _s24u::P32 = R1;
          if ((Sp + -40) < SpLim) goto c29v; else goto c29M;
      c29v:
          R1 = _s24u::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c29M:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _s24u::P32;
          _s24m::I32 = I32[_s24u::P32 + 8];
          _s24q::I32 = _s24m::I32 + 2;
          if (%MO_S_Ge_W32(_s24q::I32,
                           _s24m::I32)) goto c29H; else goto c29A;
      c29H:
          I32[Sp - 12] = c29G;
          P32[Sp - 40] = lvl_r23V_closure+3;
          P32[Sp - 36] = n_r23W_closure+1;
          I32[Sp - 32] = _s24m::I32;
          I32[Sp - 28] = _s24q::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs1_r23S_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntUpFB_info() returns to c29G, args: 32, res: 4, upd: 12;
      c29G:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
      c29A:
          I32[Sp - 12] = c29y;
          P32[Sp - 40] = lvl_r23V_closure+3;
          P32[Sp - 36] = n_r23W_closure+1;
          I32[Sp - 32] = _s24m::I32;
          I32[Sp - 28] = _s24q::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs1_r23S_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntDnFB_info() returns to c29y, args: 32, res: 4, upd: 12;
      c29y:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  c29X:
      _s24p::P32 = R1;
      goto c28U;
  c28U:
      if (Sp - <highSp> < SpLim) goto c29Y; else goto c2a5;
  c29Y:
      R1 = _s24p::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a5:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24p::P32;
      _s24m::I32 = I32[_s24p::P32 + 8];
      _c28W::I32 = %MO_S_Gt_W32(_s24m::I32, 20);
      if (_c28W::I32 >= 1) goto c29T; else goto c29S;
  c29T:
      R1 = lvl1_r23Y_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
  c29S:
      I32[(young<c2a0> + 4)] = c2a0;
      I32[(young<c2a0> + 12)] = _s24m::I32;
      P32[(young<c2a0> + 8)] = xs_r23Q_closure+2;
      call go_r23Z_info() returns to c2a0, args: 12, res: 4, upd: 12;
  c2a0:
      _s24o::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24o::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c29X:
      _s24p::P32 = R1;
      goto c28U;
  c28U:
      if (Sp - <highSp> < SpLim) goto c29Y; else goto c2a5;
  c29Y:
      R1 = _s24p::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a5:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24p::P32;
      _s24m::I32 = I32[_s24p::P32 + 8];
      _c28W::I32 = %MO_S_Gt_W32(_s24m::I32, 20);
      if (_c28W::I32 >= 1) goto c29T; else goto c29S;
  c29T:
      R1 = lvl1_r23Y_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
  c29S:
      I32[(young<c2a0> + 4)] = c2a0;
      I32[(young<c2a0> + 12)] = _s24m::I32;
      P32[(young<c2a0> + 8)] = xs_r23Q_closure+2;
      call go_r23Z_info() returns to c2a0, args: 12, res: 4, upd: 12;
  c2a0:
      _s24o::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24o::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c29X:
      _s24p::P32 = R1;
      goto c28U;
  c28U:
      if (Sp - <highSp> < SpLim) goto c29Y; else goto c2a5;
  c29Y:
      R1 = _s24p::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a5:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24p::P32;
      _s24m::I32 = I32[_s24p::P32 + 8];
      _c28W::I32 = %MO_S_Gt_W32(_s24m::I32, 20);
      if (_c28W::I32 >= 1) goto c29T; else goto c29S;
  c29T:
      R1 = lvl1_r23Y_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
  c29S:
      I32[(young<c2a0> + 4)] = c2a0;
      I32[(young<c2a0> + 12)] = _s24m::I32;
      P32[(young<c2a0> + 8)] = xs_r23Q_closure+2;
      call go_r23Z_info() returns to c2a0, args: 12, res: 4, upd: 12;
  c2a0:
      _s24o::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24o::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c29X:
      _s24p::P32 = R1;
      goto c28U;
  c28U:
      if (Sp - 24 < SpLim) goto c29Y; else goto c2a5;
  c29Y:
      R1 = _s24p::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a5:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _s24p::P32;
      _s24m::I32 = I32[_s24p::P32 + 8];
      _c28W::I32 = %MO_S_Gt_W32(_s24m::I32, 20);
      if (_c28W::I32 >= 1) goto c29T; else goto c29S;
  c29T:
      R1 = lvl1_r23Y_closure;
      Sp = Sp - 8;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
  c29S:
      I32[Sp - 12] = c2a0;
      I32[Sp - 20] = _s24m::I32;
      P32[Sp - 16] = xs_r23Q_closure+2;
      Sp = Sp - 20;
      call go_r23Z_info() returns to c2a0, args: 12, res: 4, upd: 12;
  c2a0:
      _s24o::P32 = R1;
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = _s24o::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c29X:
      goto c28U;
  c28U:
      _s24p::P32 = R1;
      if ((Sp + -24) < SpLim) goto c29Y; else goto c2a5;
  c29Y:
      R1 = _s24p::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a5:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _s24p::P32;
      _s24m::I32 = I32[_s24p::P32 + 8];
      if (%MO_S_Gt_W32(_s24m::I32, 20)) goto c29T; else goto c29S;
  c29T:
      R1 = lvl1_r23Y_closure;
      Sp = Sp - 8;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
  c29S:
      I32[Sp - 12] = c2a0;
      I32[Sp - 20] = _s24m::I32;
      P32[Sp - 16] = xs_r23Q_closure+2;
      Sp = Sp - 20;
      call go_r23Z_info() returns to c2a0, args: 12, res: 4, upd: 12;
  c2a0:
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c28U,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   lvl1_r23Y_closure}),
 (c29S, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29T, {lvl1_r23Y_closure}),
 (c29X,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   lvl1_r23Y_closure}),
 (c29Y, {}),
 (c2a0, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c2a5,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   lvl1_r23Y_closure})]



==================== after setInfoTableStackMap ====================
sat_s24p_entry() //  [R1]
        { info_tbl: [(c29X,
                      label: sat_s24p_info
                      rep:HeapRep 1 nonptrs { Thunk }),
                     (c2a0,
                      label: block_c2a0_info
                      rep:StackRep [])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c29X:
          goto c28U;
      c28U:
          _s24p::P32 = R1;
          if ((Sp + -24) < SpLim) goto c29Y; else goto c2a5;
      c29Y:
          R1 = _s24p::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2a5:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _s24p::P32;
          _s24m::I32 = I32[_s24p::P32 + 8];
          if (%MO_S_Gt_W32(_s24m::I32, 20)) goto c29T; else goto c29S;
      c29T:
          R1 = lvl1_r23Y_closure;
          Sp = Sp - 8;
          call (I32[R1])(R1) args: 12, res: 0, upd: 12;
      c29S:
          I32[Sp - 12] = c2a0;
          I32[Sp - 20] = _s24m::I32;
          P32[Sp - 16] = xs_r23Q_closure+2;
          Sp = Sp - 20;
          call go_r23Z_info() returns to c2a0, args: 12, res: 4, upd: 12;
      c2a0:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_s24p_entry() //  [R1]
        { info_tbl: [(c28U,
                      label: sat_s24p_info
                      rep:HeapRep 1 nonptrs { Thunk }),
                     (c2a0,
                      label: block_c2a0_info
                      rep:StackRep [])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c28U:
          _s24p::P32 = R1;
          if ((Sp + -24) < SpLim) goto c29Y; else goto c2a5;
      c29Y:
          R1 = _s24p::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2a5:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _s24p::P32;
          _s24m::I32 = I32[_s24p::P32 + 8];
          if (%MO_S_Gt_W32(_s24m::I32, 20)) goto c29T; else goto c29S;
      c29T:
          R1 = lvl1_r23Y_closure;
          Sp = Sp - 8;
          call (I32[R1])(R1) args: 12, res: 0, upd: 12;
      c29S:
          I32[Sp - 12] = c2a0;
          I32[Sp - 20] = _s24m::I32;
          P32[Sp - 16] = xs_r23Q_closure+2;
          Sp = Sp - 20;
          call go_r23Z_info() returns to c2a0, args: 12, res: 4, upd: 12;
      c2a0:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  c2a7:
      _s24D::P32 = R1;
      goto c28a;
  c28a:
      if (Sp - <highSp> < SpLim) goto c2a8; else goto c2a9;
  c2a9:
      Hp = Hp + 72;
      if (Hp > HpLim) goto c2ab; else goto c2aa;
  c2ab:
      HpAlloc = 72;
      goto c2a8;
  c2a8:
      R1 = _s24D::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aa:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24D::P32;
      _s24m::I32 = I32[_s24D::P32 + 8];
      I32[Hp - 68] = sat_s24z_info;
      I32[Hp - 60] = _s24m::I32;
      _c28c::P32 = Hp - 68;
      I32[Hp - 56] = :_con_info;
      P32[Hp - 52] = _c28c::P32;
      P32[Hp - 48] = GHC.Types.[]_closure+1;
      _c28z::P32 = Hp - 54;
      I32[Hp - 44] = sat_s24u_info;
      I32[Hp - 36] = _s24m::I32;
      _c28A::P32 = Hp - 44;
      I32[Hp - 32] = :_con_info;
      P32[Hp - 28] = _c28A::P32;
      P32[Hp - 24] = _c28z::P32;
      _c28R::P32 = Hp - 30;
      I32[Hp - 20] = sat_s24p_info;
      I32[Hp - 12] = _s24m::I32;
      _c28S::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c28S::P32;
      P32[Hp] = _c28R::P32;
      _c2a6::P32 = Hp - 6;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _c2a6::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c2a7:
      _s24D::P32 = R1;
      goto c28a;
  c28a:
      if (Sp - <highSp> < SpLim) goto c2a8; else goto c2a9;
  c2a9:
      Hp = Hp + 72;
      if (Hp > HpLim) goto c2ab; else goto c2aa;
  c2ab:
      HpAlloc = 72;
      goto c2a8;
  c2a8:
      R1 = _s24D::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aa:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24D::P32;
      _s24m::I32 = I32[_s24D::P32 + 8];
      I32[Hp - 68] = sat_s24z_info;
      I32[Hp - 60] = _s24m::I32;
      _c28c::P32 = Hp - 68;
      I32[Hp - 56] = :_con_info;
      P32[Hp - 52] = _c28c::P32;
      P32[Hp - 48] = GHC.Types.[]_closure+1;
      _c28z::P32 = Hp - 54;
      I32[Hp - 44] = sat_s24u_info;
      I32[Hp - 36] = _s24m::I32;
      _c28A::P32 = Hp - 44;
      I32[Hp - 32] = :_con_info;
      P32[Hp - 28] = _c28A::P32;
      P32[Hp - 24] = _c28z::P32;
      _c28R::P32 = Hp - 30;
      I32[Hp - 20] = sat_s24p_info;
      I32[Hp - 12] = _s24m::I32;
      _c28S::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c28S::P32;
      P32[Hp] = _c28R::P32;
      _c2a6::P32 = Hp - 6;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _c2a6::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c2a7:
      _s24D::P32 = R1;
      goto c28a;
  c28a:
      if (Sp - <highSp> < SpLim) goto c2a8; else goto c2a9;
  c2a9:
      Hp = Hp + 72;
      if (Hp > HpLim) goto c2ab; else goto c2aa;
  c2ab:
      HpAlloc = 72;
      goto c2a8;
  c2a8:
      R1 = _s24D::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aa:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24D::P32;
      _s24m::I32 = I32[_s24D::P32 + 8];
      I32[Hp - 68] = sat_s24z_info;
      I32[Hp - 60] = _s24m::I32;
      _c28c::P32 = Hp - 68;
      I32[Hp - 56] = :_con_info;
      P32[Hp - 52] = _c28c::P32;
      P32[Hp - 48] = GHC.Types.[]_closure+1;
      _c28z::P32 = Hp - 54;
      I32[Hp - 44] = sat_s24u_info;
      I32[Hp - 36] = _s24m::I32;
      _c28A::P32 = Hp - 44;
      I32[Hp - 32] = :_con_info;
      P32[Hp - 28] = _c28A::P32;
      P32[Hp - 24] = _c28z::P32;
      _c28R::P32 = Hp - 30;
      I32[Hp - 20] = sat_s24p_info;
      I32[Hp - 12] = _s24m::I32;
      _c28S::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c28S::P32;
      P32[Hp] = _c28R::P32;
      _c2a6::P32 = Hp - 6;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _c2a6::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c2a7:
      _s24D::P32 = R1;
      goto c28a;
  c28a:
      if (Sp - 24 < SpLim) goto c2a8; else goto c2a9;
  c2a9:
      Hp = Hp + 72;
      if (Hp > HpLim) goto c2ab; else goto c2aa;
  c2ab:
      HpAlloc = 72;
      goto c2a8;
  c2a8:
      R1 = _s24D::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aa:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _s24D::P32;
      _s24m::I32 = I32[_s24D::P32 + 8];
      I32[Hp - 68] = sat_s24z_info;
      I32[Hp - 60] = _s24m::I32;
      _c28c::P32 = Hp - 68;
      I32[Hp - 56] = :_con_info;
      P32[Hp - 52] = _c28c::P32;
      P32[Hp - 48] = GHC.Types.[]_closure+1;
      _c28z::P32 = Hp - 54;
      I32[Hp - 44] = sat_s24u_info;
      I32[Hp - 36] = _s24m::I32;
      _c28A::P32 = Hp - 44;
      I32[Hp - 32] = :_con_info;
      P32[Hp - 28] = _c28A::P32;
      P32[Hp - 24] = _c28z::P32;
      _c28R::P32 = Hp - 30;
      I32[Hp - 20] = sat_s24p_info;
      I32[Hp - 12] = _s24m::I32;
      _c28S::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c28S::P32;
      P32[Hp] = _c28R::P32;
      _c2a6::P32 = Hp - 6;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = _c2a6::P32;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c2a7:
      goto c28a;
  c28a:
      _s24D::P32 = R1;
      if ((Sp + -24) < SpLim) goto c2a8; else goto c2a9;
  c2a9:
      Hp = Hp + 72;
      if (Hp > HpLim) goto c2ab; else goto c2aa;
  c2ab:
      HpAlloc = 72;
      goto c2a8;
  c2a8:
      R1 = _s24D::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aa:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = _s24D::P32;
      _s24m::I32 = I32[_s24D::P32 + 8];
      I32[Hp - 68] = sat_s24z_info;
      I32[Hp - 60] = _s24m::I32;
      I32[Hp - 56] = :_con_info;
      P32[Hp - 52] = Hp - 68;
      P32[Hp - 48] = GHC.Types.[]_closure+1;
      I32[Hp - 44] = sat_s24u_info;
      I32[Hp - 36] = _s24m::I32;
      I32[Hp - 32] = :_con_info;
      P32[Hp - 28] = Hp - 44;
      P32[Hp - 24] = Hp - 54;
      I32[Hp - 20] = sat_s24p_info;
      I32[Hp - 12] = _s24m::I32;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = Hp - 20;
      P32[Hp] = Hp - 30;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = Hp - 6;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c28a,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure, sat_s24p_closure,
   sat_s24u_closure, sat_s24z_closure}),
 (c2a7,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure, sat_s24p_closure,
   sat_s24u_closure, sat_s24z_closure}),
 (c2a8, {}),
 (c2a9,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure, sat_s24p_closure,
   sat_s24u_closure, sat_s24z_closure}),
 (c2aa,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure, sat_s24p_closure,
   sat_s24u_closure, sat_s24z_closure}),
 (c2ab, {})]



==================== after setInfoTableStackMap ====================
sat_s24D_entry() //  [R1]
        { info_tbl: [(c2a7,
                      label: sat_s24D_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2a7:
          goto c28a;
      c28a:
          _s24D::P32 = R1;
          if ((Sp + -24) < SpLim) goto c2a8; else goto c2a9;
      c2a9:
          Hp = Hp + 72;
          if (Hp > HpLim) goto c2ab; else goto c2aa;
      c2ab:
          HpAlloc = 72;
          goto c2a8;
      c2a8:
          R1 = _s24D::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2aa:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _s24D::P32;
          _s24m::I32 = I32[_s24D::P32 + 8];
          I32[Hp - 68] = sat_s24z_info;
          I32[Hp - 60] = _s24m::I32;
          I32[Hp - 56] = :_con_info;
          P32[Hp - 52] = Hp - 68;
          P32[Hp - 48] = GHC.Types.[]_closure+1;
          I32[Hp - 44] = sat_s24u_info;
          I32[Hp - 36] = _s24m::I32;
          I32[Hp - 32] = :_con_info;
          P32[Hp - 28] = Hp - 44;
          P32[Hp - 24] = Hp - 54;
          I32[Hp - 20] = sat_s24p_info;
          I32[Hp - 12] = _s24m::I32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 20;
          P32[Hp] = Hp - 30;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = Hp - 6;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_s24D_entry() //  [R1]
        { info_tbl: [(c28a,
                      label: sat_s24D_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c28a:
          _s24D::P32 = R1;
          if ((Sp + -24) < SpLim) goto c2a8; else goto c2a9;
      c2a9:
          Hp = Hp + 72;
          if (Hp > HpLim) goto c2ab; else goto c2aa;
      c2ab:
          HpAlloc = 72;
          goto c2a8;
      c2a8:
          R1 = _s24D::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2aa:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = _s24D::P32;
          _s24m::I32 = I32[_s24D::P32 + 8];
          I32[Hp - 68] = sat_s24z_info;
          I32[Hp - 60] = _s24m::I32;
          I32[Hp - 56] = :_con_info;
          P32[Hp - 52] = Hp - 68;
          P32[Hp - 48] = GHC.Types.[]_closure+1;
          I32[Hp - 44] = sat_s24u_info;
          I32[Hp - 36] = _s24m::I32;
          I32[Hp - 32] = :_con_info;
          P32[Hp - 28] = Hp - 44;
          P32[Hp - 24] = Hp - 54;
          I32[Hp - 20] = sat_s24p_info;
          I32[Hp - 12] = _s24m::I32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 20;
          P32[Hp] = Hp - 30;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = Hp - 6;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  c2ad:
      _s24m::I32 = I32[(old + 8)];
      goto c284;
  c284:
      if (Sp - <highSp> < SpLim) goto c2ae; else goto c2af;
  c2af:
      Hp = Hp + 36;
      if (Hp > HpLim) goto c2ah; else goto c2ag;
  c2ah:
      HpAlloc = 36;
      goto c2ae;
  c2ae:
      R1 = Main.main_go_closure;
      I32[(old + 8)] = _s24m::I32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2ag:
      I32[Hp - 32] = sat_s24G_info;
      I32[Hp - 24] = _s24m::I32;
      _c286::P32 = Hp - 32;
      I32[Hp - 20] = sat_s24D_info;
      I32[Hp - 12] = _s24m::I32;
      _c288::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c288::P32;
      P32[Hp] = _c286::P32;
      _c2ac::P32 = Hp - 6;
      R1 = _c2ac::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c2ad:
      _s24m::I32 = I32[(old + 8)];
      goto c284;
  c284:
      if (Sp - <highSp> < SpLim) goto c2ae; else goto c2af;
  c2af:
      Hp = Hp + 36;
      if (Hp > HpLim) goto c2ah; else goto c2ag;
  c2ah:
      HpAlloc = 36;
      goto c2ae;
  c2ae:
      R1 = Main.main_go_closure;
      I32[(old + 8)] = _s24m::I32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2ag:
      I32[Hp - 32] = sat_s24G_info;
      I32[Hp - 24] = _s24m::I32;
      _c286::P32 = Hp - 32;
      I32[Hp - 20] = sat_s24D_info;
      I32[Hp - 12] = _s24m::I32;
      _c288::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c288::P32;
      P32[Hp] = _c286::P32;
      _c2ac::P32 = Hp - 6;
      R1 = _c2ac::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c2ad:
      _s24m::I32 = I32[(old + 8)];
      goto c284;
  c284:
      if (Sp - <highSp> < SpLim) goto c2ae; else goto c2af;
  c2af:
      Hp = Hp + 36;
      if (Hp > HpLim) goto c2ah; else goto c2ag;
  c2ah:
      HpAlloc = 36;
      goto c2ae;
  c2ae:
      R1 = Main.main_go_closure;
      I32[(old + 8)] = _s24m::I32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2ag:
      I32[Hp - 32] = sat_s24G_info;
      I32[Hp - 24] = _s24m::I32;
      _c286::P32 = Hp - 32;
      I32[Hp - 20] = sat_s24D_info;
      I32[Hp - 12] = _s24m::I32;
      _c288::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c288::P32;
      P32[Hp] = _c286::P32;
      _c2ac::P32 = Hp - 6;
      R1 = _c2ac::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c2ad:
      _s24m::I32 = I32[Sp];
      goto c284;
  c284:
      goto c2af;
  c2af:
      Hp = Hp + 36;
      if (Hp > HpLim) goto c2ah; else goto c2ag;
  c2ah:
      HpAlloc = 36;
      goto c2ae;
  c2ae:
      R1 = Main.main_go_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2ag:
      I32[Hp - 32] = sat_s24G_info;
      I32[Hp - 24] = _s24m::I32;
      _c286::P32 = Hp - 32;
      I32[Hp - 20] = sat_s24D_info;
      I32[Hp - 12] = _s24m::I32;
      _c288::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c288::P32;
      P32[Hp] = _c286::P32;
      _c2ac::P32 = Hp - 6;
      R1 = _c2ac::P32;
      Sp = Sp + 4;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c2ad:
      goto c284;
  c284:
      goto c2af;
  c2af:
      Hp = Hp + 36;
      if (Hp > HpLim) goto c2ah; else goto c2ag;
  c2ah:
      HpAlloc = 36;
      goto c2ae;
  c2ae:
      R1 = Main.main_go_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2ag:
      I32[Hp - 32] = sat_s24G_info;
      _s24m::I32 = I32[Sp];
      I32[Hp - 24] = _s24m::I32;
      I32[Hp - 20] = sat_s24D_info;
      I32[Hp - 12] = _s24m::I32;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = Hp - 20;
      P32[Hp] = Hp - 32;
      R1 = Hp - 6;
      Sp = Sp + 4;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c284,
  {Main.main_go_closure, sat_s24D_closure, sat_s24G_closure}),
 (c2ad, {Main.main_go_closure, sat_s24D_closure, sat_s24G_closure}),
 (c2ae, {Main.main_go_closure}),
 (c2af, {Main.main_go_closure, sat_s24D_closure, sat_s24G_closure}),
 (c2ag, {sat_s24D_closure, sat_s24G_closure}),
 (c2ah, {Main.main_go_closure})]



==================== after setInfoTableStackMap ====================
Main.main_go_entry() //  []
        { info_tbl: [(c2ad,
                      label: Main.main_go_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      c2ad:
          goto c284;
      c284:
          goto c2af;
      c2af:
          Hp = Hp + 36;
          if (Hp > HpLim) goto c2ah; else goto c2ag;
      c2ah:
          HpAlloc = 36;
          goto c2ae;
      c2ae:
          R1 = Main.main_go_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      c2ag:
          I32[Hp - 32] = sat_s24G_info;
          _s24m::I32 = I32[Sp];
          I32[Hp - 24] = _s24m::I32;
          I32[Hp - 20] = sat_s24D_info;
          I32[Hp - 12] = _s24m::I32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 20;
          P32[Hp] = Hp - 32;
          R1 = Hp - 6;
          Sp = Sp + 4;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
Main.main_go_entry() //  []
        { info_tbl: [(c2af,
                      label: Main.main_go_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      c2af:
          Hp = Hp + 36;
          if (Hp > HpLim) goto c2ah; else goto c2ag;
      c2ah:
          HpAlloc = 36;
          goto c2ae;
      c2ae:
          R1 = Main.main_go_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      c2ag:
          I32[Hp - 32] = sat_s24G_info;
          _s24m::I32 = I32[Sp];
          I32[Hp - 24] = _s24m::I32;
          I32[Hp - 20] = sat_s24D_info;
          I32[Hp - 12] = _s24m::I32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 20;
          P32[Hp] = Hp - 32;
          R1 = Hp - 6;
          Sp = Sp + 4;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main_go_closure:
         const Main.main_go_info;
         const 0;
 },
 sat_s24G_entry() //  [R1]
         { info_tbl: [(c28X,
                       label: sat_s24G_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28X:
           _s24G::P32 = R1;
           if ((Sp + -12) < SpLim) goto c294; else goto c295;
       c294:
           R1 = _s24G::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c295:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _s24G::P32;
           _s24E::I32 = I32[_s24G::P32 + 8];
           if (_s24E::I32 != 20) goto c291; else goto c292;
       c291:
           I32[Sp - 12] = _s24E::I32 + 1;
           Sp = Sp - 12;
           call Main.main_go_info() args: 16, res: 0, upd: 12;
       c292:
           R1 = []_closure+1;
           Sp = Sp - 8;
           call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
     }
 },
 sat_s24z_entry() //  [R1]
         { info_tbl: [(c28e,
                       label: sat_s24z_info
                       rep:HeapRep 1 nonptrs { Thunk }),
                      (c29c,
                       label: block_c29c_info
                       rep:StackRep []),
                      (c29k,
                       label: block_c29k_info
                       rep:StackRep [])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28e:
           _s24z::P32 = R1;
           if ((Sp + -40) < SpLim) goto c299; else goto c29q;
       c299:
           R1 = _s24z::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c29q:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _s24z::P32;
           _s24m::I32 = I32[_s24z::P32 + 8];
           _s24v::I32 = _s24m::I32 + 3;
           if (%MO_S_Ge_W32(_s24v::I32,
                            _s24m::I32)) goto c29l; else goto c29e;
       c29l:
           I32[Sp - 12] = c29k;
           P32[Sp - 40] = lvl_r23V_closure+3;
           P32[Sp - 36] = n1_r23X_closure+1;
           I32[Sp - 32] = _s24m::I32;
           I32[Sp - 28] = _s24v::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs2_r23U_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntUpFB_info() returns to c29k, args: 32, res: 4, upd: 12;
       c29k:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
       c29e:
           I32[Sp - 12] = c29c;
           P32[Sp - 40] = lvl_r23V_closure+3;
           P32[Sp - 36] = n1_r23X_closure+1;
           I32[Sp - 32] = _s24m::I32;
           I32[Sp - 28] = _s24v::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs2_r23U_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntDnFB_info() returns to c29c, args: 32, res: 4, upd: 12;
       c29c:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24u_entry() //  [R1]
         { info_tbl: [(c28C,
                       label: sat_s24u_info
                       rep:HeapRep 1 nonptrs { Thunk }),
                      (c29y,
                       label: block_c29y_info
                       rep:StackRep []),
                      (c29G,
                       label: block_c29G_info
                       rep:StackRep [])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28C:
           _s24u::P32 = R1;
           if ((Sp + -40) < SpLim) goto c29v; else goto c29M;
       c29v:
           R1 = _s24u::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c29M:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _s24u::P32;
           _s24m::I32 = I32[_s24u::P32 + 8];
           _s24q::I32 = _s24m::I32 + 2;
           if (%MO_S_Ge_W32(_s24q::I32,
                            _s24m::I32)) goto c29H; else goto c29A;
       c29H:
           I32[Sp - 12] = c29G;
           P32[Sp - 40] = lvl_r23V_closure+3;
           P32[Sp - 36] = n_r23W_closure+1;
           I32[Sp - 32] = _s24m::I32;
           I32[Sp - 28] = _s24q::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs1_r23S_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntUpFB_info() returns to c29G, args: 32, res: 4, upd: 12;
       c29G:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
       c29A:
           I32[Sp - 12] = c29y;
           P32[Sp - 40] = lvl_r23V_closure+3;
           P32[Sp - 36] = n_r23W_closure+1;
           I32[Sp - 32] = _s24m::I32;
           I32[Sp - 28] = _s24q::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs1_r23S_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntDnFB_info() returns to c29y, args: 32, res: 4, upd: 12;
       c29y:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24p_entry() //  [R1]
         { info_tbl: [(c28U,
                       label: sat_s24p_info
                       rep:HeapRep 1 nonptrs { Thunk }),
                      (c2a0,
                       label: block_c2a0_info
                       rep:StackRep [])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28U:
           _s24p::P32 = R1;
           if ((Sp + -24) < SpLim) goto c29Y; else goto c2a5;
       c29Y:
           R1 = _s24p::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2a5:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _s24p::P32;
           _s24m::I32 = I32[_s24p::P32 + 8];
           if (%MO_S_Gt_W32(_s24m::I32, 20)) goto c29T; else goto c29S;
       c29T:
           R1 = lvl1_r23Y_closure;
           Sp = Sp - 8;
           call (I32[R1])(R1) args: 12, res: 0, upd: 12;
       c29S:
           I32[Sp - 12] = c2a0;
           I32[Sp - 20] = _s24m::I32;
           P32[Sp - 16] = xs_r23Q_closure+2;
           Sp = Sp - 20;
           call go_r23Z_info() returns to c2a0, args: 12, res: 4, upd: 12;
       c2a0:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24D_entry() //  [R1]
         { info_tbl: [(c28a,
                       label: sat_s24D_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28a:
           _s24D::P32 = R1;
           if ((Sp + -24) < SpLim) goto c2a8; else goto c2a9;
       c2a9:
           Hp = Hp + 72;
           if (Hp > HpLim) goto c2ab; else goto c2aa;
       c2ab:
           HpAlloc = 72;
           goto c2a8;
       c2a8:
           R1 = _s24D::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2aa:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _s24D::P32;
           _s24m::I32 = I32[_s24D::P32 + 8];
           I32[Hp - 68] = sat_s24z_info;
           I32[Hp - 60] = _s24m::I32;
           I32[Hp - 56] = :_con_info;
           P32[Hp - 52] = Hp - 68;
           P32[Hp - 48] = GHC.Types.[]_closure+1;
           I32[Hp - 44] = sat_s24u_info;
           I32[Hp - 36] = _s24m::I32;
           I32[Hp - 32] = :_con_info;
           P32[Hp - 28] = Hp - 44;
           P32[Hp - 24] = Hp - 54;
           I32[Hp - 20] = sat_s24p_info;
           I32[Hp - 12] = _s24m::I32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 20;
           P32[Hp] = Hp - 30;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = Hp - 6;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 },
 Main.main_go_entry() //  []
         { info_tbl: [(c2af,
                       label: Main.main_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c2af:
           Hp = Hp + 36;
           if (Hp > HpLim) goto c2ah; else goto c2ag;
       c2ah:
           HpAlloc = 36;
           goto c2ae;
       c2ae:
           R1 = Main.main_go_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       c2ag:
           I32[Hp - 32] = sat_s24G_info;
           _s24m::I32 = I32[Sp];
           I32[Hp - 24] = _s24m::I32;
           I32[Hp - 20] = sat_s24D_info;
           I32[Hp - 12] = _s24m::I32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 20;
           P32[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 4;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main_go_closure:
         const Main.main_go_info;
         const 0;
 },
 sat_s24G_entry() //  [R1]
         { info_tbl: [(c28X,
                       label: sat_s24G_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28X:
           _s24G::P32 = R1;
           if ((Sp + -12) < SpLim) goto c294; else goto c295;
       c294:
           R1 = _s24G::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c295:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _s24G::P32;
           _s24E::I32 = I32[_s24G::P32 + 8];
           if (_s24E::I32 != 20) goto c291; else goto c292;
       c291:
           I32[Sp - 12] = _s24E::I32 + 1;
           Sp = Sp - 12;
           call Main.main_go_info() args: 16, res: 0, upd: 12;
       c292:
           R1 = []_closure+1;
           Sp = Sp - 8;
           call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
     }
 },
 sat_s24z_entry() //  [R1]
         { info_tbl: [(c28e,
                       label: sat_s24z_info
                       rep:HeapRep 1 nonptrs { Thunk }),
                      (c29c,
                       label: block_c29c_info
                       rep:StackRep []),
                      (c29k,
                       label: block_c29k_info
                       rep:StackRep [])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28e:
           _s24z::P32 = R1;
           if ((Sp + -40) < SpLim) goto c299; else goto c29q;
       c299:
           R1 = _s24z::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c29q:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _s24z::P32;
           _s24m::I32 = I32[_s24z::P32 + 8];
           _s24v::I32 = _s24m::I32 + 3;
           if (%MO_S_Ge_W32(_s24v::I32,
                            _s24m::I32)) goto c29l; else goto c29e;
       c29l:
           I32[Sp - 12] = c29k;
           P32[Sp - 40] = lvl_r23V_closure+3;
           P32[Sp - 36] = n1_r23X_closure+1;
           I32[Sp - 32] = _s24m::I32;
           I32[Sp - 28] = _s24v::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs2_r23U_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntUpFB_info() returns to c29k, args: 32, res: 4, upd: 12;
       c29k:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
       c29e:
           I32[Sp - 12] = c29c;
           P32[Sp - 40] = lvl_r23V_closure+3;
           P32[Sp - 36] = n1_r23X_closure+1;
           I32[Sp - 32] = _s24m::I32;
           I32[Sp - 28] = _s24v::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs2_r23U_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntDnFB_info() returns to c29c, args: 32, res: 4, upd: 12;
       c29c:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24u_entry() //  [R1]
         { info_tbl: [(c28C,
                       label: sat_s24u_info
                       rep:HeapRep 1 nonptrs { Thunk }),
                      (c29y,
                       label: block_c29y_info
                       rep:StackRep []),
                      (c29G,
                       label: block_c29G_info
                       rep:StackRep [])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28C:
           _s24u::P32 = R1;
           if ((Sp + -40) < SpLim) goto c29v; else goto c29M;
       c29v:
           R1 = _s24u::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c29M:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _s24u::P32;
           _s24m::I32 = I32[_s24u::P32 + 8];
           _s24q::I32 = _s24m::I32 + 2;
           if (%MO_S_Ge_W32(_s24q::I32,
                            _s24m::I32)) goto c29H; else goto c29A;
       c29H:
           I32[Sp - 12] = c29G;
           P32[Sp - 40] = lvl_r23V_closure+3;
           P32[Sp - 36] = n_r23W_closure+1;
           I32[Sp - 32] = _s24m::I32;
           I32[Sp - 28] = _s24q::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs1_r23S_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntUpFB_info() returns to c29G, args: 32, res: 4, upd: 12;
       c29G:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
       c29A:
           I32[Sp - 12] = c29y;
           P32[Sp - 40] = lvl_r23V_closure+3;
           P32[Sp - 36] = n_r23W_closure+1;
           I32[Sp - 32] = _s24m::I32;
           I32[Sp - 28] = _s24q::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs1_r23S_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntDnFB_info() returns to c29y, args: 32, res: 4, upd: 12;
       c29y:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24p_entry() //  [R1]
         { info_tbl: [(c28U,
                       label: sat_s24p_info
                       rep:HeapRep 1 nonptrs { Thunk }),
                      (c2a0,
                       label: block_c2a0_info
                       rep:StackRep [])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28U:
           _s24p::P32 = R1;
           if ((Sp + -24) < SpLim) goto c29Y; else goto c2a5;
       c29Y:
           R1 = _s24p::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2a5:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _s24p::P32;
           _s24m::I32 = I32[_s24p::P32 + 8];
           if (%MO_S_Gt_W32(_s24m::I32, 20)) goto c29T; else goto c29S;
       c29T:
           R1 = lvl1_r23Y_closure;
           Sp = Sp - 8;
           call (I32[R1])(R1) args: 12, res: 0, upd: 12;
       c29S:
           I32[Sp - 12] = c2a0;
           I32[Sp - 20] = _s24m::I32;
           P32[Sp - 16] = xs_r23Q_closure+2;
           Sp = Sp - 20;
           call go_r23Z_info() returns to c2a0, args: 12, res: 4, upd: 12;
       c2a0:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24D_entry() //  [R1]
         { info_tbl: [(c28a,
                       label: sat_s24D_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28a:
           _s24D::P32 = R1;
           if ((Sp + -24) < SpLim) goto c2a8; else goto c2a9;
       c2a9:
           Hp = Hp + 72;
           if (Hp > HpLim) goto c2ab; else goto c2aa;
       c2ab:
           HpAlloc = 72;
           goto c2a8;
       c2a8:
           R1 = _s24D::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2aa:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = _s24D::P32;
           _s24m::I32 = I32[_s24D::P32 + 8];
           I32[Hp - 68] = sat_s24z_info;
           I32[Hp - 60] = _s24m::I32;
           I32[Hp - 56] = :_con_info;
           P32[Hp - 52] = Hp - 68;
           P32[Hp - 48] = GHC.Types.[]_closure+1;
           I32[Hp - 44] = sat_s24u_info;
           I32[Hp - 36] = _s24m::I32;
           I32[Hp - 32] = :_con_info;
           P32[Hp - 28] = Hp - 44;
           P32[Hp - 24] = Hp - 54;
           I32[Hp - 20] = sat_s24p_info;
           I32[Hp - 12] = _s24m::I32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 20;
           P32[Hp] = Hp - 30;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = Hp - 6;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 },
 Main.main_go_entry() //  []
         { info_tbl: [(c2af,
                       label: Main.main_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c2af:
           Hp = Hp + 36;
           if (Hp > HpLim) goto c2ah; else goto c2ag;
       c2ah:
           HpAlloc = 36;
           goto c2ae;
       c2ae:
           R1 = Main.main_go_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       c2ag:
           I32[Hp - 32] = sat_s24G_info;
           _s24m::I32 = I32[Sp];
           I32[Hp - 24] = _s24m::I32;
           I32[Hp - 20] = sat_s24D_info;
           I32[Hp - 12] = _s24m::I32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 20;
           P32[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 4;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main6_closure:
         const Main.main6_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main6_entry() //  [R1]
         { info_tbl: [(c2aR,
                       label: Main.main6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2aR:
           _rT5::P32 = R1;
           goto c2aM;
       c2aM:
           if (Sp - <highSp> < SpLim) goto c2aS; else goto c2aT;
       c2aT:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2aV; else goto c2aU;
       c2aV:
           HpAlloc = 8;
           goto c2aS;
       c2aS:
           R1 = _rT5::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2aU:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2aO::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT5::P32, Hp - 4);
           if (_c2aO::I32 == 0) goto c2aQ; else goto c2aP;
       c2aQ:
           call (I32[_rT5::P32])() args: 4, res: 0, upd: 4;
       c2aP:
           I32[(old + 12)] = stg_bh_upd_frame_info;
           P32[(old + 8)] = Hp - 4;
           I32[(old + 16)] = 1;
           call Main.main_go_info() args: 16, res: 0, upd: 12;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2aR:
      _rT5::P32 = R1;
      goto c2aM;
  c2aM:
      if (Sp - <highSp> < SpLim) goto c2aS; else goto c2aT;
  c2aT:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2aV; else goto c2aU;
  c2aV:
      HpAlloc = 8;
      goto c2aS;
  c2aS:
      R1 = _rT5::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aU:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2aO::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT5::P32, Hp - 4);
      if (_c2aO::I32 == 0) goto c2aQ; else goto c2aP;
  c2aQ:
      call (I32[_rT5::P32])() args: 4, res: 0, upd: 4;
  c2aP:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = 1;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c2aR:
      _rT5::P32 = R1;
      goto c2aM;
  c2aM:
      if (Sp - <highSp> < SpLim) goto c2aS; else goto c2aT;
  c2aT:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2aV; else goto c2aU;
  c2aV:
      HpAlloc = 8;
      goto c2aS;
  c2aS:
      R1 = _rT5::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aU:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2aO::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT5::P32, Hp - 4);
      if (_c2aO::I32 == 0) goto c2aQ; else goto c2aP;
  c2aQ:
      call (I32[_rT5::P32])() args: 4, res: 0, upd: 4;
  c2aP:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = 1;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c2aR:
      _rT5::P32 = R1;
      goto c2aM;
  c2aM:
      if (Sp - <highSp> < SpLim) goto c2aS; else goto c2aT;
  c2aT:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2aV; else goto c2aU;
  c2aV:
      HpAlloc = 8;
      goto c2aS;
  c2aS:
      R1 = _rT5::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aU:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2aO::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT5::P32, Hp - 4);
      if (_c2aO::I32 == 0) goto c2aQ; else goto c2aP;
  c2aQ:
      call (I32[_rT5::P32])() args: 4, res: 0, upd: 4;
  c2aP:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = 1;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c2aR:
      _rT5::P32 = R1;
      goto c2aM;
  c2aM:
      if (Sp - 12 < SpLim) goto c2aS; else goto c2aT;
  c2aT:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2aV; else goto c2aU;
  c2aV:
      HpAlloc = 8;
      goto c2aS;
  c2aS:
      R1 = _rT5::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aU:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2aO::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT5::P32, Hp - 4);
      if (_c2aO::I32 == 0) goto c2aQ; else goto c2aP;
  c2aQ:
      call (I32[_rT5::P32])() args: 4, res: 0, upd: 4;
  c2aP:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      I32[Sp - 12] = 1;
      Sp = Sp - 12;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c2aR:
      goto c2aM;
  c2aM:
      _rT5::P32 = R1;
      if ((Sp + -12) < SpLim) goto c2aS; else goto c2aT;
  c2aT:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2aV; else goto c2aU;
  c2aV:
      HpAlloc = 8;
      goto c2aS;
  c2aS:
      R1 = _rT5::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aU:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2aO::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT5::P32, Hp - 4);
      if (_c2aO::I32 == 0) goto c2aQ; else goto c2aP;
  c2aQ:
      call (I32[_rT5::P32])() args: 4, res: 0, upd: 4;
  c2aP:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      I32[Sp - 12] = 1;
      Sp = Sp - 12;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c2aM, {Main.main_go_closure}), (c2aP, {Main.main_go_closure}),
 (c2aQ, {}), (c2aR, {Main.main_go_closure}), (c2aS, {}),
 (c2aT, {Main.main_go_closure}), (c2aU, {Main.main_go_closure}),
 (c2aV, {})]



==================== after setInfoTableStackMap ====================
Main.main6_entry() //  [R1]
        { info_tbl: [(c2aR,
                      label: Main.main6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2aR:
          goto c2aM;
      c2aM:
          _rT5::P32 = R1;
          if ((Sp + -12) < SpLim) goto c2aS; else goto c2aT;
      c2aT:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2aV; else goto c2aU;
      c2aV:
          HpAlloc = 8;
          goto c2aS;
      c2aS:
          R1 = _rT5::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2aU:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2aO::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, _rT5::P32, Hp - 4);
          if (_c2aO::I32 == 0) goto c2aQ; else goto c2aP;
      c2aQ:
          call (I32[_rT5::P32])() args: 4, res: 0, upd: 4;
      c2aP:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          I32[Sp - 12] = 1;
          Sp = Sp - 12;
          call Main.main_go_info() args: 16, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
Main.main6_entry() //  [R1]
        { info_tbl: [(c2aM,
                      label: Main.main6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2aM:
          _rT5::P32 = R1;
          if ((Sp + -12) < SpLim) goto c2aS; else goto c2aT;
      c2aT:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2aV; else goto c2aU;
      c2aV:
          HpAlloc = 8;
          goto c2aS;
      c2aS:
          R1 = _rT5::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2aU:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2aO::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, _rT5::P32, Hp - 4);
          if (_c2aO::I32 == 0) goto c2aQ; else goto c2aP;
      c2aQ:
          call (I32[_rT5::P32])() args: 4, res: 0, upd: 4;
      c2aP:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          I32[Sp - 12] = 1;
          Sp = Sp - 12;
          call Main.main_go_info() args: 16, res: 0, upd: 12;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main6_closure:
         const Main.main6_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main6_entry() //  [R1]
         { info_tbl: [(c2aM,
                       label: Main.main6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2aM:
           _rT5::P32 = R1;
           if ((Sp + -12) < SpLim) goto c2aS; else goto c2aT;
       c2aT:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2aV; else goto c2aU;
       c2aV:
           HpAlloc = 8;
           goto c2aS;
       c2aS:
           R1 = _rT5::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2aU:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2aO::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT5::P32, Hp - 4);
           if (_c2aO::I32 == 0) goto c2aQ; else goto c2aP;
       c2aQ:
           call (I32[_rT5::P32])() args: 4, res: 0, upd: 4;
       c2aP:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           I32[Sp - 12] = 1;
           Sp = Sp - 12;
           call Main.main_go_info() args: 16, res: 0, upd: 12;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main6_closure:
         const Main.main6_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main6_entry() //  [R1]
         { info_tbl: [(c2aM,
                       label: Main.main6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2aM:
           _rT5::P32 = R1;
           if ((Sp + -12) < SpLim) goto c2aS; else goto c2aT;
       c2aT:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2aV; else goto c2aU;
       c2aV:
           HpAlloc = 8;
           goto c2aS;
       c2aS:
           R1 = _rT5::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2aU:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2aO::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT5::P32, Hp - 4);
           if (_c2aO::I32 == 0) goto c2aQ; else goto c2aP;
       c2aQ:
           call (I32[_rT5::P32])() args: 4, res: 0, upd: 4;
       c2aP:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           I32[Sp - 12] = 1;
           Sp = Sp - 12;
           call Main.main_go_info() args: 16, res: 0, upd: 12;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main5_closure:
         const Main.main5_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main5_entry() //  [R1]
         { info_tbl: [(c2bb,
                       label: Main.main5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bb:
           _rT6::P32 = R1;
           goto c2b6;
       c2b6:
           if (Sp - <highSp> < SpLim) goto c2bc; else goto c2bd;
       c2bd:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bf; else goto c2be;
       c2bf:
           HpAlloc = 8;
           goto c2bc;
       c2bc:
           R1 = _rT6::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2be:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2b8::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT6::P32, Hp - 4);
           if (_c2b8::I32 == 0) goto c2ba; else goto c2b9;
       c2ba:
           call (I32[_rT6::P32])() args: 4, res: 0, upd: 4;
       c2b9:
           I32[(old + 12)] = stg_bh_upd_frame_info;
           P32[(old + 8)] = Hp - 4;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = Main.main6_closure;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2bb:
      _rT6::P32 = R1;
      goto c2b6;
  c2b6:
      if (Sp - <highSp> < SpLim) goto c2bc; else goto c2bd;
  c2bd:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bf; else goto c2be;
  c2bf:
      HpAlloc = 8;
      goto c2bc;
  c2bc:
      R1 = _rT6::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2be:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2b8::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT6::P32, Hp - 4);
      if (_c2b8::I32 == 0) goto c2ba; else goto c2b9;
  c2ba:
      call (I32[_rT6::P32])() args: 4, res: 0, upd: 4;
  c2b9:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main6_closure;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c2bb:
      _rT6::P32 = R1;
      goto c2b6;
  c2b6:
      if (Sp - <highSp> < SpLim) goto c2bc; else goto c2bd;
  c2bd:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bf; else goto c2be;
  c2bf:
      HpAlloc = 8;
      goto c2bc;
  c2bc:
      R1 = _rT6::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2be:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2b8::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT6::P32, Hp - 4);
      if (_c2b8::I32 == 0) goto c2ba; else goto c2b9;
  c2ba:
      call (I32[_rT6::P32])() args: 4, res: 0, upd: 4;
  c2b9:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main6_closure;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c2bb:
      _rT6::P32 = R1;
      goto c2b6;
  c2b6:
      if (Sp - <highSp> < SpLim) goto c2bc; else goto c2bd;
  c2bd:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bf; else goto c2be;
  c2bf:
      HpAlloc = 8;
      goto c2bc;
  c2bc:
      R1 = _rT6::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2be:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2b8::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT6::P32, Hp - 4);
      if (_c2b8::I32 == 0) goto c2ba; else goto c2b9;
  c2ba:
      call (I32[_rT6::P32])() args: 4, res: 0, upd: 4;
  c2b9:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main6_closure;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c2bb:
      _rT6::P32 = R1;
      goto c2b6;
  c2b6:
      if (Sp - 24 < SpLim) goto c2bc; else goto c2bd;
  c2bd:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bf; else goto c2be;
  c2bf:
      HpAlloc = 8;
      goto c2bc;
  c2bc:
      R1 = _rT6::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2be:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2b8::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT6::P32, Hp - 4);
      if (_c2b8::I32 == 0) goto c2ba; else goto c2b9;
  c2ba:
      call (I32[_rT6::P32])() args: 4, res: 0, upd: 4;
  c2b9:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = Main.main6_closure;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c2bb:
      goto c2b6;
  c2b6:
      _rT6::P32 = R1;
      if ((Sp + -24) < SpLim) goto c2bc; else goto c2bd;
  c2bd:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bf; else goto c2be;
  c2bf:
      HpAlloc = 8;
      goto c2bc;
  c2bc:
      R1 = _rT6::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2be:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2b8::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT6::P32, Hp - 4);
      if (_c2b8::I32 == 0) goto c2ba; else goto c2b9;
  c2ba:
      call (I32[_rT6::P32])() args: 4, res: 0, upd: 4;
  c2b9:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = Main.main6_closure;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c2b6,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   Main.main6_closure}),
 (c2b9,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   Main.main6_closure}),
 (c2ba, {}),
 (c2bb,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   Main.main6_closure}),
 (c2bc, {}),
 (c2bd,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   Main.main6_closure}),
 (c2be,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   Main.main6_closure}),
 (c2bf, {})]



==================== after setInfoTableStackMap ====================
Main.main5_entry() //  [R1]
        { info_tbl: [(c2bb,
                      label: Main.main5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2bb:
          goto c2b6;
      c2b6:
          _rT6::P32 = R1;
          if ((Sp + -24) < SpLim) goto c2bc; else goto c2bd;
      c2bd:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2bf; else goto c2be;
      c2bf:
          HpAlloc = 8;
          goto c2bc;
      c2bc:
          R1 = _rT6::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2be:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2b8::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, _rT6::P32, Hp - 4);
          if (_c2b8::I32 == 0) goto c2ba; else goto c2b9;
      c2ba:
          call (I32[_rT6::P32])() args: 4, res: 0, upd: 4;
      c2b9:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = Main.main6_closure;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
Main.main5_entry() //  [R1]
        { info_tbl: [(c2b6,
                      label: Main.main5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2b6:
          _rT6::P32 = R1;
          if ((Sp + -24) < SpLim) goto c2bc; else goto c2bd;
      c2bd:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2bf; else goto c2be;
      c2bf:
          HpAlloc = 8;
          goto c2bc;
      c2bc:
          R1 = _rT6::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2be:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2b8::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, _rT6::P32, Hp - 4);
          if (_c2b8::I32 == 0) goto c2ba; else goto c2b9;
      c2ba:
          call (I32[_rT6::P32])() args: 4, res: 0, upd: 4;
      c2b9:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = Main.main6_closure;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main5_closure:
         const Main.main5_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main5_entry() //  [R1]
         { info_tbl: [(c2b6,
                       label: Main.main5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2b6:
           _rT6::P32 = R1;
           if ((Sp + -24) < SpLim) goto c2bc; else goto c2bd;
       c2bd:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bf; else goto c2be;
       c2bf:
           HpAlloc = 8;
           goto c2bc;
       c2bc:
           R1 = _rT6::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2be:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2b8::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT6::P32, Hp - 4);
           if (_c2b8::I32 == 0) goto c2ba; else goto c2b9;
       c2ba:
           call (I32[_rT6::P32])() args: 4, res: 0, upd: 4;
       c2b9:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = Main.main6_closure;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main5_closure:
         const Main.main5_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main5_entry() //  [R1]
         { info_tbl: [(c2b6,
                       label: Main.main5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2b6:
           _rT6::P32 = R1;
           if ((Sp + -24) < SpLim) goto c2bc; else goto c2bd;
       c2bd:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bf; else goto c2be;
       c2bf:
           HpAlloc = 8;
           goto c2bc;
       c2bc:
           R1 = _rT6::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2be:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2b8::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT6::P32, Hp - 4);
           if (_c2b8::I32 == 0) goto c2ba; else goto c2b9;
       c2ba:
           call (I32[_rT6::P32])() args: 4, res: 0, upd: 4;
       c2b9:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = Main.main6_closure;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main4_closure:
         const Main.main4_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main4_entry() //  [R1]
         { info_tbl: [(c2bv,
                       label: Main.main4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bv:
           _rT7::P32 = R1;
           goto c2bq;
       c2bq:
           if (Sp - <highSp> < SpLim) goto c2bw; else goto c2bx;
       c2bx:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bz; else goto c2by;
       c2bz:
           HpAlloc = 8;
           goto c2bw;
       c2bw:
           R1 = _rT7::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2by:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2bs::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
           if (_c2bs::I32 == 0) goto c2bu; else goto c2bt;
       c2bu:
           call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
       c2bt:
           I32[(old + 12)] = stg_bh_upd_frame_info;
           P32[(old + 8)] = Hp - 4;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = Main.main5_closure;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2bv:
      _rT7::P32 = R1;
      goto c2bq;
  c2bq:
      if (Sp - <highSp> < SpLim) goto c2bw; else goto c2bx;
  c2bx:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bz; else goto c2by;
  c2bz:
      HpAlloc = 8;
      goto c2bw;
  c2bw:
      R1 = _rT7::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2by:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bs::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
      if (_c2bs::I32 == 0) goto c2bu; else goto c2bt;
  c2bu:
      call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
  c2bt:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main5_closure;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c2bv:
      _rT7::P32 = R1;
      goto c2bq;
  c2bq:
      if (Sp - <highSp> < SpLim) goto c2bw; else goto c2bx;
  c2bx:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bz; else goto c2by;
  c2bz:
      HpAlloc = 8;
      goto c2bw;
  c2bw:
      R1 = _rT7::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2by:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bs::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
      if (_c2bs::I32 == 0) goto c2bu; else goto c2bt;
  c2bu:
      call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
  c2bt:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main5_closure;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c2bv:
      _rT7::P32 = R1;
      goto c2bq;
  c2bq:
      if (Sp - <highSp> < SpLim) goto c2bw; else goto c2bx;
  c2bx:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bz; else goto c2by;
  c2bz:
      HpAlloc = 8;
      goto c2bw;
  c2bw:
      R1 = _rT7::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2by:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bs::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
      if (_c2bs::I32 == 0) goto c2bu; else goto c2bt;
  c2bu:
      call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
  c2bt:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main5_closure;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c2bv:
      _rT7::P32 = R1;
      goto c2bq;
  c2bq:
      if (Sp - 24 < SpLim) goto c2bw; else goto c2bx;
  c2bx:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bz; else goto c2by;
  c2bz:
      HpAlloc = 8;
      goto c2bw;
  c2bw:
      R1 = _rT7::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2by:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bs::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
      if (_c2bs::I32 == 0) goto c2bu; else goto c2bt;
  c2bu:
      call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
  c2bt:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = Main.main5_closure;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c2bv:
      goto c2bq;
  c2bq:
      _rT7::P32 = R1;
      if ((Sp + -24) < SpLim) goto c2bw; else goto c2bx;
  c2bx:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bz; else goto c2by;
  c2bz:
      HpAlloc = 8;
      goto c2bw;
  c2bw:
      R1 = _rT7::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2by:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bs::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
      if (_c2bs::I32 == 0) goto c2bu; else goto c2bt;
  c2bu:
      call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
  c2bt:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = Main.main5_closure;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c2bq,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   Main.main5_closure}),
 (c2bt,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   Main.main5_closure}),
 (c2bu, {}),
 (c2bv,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   Main.main5_closure}),
 (c2bw, {}),
 (c2bx,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   Main.main5_closure}),
 (c2by,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   Main.main5_closure}),
 (c2bz, {})]



==================== after setInfoTableStackMap ====================
Main.main4_entry() //  [R1]
        { info_tbl: [(c2bv,
                      label: Main.main4_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2bv:
          goto c2bq;
      c2bq:
          _rT7::P32 = R1;
          if ((Sp + -24) < SpLim) goto c2bw; else goto c2bx;
      c2bx:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2bz; else goto c2by;
      c2bz:
          HpAlloc = 8;
          goto c2bw;
      c2bw:
          R1 = _rT7::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2by:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2bs::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
          if (_c2bs::I32 == 0) goto c2bu; else goto c2bt;
      c2bu:
          call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
      c2bt:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = Main.main5_closure;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
Main.main4_entry() //  [R1]
        { info_tbl: [(c2bq,
                      label: Main.main4_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2bq:
          _rT7::P32 = R1;
          if ((Sp + -24) < SpLim) goto c2bw; else goto c2bx;
      c2bx:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2bz; else goto c2by;
      c2bz:
          HpAlloc = 8;
          goto c2bw;
      c2bw:
          R1 = _rT7::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2by:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2bs::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
          if (_c2bs::I32 == 0) goto c2bu; else goto c2bt;
      c2bu:
          call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
      c2bt:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = Main.main5_closure;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main4_closure:
         const Main.main4_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main4_entry() //  [R1]
         { info_tbl: [(c2bq,
                       label: Main.main4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bq:
           _rT7::P32 = R1;
           if ((Sp + -24) < SpLim) goto c2bw; else goto c2bx;
       c2bx:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bz; else goto c2by;
       c2bz:
           HpAlloc = 8;
           goto c2bw;
       c2bw:
           R1 = _rT7::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2by:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2bs::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
           if (_c2bs::I32 == 0) goto c2bu; else goto c2bt;
       c2bu:
           call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
       c2bt:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = Main.main5_closure;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main4_closure:
         const Main.main4_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main4_entry() //  [R1]
         { info_tbl: [(c2bq,
                       label: Main.main4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bq:
           _rT7::P32 = R1;
           if ((Sp + -24) < SpLim) goto c2bw; else goto c2bx;
       c2bx:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bz; else goto c2by;
       c2bz:
           HpAlloc = 8;
           goto c2bw;
       c2bw:
           R1 = _rT7::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2by:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2bs::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
           if (_c2bs::I32 == 0) goto c2bu; else goto c2bt;
       c2bu:
           call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
       c2bt:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = Main.main5_closure;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main3_closure:
         const Main.main3_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main3_entry() //  [R1]
         { info_tbl: [(c2bP,
                       label: Main.main3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bP:
           _rT9::P32 = R1;
           goto c2bK;
       c2bK:
           if (Sp - <highSp> < SpLim) goto c2bQ; else goto c2bR;
       c2bR:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bT; else goto c2bS;
       c2bT:
           HpAlloc = 8;
           goto c2bQ;
       c2bQ:
           R1 = _rT9::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2bS:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2bM::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT9::P32, Hp - 4);
           if (_c2bM::I32 == 0) goto c2bO; else goto c2bN;
       c2bO:
           call (I32[_rT9::P32])() args: 4, res: 0, upd: 4;
       c2bN:
           I32[(old + 12)] = stg_bh_upd_frame_info;
           P32[(old + 8)] = Hp - 4;
           I32[(old + 20)] = 20;
           P32[(old + 16)] = Main.main4_closure;
           call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2bP:
      _rT9::P32 = R1;
      goto c2bK;
  c2bK:
      if (Sp - <highSp> < SpLim) goto c2bQ; else goto c2bR;
  c2bR:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bT; else goto c2bS;
  c2bT:
      HpAlloc = 8;
      goto c2bQ;
  c2bQ:
      R1 = _rT9::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bS:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bM::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT9::P32, Hp - 4);
      if (_c2bM::I32 == 0) goto c2bO; else goto c2bN;
  c2bO:
      call (I32[_rT9::P32])() args: 4, res: 0, upd: 4;
  c2bN:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 20)] = 20;
      P32[(old + 16)] = Main.main4_closure;
      call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c2bP:
      _rT9::P32 = R1;
      goto c2bK;
  c2bK:
      if (Sp - <highSp> < SpLim) goto c2bQ; else goto c2bR;
  c2bR:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bT; else goto c2bS;
  c2bT:
      HpAlloc = 8;
      goto c2bQ;
  c2bQ:
      R1 = _rT9::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bS:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bM::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT9::P32, Hp - 4);
      if (_c2bM::I32 == 0) goto c2bO; else goto c2bN;
  c2bO:
      call (I32[_rT9::P32])() args: 4, res: 0, upd: 4;
  c2bN:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 20)] = 20;
      P32[(old + 16)] = Main.main4_closure;
      call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c2bP:
      _rT9::P32 = R1;
      goto c2bK;
  c2bK:
      if (Sp - <highSp> < SpLim) goto c2bQ; else goto c2bR;
  c2bR:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bT; else goto c2bS;
  c2bT:
      HpAlloc = 8;
      goto c2bQ;
  c2bQ:
      R1 = _rT9::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bS:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bM::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT9::P32, Hp - 4);
      if (_c2bM::I32 == 0) goto c2bO; else goto c2bN;
  c2bO:
      call (I32[_rT9::P32])() args: 4, res: 0, upd: 4;
  c2bN:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 20)] = 20;
      P32[(old + 16)] = Main.main4_closure;
      call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c2bP:
      _rT9::P32 = R1;
      goto c2bK;
  c2bK:
      if (Sp - 16 < SpLim) goto c2bQ; else goto c2bR;
  c2bR:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bT; else goto c2bS;
  c2bT:
      HpAlloc = 8;
      goto c2bQ;
  c2bQ:
      R1 = _rT9::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bS:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bM::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT9::P32, Hp - 4);
      if (_c2bM::I32 == 0) goto c2bO; else goto c2bN;
  c2bO:
      call (I32[_rT9::P32])() args: 4, res: 0, upd: 4;
  c2bN:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      I32[Sp - 16] = 20;
      P32[Sp - 12] = Main.main4_closure;
      Sp = Sp - 16;
      call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c2bP:
      goto c2bK;
  c2bK:
      _rT9::P32 = R1;
      if ((Sp + -16) < SpLim) goto c2bQ; else goto c2bR;
  c2bR:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bT; else goto c2bS;
  c2bT:
      HpAlloc = 8;
      goto c2bQ;
  c2bQ:
      R1 = _rT9::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bS:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bM::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT9::P32, Hp - 4);
      if (_c2bM::I32 == 0) goto c2bO; else goto c2bN;
  c2bO:
      call (I32[_rT9::P32])() args: 4, res: 0, upd: 4;
  c2bN:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      I32[Sp - 16] = 20;
      P32[Sp - 12] = Main.main4_closure;
      Sp = Sp - 16;
      call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c2bK, {Main.main4_closure}), (c2bN, {Main.main4_closure}),
 (c2bO, {}), (c2bP, {Main.main4_closure}), (c2bQ, {}),
 (c2bR, {Main.main4_closure}), (c2bS, {Main.main4_closure}),
 (c2bT, {})]



==================== after setInfoTableStackMap ====================
Main.main3_entry() //  [R1]
        { info_tbl: [(c2bP,
                      label: Main.main3_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2bP:
          goto c2bK;
      c2bK:
          _rT9::P32 = R1;
          if ((Sp + -16) < SpLim) goto c2bQ; else goto c2bR;
      c2bR:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2bT; else goto c2bS;
      c2bT:
          HpAlloc = 8;
          goto c2bQ;
      c2bQ:
          R1 = _rT9::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2bS:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2bM::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, _rT9::P32, Hp - 4);
          if (_c2bM::I32 == 0) goto c2bO; else goto c2bN;
      c2bO:
          call (I32[_rT9::P32])() args: 4, res: 0, upd: 4;
      c2bN:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          I32[Sp - 16] = 20;
          P32[Sp - 12] = Main.main4_closure;
          Sp = Sp - 16;
          call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
Main.main3_entry() //  [R1]
        { info_tbl: [(c2bK,
                      label: Main.main3_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2bK:
          _rT9::P32 = R1;
          if ((Sp + -16) < SpLim) goto c2bQ; else goto c2bR;
      c2bR:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2bT; else goto c2bS;
      c2bT:
          HpAlloc = 8;
          goto c2bQ;
      c2bQ:
          R1 = _rT9::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2bS:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2bM::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, _rT9::P32, Hp - 4);
          if (_c2bM::I32 == 0) goto c2bO; else goto c2bN;
      c2bO:
          call (I32[_rT9::P32])() args: 4, res: 0, upd: 4;
      c2bN:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          I32[Sp - 16] = 20;
          P32[Sp - 12] = Main.main4_closure;
          Sp = Sp - 16;
          call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main3_closure:
         const Main.main3_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main3_entry() //  [R1]
         { info_tbl: [(c2bK,
                       label: Main.main3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bK:
           _rT9::P32 = R1;
           if ((Sp + -16) < SpLim) goto c2bQ; else goto c2bR;
       c2bR:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bT; else goto c2bS;
       c2bT:
           HpAlloc = 8;
           goto c2bQ;
       c2bQ:
           R1 = _rT9::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2bS:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2bM::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT9::P32, Hp - 4);
           if (_c2bM::I32 == 0) goto c2bO; else goto c2bN;
       c2bO:
           call (I32[_rT9::P32])() args: 4, res: 0, upd: 4;
       c2bN:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           I32[Sp - 16] = 20;
           P32[Sp - 12] = Main.main4_closure;
           Sp = Sp - 16;
           call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main3_closure:
         const Main.main3_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main3_entry() //  [R1]
         { info_tbl: [(c2bK,
                       label: Main.main3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bK:
           _rT9::P32 = R1;
           if ((Sp + -16) < SpLim) goto c2bQ; else goto c2bR;
       c2bR:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bT; else goto c2bS;
       c2bT:
           HpAlloc = 8;
           goto c2bQ;
       c2bQ:
           R1 = _rT9::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2bS:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2bM::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT9::P32, Hp - 4);
           if (_c2bM::I32 == 0) goto c2bO; else goto c2bN;
       c2bO:
           call (I32[_rT9::P32])() args: 4, res: 0, upd: 4;
       c2bN:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           I32[Sp - 16] = 20;
           P32[Sp - 12] = Main.main4_closure;
           Sp = Sp - 16;
           call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main2_closure:
         const Main.main2_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main2_entry() //  [R1]
         { info_tbl: [(c2c9,
                       label: Main.main2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2c9:
           _rTc::P32 = R1;
           goto c2c4;
       c2c4:
           if (Sp - <highSp> < SpLim) goto c2ca; else goto c2cb;
       c2cb:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2cd; else goto c2cc;
       c2cd:
           HpAlloc = 8;
           goto c2ca;
       c2ca:
           R1 = _rTc::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2cc:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2c6::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rTc::P32, Hp - 4);
           if (_c2c6::I32 == 0) goto c2c8; else goto c2c7;
       c2c8:
           call (I32[_rTc::P32])() args: 4, res: 0, upd: 4;
       c2c7:
           I32[(old + 12)] = stg_bh_upd_frame_info;
           P32[(old + 8)] = Hp - 4;
           P32[(old + 28)] = GHC.Show.$fShowInt_closure;
           P32[(old + 24)] = GHC.Show.$fShowInt_closure;
           P32[(old + 20)] = Main.main3_closure;
           P32[(old + 16)] = GHC.Types.[]_closure+1;
           call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2c9:
      _rTc::P32 = R1;
      goto c2c4;
  c2c4:
      if (Sp - <highSp> < SpLim) goto c2ca; else goto c2cb;
  c2cb:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2cd; else goto c2cc;
  c2cd:
      HpAlloc = 8;
      goto c2ca;
  c2ca:
      R1 = _rTc::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2cc:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2c6::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rTc::P32, Hp - 4);
      if (_c2c6::I32 == 0) goto c2c8; else goto c2c7;
  c2c8:
      call (I32[_rTc::P32])() args: 4, res: 0, upd: 4;
  c2c7:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Show.$fShowInt_closure;
      P32[(old + 24)] = GHC.Show.$fShowInt_closure;
      P32[(old + 20)] = Main.main3_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c2c9:
      _rTc::P32 = R1;
      goto c2c4;
  c2c4:
      if (Sp - <highSp> < SpLim) goto c2ca; else goto c2cb;
  c2cb:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2cd; else goto c2cc;
  c2cd:
      HpAlloc = 8;
      goto c2ca;
  c2ca:
      R1 = _rTc::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2cc:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2c6::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rTc::P32, Hp - 4);
      if (_c2c6::I32 == 0) goto c2c8; else goto c2c7;
  c2c8:
      call (I32[_rTc::P32])() args: 4, res: 0, upd: 4;
  c2c7:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Show.$fShowInt_closure;
      P32[(old + 24)] = GHC.Show.$fShowInt_closure;
      P32[(old + 20)] = Main.main3_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c2c9:
      _rTc::P32 = R1;
      goto c2c4;
  c2c4:
      if (Sp - <highSp> < SpLim) goto c2ca; else goto c2cb;
  c2cb:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2cd; else goto c2cc;
  c2cd:
      HpAlloc = 8;
      goto c2ca;
  c2ca:
      R1 = _rTc::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2cc:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2c6::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rTc::P32, Hp - 4);
      if (_c2c6::I32 == 0) goto c2c8; else goto c2c7;
  c2c8:
      call (I32[_rTc::P32])() args: 4, res: 0, upd: 4;
  c2c7:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Show.$fShowInt_closure;
      P32[(old + 24)] = GHC.Show.$fShowInt_closure;
      P32[(old + 20)] = Main.main3_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c2c9:
      _rTc::P32 = R1;
      goto c2c4;
  c2c4:
      if (Sp - 24 < SpLim) goto c2ca; else goto c2cb;
  c2cb:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2cd; else goto c2cc;
  c2cd:
      HpAlloc = 8;
      goto c2ca;
  c2ca:
      R1 = _rTc::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2cc:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2c6::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rTc::P32, Hp - 4);
      if (_c2c6::I32 == 0) goto c2c8; else goto c2c7;
  c2c8:
      call (I32[_rTc::P32])() args: 4, res: 0, upd: 4;
  c2c7:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Show.$fShowInt_closure;
      P32[Sp - 20] = GHC.Show.$fShowInt_closure;
      P32[Sp - 16] = Main.main3_closure;
      P32[Sp - 12] = GHC.Types.[]_closure+1;
      Sp = Sp - 24;
      call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c2c9:
      goto c2c4;
  c2c4:
      _rTc::P32 = R1;
      if ((Sp + -24) < SpLim) goto c2ca; else goto c2cb;
  c2cb:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2cd; else goto c2cc;
  c2cd:
      HpAlloc = 8;
      goto c2ca;
  c2ca:
      R1 = _rTc::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2cc:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2c6::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rTc::P32, Hp - 4);
      if (_c2c6::I32 == 0) goto c2c8; else goto c2c7;
  c2c8:
      call (I32[_rTc::P32])() args: 4, res: 0, upd: 4;
  c2c7:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Show.$fShowInt_closure;
      P32[Sp - 20] = GHC.Show.$fShowInt_closure;
      P32[Sp - 16] = Main.main3_closure;
      P32[Sp - 12] = GHC.Types.[]_closure+1;
      Sp = Sp - 24;
      call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c2c4,
  {Main.main3_closure, GHC.Show.$fShow(,)_$cshowList_closure}),
 (c2c7,
  {Main.main3_closure, GHC.Show.$fShow(,)_$cshowList_closure}),
 (c2c8, {}),
 (c2c9,
  {Main.main3_closure, GHC.Show.$fShow(,)_$cshowList_closure}),
 (c2ca, {}),
 (c2cb,
  {Main.main3_closure, GHC.Show.$fShow(,)_$cshowList_closure}),
 (c2cc,
  {Main.main3_closure, GHC.Show.$fShow(,)_$cshowList_closure}),
 (c2cd, {})]



==================== after setInfoTableStackMap ====================
Main.main2_entry() //  [R1]
        { info_tbl: [(c2c9,
                      label: Main.main2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2c9:
          goto c2c4;
      c2c4:
          _rTc::P32 = R1;
          if ((Sp + -24) < SpLim) goto c2ca; else goto c2cb;
      c2cb:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2cd; else goto c2cc;
      c2cd:
          HpAlloc = 8;
          goto c2ca;
      c2ca:
          R1 = _rTc::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2cc:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2c6::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, _rTc::P32, Hp - 4);
          if (_c2c6::I32 == 0) goto c2c8; else goto c2c7;
      c2c8:
          call (I32[_rTc::P32])() args: 4, res: 0, upd: 4;
      c2c7:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Show.$fShowInt_closure;
          P32[Sp - 20] = GHC.Show.$fShowInt_closure;
          P32[Sp - 16] = Main.main3_closure;
          P32[Sp - 12] = GHC.Types.[]_closure+1;
          Sp = Sp - 24;
          call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
Main.main2_entry() //  [R1]
        { info_tbl: [(c2c4,
                      label: Main.main2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2c4:
          _rTc::P32 = R1;
          if ((Sp + -24) < SpLim) goto c2ca; else goto c2cb;
      c2cb:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2cd; else goto c2cc;
      c2cd:
          HpAlloc = 8;
          goto c2ca;
      c2ca:
          R1 = _rTc::P32;
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2cc:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2c6::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, _rTc::P32, Hp - 4);
          if (_c2c6::I32 == 0) goto c2c8; else goto c2c7;
      c2c8:
          call (I32[_rTc::P32])() args: 4, res: 0, upd: 4;
      c2c7:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Show.$fShowInt_closure;
          P32[Sp - 20] = GHC.Show.$fShowInt_closure;
          P32[Sp - 16] = Main.main3_closure;
          P32[Sp - 12] = GHC.Types.[]_closure+1;
          Sp = Sp - 24;
          call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main2_closure:
         const Main.main2_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main2_entry() //  [R1]
         { info_tbl: [(c2c4,
                       label: Main.main2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2c4:
           _rTc::P32 = R1;
           if ((Sp + -24) < SpLim) goto c2ca; else goto c2cb;
       c2cb:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2cd; else goto c2cc;
       c2cd:
           HpAlloc = 8;
           goto c2ca;
       c2ca:
           R1 = _rTc::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2cc:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2c6::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rTc::P32, Hp - 4);
           if (_c2c6::I32 == 0) goto c2c8; else goto c2c7;
       c2c8:
           call (I32[_rTc::P32])() args: 4, res: 0, upd: 4;
       c2c7:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Show.$fShowInt_closure;
           P32[Sp - 20] = GHC.Show.$fShowInt_closure;
           P32[Sp - 16] = Main.main3_closure;
           P32[Sp - 12] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main2_closure:
         const Main.main2_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main2_entry() //  [R1]
         { info_tbl: [(c2c4,
                       label: Main.main2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2c4:
           _rTc::P32 = R1;
           if ((Sp + -24) < SpLim) goto c2ca; else goto c2cb;
       c2cb:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2cd; else goto c2cc;
       c2cd:
           HpAlloc = 8;
           goto c2ca;
       c2ca:
           R1 = _rTc::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2cc:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2c6::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rTc::P32, Hp - 4);
           if (_c2c6::I32 == 0) goto c2c8; else goto c2c7;
       c2c8:
           call (I32[_rTc::P32])() args: 4, res: 0, upd: 4;
       c2c7:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Show.$fShowInt_closure;
           P32[Sp - 20] = GHC.Show.$fShowInt_closure;
           P32[Sp - 16] = Main.main3_closure;
           P32[Sp - 12] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main1_closure:
         const Main.main1_info;
         const 0;
 },
 Main.main1_entry() //  []
         { info_tbl: [(c2cq,
                       label: Main.main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cq:
           goto c2co;
       c2co:
           if (Sp - <highSp> < SpLim) goto c2cr; else goto c2cs;
       c2cr:
           R1 = Main.main1_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cs:
           P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
           P32[(old + 12)] = Main.main2_closure;
           P32[(old + 8)] = GHC.Types.True_closure+2;
           call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2co:
      if (Sp - <highSp> < SpLim) goto c2cr; else goto c2cs;
  c2cr:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cs:
      P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
      P32[(old + 12)] = Main.main2_closure;
      P32[(old + 8)] = GHC.Types.True_closure+2;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c2co:
      if (Sp - <highSp> < SpLim) goto c2cr; else goto c2cs;
  c2cr:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cs:
      P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
      P32[(old + 12)] = Main.main2_closure;
      P32[(old + 8)] = GHC.Types.True_closure+2;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c2co:
      if (Sp - <highSp> < SpLim) goto c2cr; else goto c2cs;
  c2cr:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cs:
      P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
      P32[(old + 12)] = Main.main2_closure;
      P32[(old + 8)] = GHC.Types.True_closure+2;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c2co:
      if (Sp - 12 < SpLim) goto c2cr; else goto c2cs;
  c2cr:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cs:
      P32[Sp - 12] = GHC.IO.Handle.FD.stdout_closure;
      P32[Sp - 8] = Main.main2_closure;
      P32[Sp - 4] = GHC.Types.True_closure+2;
      Sp = Sp - 12;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c2co:
      if ((Sp + -12) < SpLim) goto c2cr; else goto c2cs;
  c2cr:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cs:
      P32[Sp - 12] = GHC.IO.Handle.FD.stdout_closure;
      P32[Sp - 8] = Main.main2_closure;
      P32[Sp - 4] = GHC.Types.True_closure+2;
      Sp = Sp - 12;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c2co,
  {Main.main2_closure, GHC.IO.Handle.FD.stdout_closure,
   GHC.IO.Handle.Text.hPutStr2_closure, Main.main1_closure}),
 (c2cr, {Main.main1_closure}),
 (c2cs,
  {Main.main2_closure, GHC.IO.Handle.FD.stdout_closure,
   GHC.IO.Handle.Text.hPutStr2_closure})]



==================== after setInfoTableStackMap ====================
Main.main1_entry() //  []
        { info_tbl: [(c2co,
                      label: Main.main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2co:
          if ((Sp + -12) < SpLim) goto c2cr; else goto c2cs;
      c2cr:
          R1 = Main.main1_closure;
          call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
      c2cs:
          P32[Sp - 12] = GHC.IO.Handle.FD.stdout_closure;
          P32[Sp - 8] = Main.main2_closure;
          P32[Sp - 4] = GHC.Types.True_closure+2;
          Sp = Sp - 12;
          call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
Main.main1_entry() //  []
        { info_tbl: [(c2co,
                      label: Main.main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2co:
          if ((Sp + -12) < SpLim) goto c2cr; else goto c2cs;
      c2cr:
          R1 = Main.main1_closure;
          call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
      c2cs:
          P32[Sp - 12] = GHC.IO.Handle.FD.stdout_closure;
          P32[Sp - 8] = Main.main2_closure;
          P32[Sp - 4] = GHC.Types.True_closure+2;
          Sp = Sp - 12;
          call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main1_closure:
         const Main.main1_info;
         const 0;
 },
 Main.main1_entry() //  []
         { info_tbl: [(c2co,
                       label: Main.main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2co:
           if ((Sp + -12) < SpLim) goto c2cr; else goto c2cs;
       c2cr:
           R1 = Main.main1_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cs:
           P32[Sp - 12] = GHC.IO.Handle.FD.stdout_closure;
           P32[Sp - 8] = Main.main2_closure;
           P32[Sp - 4] = GHC.Types.True_closure+2;
           Sp = Sp - 12;
           call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main1_closure:
         const Main.main1_info;
         const 0;
 },
 Main.main1_entry() //  []
         { info_tbl: [(c2co,
                       label: Main.main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2co:
           if ((Sp + -12) < SpLim) goto c2cr; else goto c2cs;
       c2cr:
           R1 = Main.main1_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cs:
           P32[Sp - 12] = GHC.IO.Handle.FD.stdout_closure;
           P32[Sp - 8] = Main.main2_closure;
           P32[Sp - 4] = GHC.Types.True_closure+2;
           Sp = Sp - 12;
           call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main_closure:
         const Main.main_info;
         const 0;
 },
 Main.main_entry() //  []
         { info_tbl: [(c2cC,
                       label: Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cC:
           goto c2cA;
       c2cA:
           if (Sp - <highSp> < SpLim) goto c2cD; else goto c2cE;
       c2cD:
           R1 = Main.main_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cE:
           call Main.main1_info() args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2cA:
      if (Sp - <highSp> < SpLim) goto c2cD; else goto c2cE;
  c2cD:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cE:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c2cA:
      if (Sp - <highSp> < SpLim) goto c2cD; else goto c2cE;
  c2cD:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cE:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c2cA:
      if (Sp - <highSp> < SpLim) goto c2cD; else goto c2cE;
  c2cD:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cE:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c2cA:
      goto c2cE;
  c2cE:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c2cA:
      goto c2cE;
  c2cE:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c2cA, {Main.main1_closure}), (c2cE, {Main.main1_closure})]



==================== after setInfoTableStackMap ====================
Main.main_entry() //  []
        { info_tbl: [(c2cA,
                      label: Main.main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cA:
          goto c2cE;
      c2cE:
          call Main.main1_info() args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
Main.main_entry() //  []
        { info_tbl: [(c2cE,
                      label: Main.main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cE:
          call Main.main1_info() args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main_closure:
         const Main.main_info;
         const 0;
 },
 Main.main_entry() //  []
         { info_tbl: [(c2cE,
                       label: Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cE:
           call Main.main1_info() args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main_closure:
         const Main.main_info;
         const 0;
 },
 Main.main_entry() //  []
         { info_tbl: [(c2cE,
                       label: Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cE:
           call Main.main1_info() args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main7_closure:
         const Main.main7_info;
         const 0;
 },
 Main.main7_entry() //  []
         { info_tbl: [(c2cN,
                       label: Main.main7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cN:
           goto c2cL;
       c2cL:
           if (Sp - <highSp> < SpLim) goto c2cO; else goto c2cP;
       c2cO:
           R1 = Main.main7_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cP:
           P32[(old + 8)] = Main.main1_closure+1;
           call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2cL:
      if (Sp - <highSp> < SpLim) goto c2cO; else goto c2cP;
  c2cO:
      R1 = Main.main7_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cP:
      P32[(old + 8)] = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c2cL:
      if (Sp - <highSp> < SpLim) goto c2cO; else goto c2cP;
  c2cO:
      R1 = Main.main7_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cP:
      P32[(old + 8)] = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c2cL:
      if (Sp - <highSp> < SpLim) goto c2cO; else goto c2cP;
  c2cO:
      R1 = Main.main7_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cP:
      P32[(old + 8)] = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c2cL:
      if (Sp - 4 < SpLim) goto c2cO; else goto c2cP;
  c2cO:
      R1 = Main.main7_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cP:
      P32[Sp - 4] = Main.main1_closure+1;
      Sp = Sp - 4;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c2cL:
      if ((Sp + -4) < SpLim) goto c2cO; else goto c2cP;
  c2cO:
      R1 = Main.main7_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cP:
      P32[Sp - 4] = Main.main1_closure+1;
      Sp = Sp - 4;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c2cL,
  {GHC.TopHandler.runMainIO1_closure, Main.main1_closure,
   Main.main7_closure}),
 (c2cO, {Main.main7_closure}),
 (c2cP, {GHC.TopHandler.runMainIO1_closure, Main.main1_closure})]



==================== after setInfoTableStackMap ====================
Main.main7_entry() //  []
        { info_tbl: [(c2cL,
                      label: Main.main7_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cL:
          if ((Sp + -4) < SpLim) goto c2cO; else goto c2cP;
      c2cO:
          R1 = Main.main7_closure;
          call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
      c2cP:
          P32[Sp - 4] = Main.main1_closure+1;
          Sp = Sp - 4;
          call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
Main.main7_entry() //  []
        { info_tbl: [(c2cL,
                      label: Main.main7_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cL:
          if ((Sp + -4) < SpLim) goto c2cO; else goto c2cP;
      c2cO:
          R1 = Main.main7_closure;
          call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
      c2cP:
          P32[Sp - 4] = Main.main1_closure+1;
          Sp = Sp - 4;
          call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main7_closure:
         const Main.main7_info;
         const 0;
 },
 Main.main7_entry() //  []
         { info_tbl: [(c2cL,
                       label: Main.main7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cL:
           if ((Sp + -4) < SpLim) goto c2cO; else goto c2cP;
       c2cO:
           R1 = Main.main7_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cP:
           P32[Sp - 4] = Main.main1_closure+1;
           Sp = Sp - 4;
           call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main7_closure:
         const Main.main7_info;
         const 0;
 },
 Main.main7_entry() //  []
         { info_tbl: [(c2cL,
                       label: Main.main7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cL:
           if ((Sp + -4) < SpLim) goto c2cO; else goto c2cP;
       c2cO:
           R1 = Main.main7_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cP:
           P32[Sp - 4] = Main.main1_closure+1;
           Sp = Sp - 4;
           call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
 },
 :Main.main_entry() //  []
         { info_tbl: [(c2cZ,
                       label: :Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cZ:
           goto c2cX;
       c2cX:
           if (Sp - <highSp> < SpLim) goto c2d0; else goto c2d1;
       c2d0:
           R1 = :Main.main_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2d1:
           call Main.main7_info() args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2cX:
      if (Sp - <highSp> < SpLim) goto c2d0; else goto c2d1;
  c2d0:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2d1:
      call Main.main7_info() args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c2cX:
      if (Sp - <highSp> < SpLim) goto c2d0; else goto c2d1;
  c2d0:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2d1:
      call Main.main7_info() args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c2cX:
      if (Sp - <highSp> < SpLim) goto c2d0; else goto c2d1;
  c2d0:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2d1:
      call Main.main7_info() args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c2cX:
      goto c2d1;
  c2d1:
      call Main.main7_info() args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c2cX:
      goto c2d1;
  c2d1:
      call Main.main7_info() args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c2cX, {Main.main7_closure}), (c2d1, {Main.main7_closure})]



==================== after setInfoTableStackMap ====================
:Main.main_entry() //  []
        { info_tbl: [(c2cX,
                      label: :Main.main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cX:
          goto c2d1;
      c2d1:
          call Main.main7_info() args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
:Main.main_entry() //  []
        { info_tbl: [(c2d1,
                      label: :Main.main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2d1:
          call Main.main7_info() args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
 },
 :Main.main_entry() //  []
         { info_tbl: [(c2d1,
                       label: :Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2d1:
           call Main.main7_info() args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
 },
 :Main.main_entry() //  []
         { info_tbl: [(c2d1,
                       label: :Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2d1:
           call Main.main7_info() args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "relreadonly" {
     S26m_srt:
         const T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
         const Main.main_go_closure;
         const lvl1_r23Y_closure;
         const T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
         const Main.main6_closure;
         const T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
         const Main.main5_closure;
         const Main.main4_closure;
         const Main.main3_closure;
         const GHC.Show.$fShow(,)_$cshowList_closure;
         const Main.main2_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.Text.hPutStr2_closure;
         const Main.main1_closure;
         const GHC.TopHandler.runMainIO1_closure;
         const Main.main7_closure;
 }]


Linking T2902_B ...
