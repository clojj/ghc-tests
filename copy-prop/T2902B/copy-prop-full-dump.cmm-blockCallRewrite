[1 of 3] Compiling T2902_Sum        ( T2902_Sum.hs, T2902_Sum.o )

==================== Cmm produced by new codegen ====================
[section "data" { __stginit_main:T2902_Sum:
 }]



==================== Post CPS Cmm ====================
[section "data" { __stginit_main:T2902_Sum:
 }]



==================== Output Cmm ====================
[section "data" { __stginit_main:T2902_Sum:
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.insert_closure:
         const T2902_Sum.insert_info;
 },
 T2902_Sum.insert_entry() //  []
         { info_tbl: [(cfY,
                       label: T2902_Sum.insert_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cfY:
           _sf2::P32 = P32[(old + 8)];
           goto cfT;
       cfT:
           if (Sp - <highSp> < SpLim) goto cfZ; else goto cg0;
       cfZ:
           R1 = T2902_Sum.insert_closure;
           P32[(old + 8)] = _sf2::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cg0:
           I32[(young<cfV> + 4)] = cfV;
           R1 = _sf2::P32;
           if (R1 & 3 != 0) goto cfV; else goto cfW;
       cfW:
           call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
       cfV:
           _sf3::P32 = R1;
           _sf4::P32 = P32[_sf3::P32 + 3];
           _sf5::P32 = P32[_sf3::P32 + 7];
           _sf6::P32 = P32[_sf3::P32 + 11];
           _sf7::P32 = P32[_sf3::P32 + 15];
           _sf8::P32 = P32[_sf3::P32 + 19];
           _sf9::P32 = P32[_sf3::P32 + 23];
           R1 = _sf4::P32;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cfY:
      _sf2::P32 = P32[(old + 8)];
      goto cfT;
  cfT:
      if (Sp - <highSp> < SpLim) goto cfZ; else goto cg0;
  cfZ:
      R1 = T2902_Sum.insert_closure;
      P32[(old + 8)] = _sf2::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cg0:
      I32[(young<cfV> + 4)] = cfV;
      R1 = _sf2::P32;
      if (R1 & 3 != 0) goto cfV; else goto cfW;
  cfW:
      call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
  cfV:
      _sf3::P32 = R1;
      _sf4::P32 = P32[_sf3::P32 + 3];
      _sf5::P32 = P32[_sf3::P32 + 7];
      _sf6::P32 = P32[_sf3::P32 + 11];
      _sf7::P32 = P32[_sf3::P32 + 15];
      _sf8::P32 = P32[_sf3::P32 + 19];
      _sf9::P32 = P32[_sf3::P32 + 23];
      R1 = _sf4::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cfY:
      _sf2::P32 = P32[(old + 8)];
      goto cfT;
  cfT:
      if (Sp - <highSp> < SpLim) goto cfZ; else goto cg0;
  cfZ:
      R1 = T2902_Sum.insert_closure;
      P32[(old + 8)] = _sf2::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cg0:
      I32[(young<cfV> + 4)] = cfV;
      R1 = _sf2::P32;
      if (R1 & 3 != 0) goto cfV; else goto cfW;
  cfW:
      call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
  cfV:
      _sf3::P32 = R1;
      _sf4::P32 = P32[_sf3::P32 + 3];
      _sf5::P32 = P32[_sf3::P32 + 7];
      _sf6::P32 = P32[_sf3::P32 + 11];
      _sf7::P32 = P32[_sf3::P32 + 15];
      _sf8::P32 = P32[_sf3::P32 + 19];
      _sf9::P32 = P32[_sf3::P32 + 23];
      R1 = _sf4::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cfY:
      _sf2::P32 = P32[(old + 8)];
      goto cfT;
  cfT:
      if (Sp - <highSp> < SpLim) goto cfZ; else goto cg0;
  cfZ:
      R1 = T2902_Sum.insert_closure;
      P32[(old + 8)] = _sf2::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cg0:
      I32[(young<cfV> + 4)] = cfV;
      R1 = _sf2::P32;
      if (R1 & 3 != 0) goto cfV; else goto cfW;
  cfW:
      call (I32[R1])(R1) returns to cfV, args: 4, res: 4, upd: 4;
  cfV:
      _sf3::P32 = R1;
      _sf4::P32 = P32[_sf3::P32 + 3];
      _sf5::P32 = P32[_sf3::P32 + 7];
      _sf6::P32 = P32[_sf3::P32 + 11];
      _sf7::P32 = P32[_sf3::P32 + 15];
      _sf8::P32 = P32[_sf3::P32 + 19];
      _sf9::P32 = P32[_sf3::P32 + 23];
      R1 = _sf4::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cfY:
      _sf2::P32 = P32[(old + 8)];
      goto cfT;
  cfT:
      if (Sp - <highSp> < SpLim) goto cfZ; else goto cg0;
  cfZ:
      R1 = T2902_Sum.insert_closure;
      P32[(old + 8)] = _sf2::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cg0:
      I32[(young<cfV> + 4)] = cfV;
      R1 = _sf2::P32;
      if (_sf2::P32 & 3 != 0) goto cfV; else goto cfW;
  cfW:
      call (I32[_sf2::P32])(R1) returns to cfV, args: 4, res: 4, upd: 4;
  cfV:
      _sf3::P32 = R1;
      _sf4::P32 = P32[R1 + 3];
      _sf5::P32 = P32[R1 + 7];
      _sf6::P32 = P32[R1 + 11];
      _sf7::P32 = P32[R1 + 15];
      _sf8::P32 = P32[R1 + 19];
      _sf9::P32 = P32[R1 + 23];
      R1 = _sf4::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cfY:
      _sf2::P32 = P32[Sp];
      goto cfT;
  cfT:
      goto cg0;
  cg0:
      I32[Sp] = cfV;
      R1 = _sf2::P32;
      if (_sf2::P32 & 3 != 0) goto cfV; else goto cfW;
  cfW:
      call (I32[_sf2::P32])(R1) returns to cfV, args: 4, res: 4, upd: 4;
  cfV:
      _sf3::P32 = R1;
      _sf4::P32 = P32[R1 + 3];
      _sf5::P32 = P32[R1 + 7];
      _sf6::P32 = P32[R1 + 11];
      _sf7::P32 = P32[R1 + 15];
      _sf8::P32 = P32[R1 + 19];
      _sf9::P32 = P32[R1 + 23];
      R1 = _sf4::P32;
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cfY:
      goto cfT;
  cfT:
      goto cg0;
  cg0:
      _sf2::P32 = P32[Sp];
      I32[Sp] = cfV;
      R1 = _sf2::P32;
      if (_sf2::P32 & 3 != 0) goto cfV; else goto cfW;
  cfW:
      call (I32[_sf2::P32])(R1) returns to cfV, args: 4, res: 4, upd: 4;
  cfV:
      R1 = P32[R1 + 3];
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cfT, {}), (cfV, {}), (cfW, {}), (cfY, {}), (cg0, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.insert_entry() //  []
        { info_tbl: [(cfV,
                      label: block_cfV_info
                      rep:StackRep []),
                     (cfY,
                      label: T2902_Sum.insert_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cfY:
          goto cfT;
      cfT:
          goto cg0;
      cg0:
          _sf2::P32 = P32[Sp];
          I32[Sp] = cfV;
          R1 = _sf2::P32;
          if (_sf2::P32 & 3 != 0) goto cfV; else goto cfW;
      cfW:
          call (I32[_sf2::P32])(R1) returns to cfV, args: 4, res: 4, upd: 4;
      cfV:
          R1 = P32[R1 + 3];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.insert_entry() //  []
        { info_tbl: [(cfV,
                      label: block_cfV_info
                      rep:StackRep []),
                     (cg0,
                      label: T2902_Sum.insert_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cg0:
          _sf2::P32 = P32[Sp];
          I32[Sp] = cfV;
          R1 = _sf2::P32;
          if (_sf2::P32 & 3 != 0) goto cfV; else goto cfW;
      cfW:
          call (I32[_sf2::P32])(R1) returns to cfV, args: 4, res: 4, upd: 4;
      cfV:
          R1 = P32[R1 + 3];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.insert_closure:
         const T2902_Sum.insert_info;
 },
 T2902_Sum.insert_entry() //  []
         { info_tbl: [(cfV,
                       label: block_cfV_info
                       rep:StackRep []),
                      (cg0,
                       label: T2902_Sum.insert_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cg0:
           _sf2::P32 = P32[Sp];
           I32[Sp] = cfV;
           R1 = _sf2::P32;
           if (_sf2::P32 & 3 != 0) goto cfV; else goto cfW;
       cfW:
           call (I32[_sf2::P32])(R1) returns to cfV, args: 4, res: 4, upd: 4;
       cfV:
           R1 = P32[R1 + 3];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.insert_closure:
         const T2902_Sum.insert_info;
 },
 T2902_Sum.insert_entry() //  []
         { info_tbl: [(cfV,
                       label: block_cfV_info
                       rep:StackRep []),
                      (cg0,
                       label: T2902_Sum.insert_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cg0:
           _sf2::P32 = P32[Sp];
           I32[Sp] = cfV;
           R1 = _sf2::P32;
           if (_sf2::P32 & 3 != 0) goto cfV; else goto cfW;
       cfW:
           call (I32[_sf2::P32])(R1) returns to cfV, args: 4, res: 4, upd: 4;
       cfV:
           R1 = P32[R1 + 3];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.union_closure:
         const T2902_Sum.union_info;
 },
 T2902_Sum.union_entry() //  []
         { info_tbl: [(cgi,
                       label: T2902_Sum.union_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgi:
           _sfa::P32 = P32[(old + 8)];
           goto cgd;
       cgd:
           if (Sp - <highSp> < SpLim) goto cgj; else goto cgk;
       cgj:
           R1 = T2902_Sum.union_closure;
           P32[(old + 8)] = _sfa::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cgk:
           I32[(young<cgf> + 4)] = cgf;
           R1 = _sfa::P32;
           if (R1 & 3 != 0) goto cgf; else goto cgg;
       cgg:
           call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
       cgf:
           _sfb::P32 = R1;
           _sfc::P32 = P32[_sfb::P32 + 3];
           _sfd::P32 = P32[_sfb::P32 + 7];
           _sfe::P32 = P32[_sfb::P32 + 11];
           _sff::P32 = P32[_sfb::P32 + 15];
           _sfg::P32 = P32[_sfb::P32 + 19];
           _sfh::P32 = P32[_sfb::P32 + 23];
           R1 = _sfd::P32;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cgi:
      _sfa::P32 = P32[(old + 8)];
      goto cgd;
  cgd:
      if (Sp - <highSp> < SpLim) goto cgj; else goto cgk;
  cgj:
      R1 = T2902_Sum.union_closure;
      P32[(old + 8)] = _sfa::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgk:
      I32[(young<cgf> + 4)] = cgf;
      R1 = _sfa::P32;
      if (R1 & 3 != 0) goto cgf; else goto cgg;
  cgg:
      call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
  cgf:
      _sfb::P32 = R1;
      _sfc::P32 = P32[_sfb::P32 + 3];
      _sfd::P32 = P32[_sfb::P32 + 7];
      _sfe::P32 = P32[_sfb::P32 + 11];
      _sff::P32 = P32[_sfb::P32 + 15];
      _sfg::P32 = P32[_sfb::P32 + 19];
      _sfh::P32 = P32[_sfb::P32 + 23];
      R1 = _sfd::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cgi:
      _sfa::P32 = P32[(old + 8)];
      goto cgd;
  cgd:
      if (Sp - <highSp> < SpLim) goto cgj; else goto cgk;
  cgj:
      R1 = T2902_Sum.union_closure;
      P32[(old + 8)] = _sfa::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgk:
      I32[(young<cgf> + 4)] = cgf;
      R1 = _sfa::P32;
      if (R1 & 3 != 0) goto cgf; else goto cgg;
  cgg:
      call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
  cgf:
      _sfb::P32 = R1;
      _sfc::P32 = P32[_sfb::P32 + 3];
      _sfd::P32 = P32[_sfb::P32 + 7];
      _sfe::P32 = P32[_sfb::P32 + 11];
      _sff::P32 = P32[_sfb::P32 + 15];
      _sfg::P32 = P32[_sfb::P32 + 19];
      _sfh::P32 = P32[_sfb::P32 + 23];
      R1 = _sfd::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cgi:
      _sfa::P32 = P32[(old + 8)];
      goto cgd;
  cgd:
      if (Sp - <highSp> < SpLim) goto cgj; else goto cgk;
  cgj:
      R1 = T2902_Sum.union_closure;
      P32[(old + 8)] = _sfa::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgk:
      I32[(young<cgf> + 4)] = cgf;
      R1 = _sfa::P32;
      if (R1 & 3 != 0) goto cgf; else goto cgg;
  cgg:
      call (I32[R1])(R1) returns to cgf, args: 4, res: 4, upd: 4;
  cgf:
      _sfb::P32 = R1;
      _sfc::P32 = P32[_sfb::P32 + 3];
      _sfd::P32 = P32[_sfb::P32 + 7];
      _sfe::P32 = P32[_sfb::P32 + 11];
      _sff::P32 = P32[_sfb::P32 + 15];
      _sfg::P32 = P32[_sfb::P32 + 19];
      _sfh::P32 = P32[_sfb::P32 + 23];
      R1 = _sfd::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cgi:
      _sfa::P32 = P32[(old + 8)];
      goto cgd;
  cgd:
      if (Sp - <highSp> < SpLim) goto cgj; else goto cgk;
  cgj:
      R1 = T2902_Sum.union_closure;
      P32[(old + 8)] = _sfa::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgk:
      I32[(young<cgf> + 4)] = cgf;
      R1 = _sfa::P32;
      if (_sfa::P32 & 3 != 0) goto cgf; else goto cgg;
  cgg:
      call (I32[_sfa::P32])(R1) returns to cgf, args: 4, res: 4, upd: 4;
  cgf:
      _sfb::P32 = R1;
      _sfc::P32 = P32[R1 + 3];
      _sfd::P32 = P32[R1 + 7];
      _sfe::P32 = P32[R1 + 11];
      _sff::P32 = P32[R1 + 15];
      _sfg::P32 = P32[R1 + 19];
      _sfh::P32 = P32[R1 + 23];
      R1 = _sfd::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cgi:
      _sfa::P32 = P32[Sp];
      goto cgd;
  cgd:
      goto cgk;
  cgk:
      I32[Sp] = cgf;
      R1 = _sfa::P32;
      if (_sfa::P32 & 3 != 0) goto cgf; else goto cgg;
  cgg:
      call (I32[_sfa::P32])(R1) returns to cgf, args: 4, res: 4, upd: 4;
  cgf:
      _sfb::P32 = R1;
      _sfc::P32 = P32[R1 + 3];
      _sfd::P32 = P32[R1 + 7];
      _sfe::P32 = P32[R1 + 11];
      _sff::P32 = P32[R1 + 15];
      _sfg::P32 = P32[R1 + 19];
      _sfh::P32 = P32[R1 + 23];
      R1 = _sfd::P32;
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cgi:
      goto cgd;
  cgd:
      goto cgk;
  cgk:
      _sfa::P32 = P32[Sp];
      I32[Sp] = cgf;
      R1 = _sfa::P32;
      if (_sfa::P32 & 3 != 0) goto cgf; else goto cgg;
  cgg:
      call (I32[_sfa::P32])(R1) returns to cgf, args: 4, res: 4, upd: 4;
  cgf:
      R1 = P32[R1 + 7];
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cgd, {}), (cgf, {}), (cgg, {}), (cgi, {}), (cgk, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.union_entry() //  []
        { info_tbl: [(cgf,
                      label: block_cgf_info
                      rep:StackRep []),
                     (cgi,
                      label: T2902_Sum.union_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cgi:
          goto cgd;
      cgd:
          goto cgk;
      cgk:
          _sfa::P32 = P32[Sp];
          I32[Sp] = cgf;
          R1 = _sfa::P32;
          if (_sfa::P32 & 3 != 0) goto cgf; else goto cgg;
      cgg:
          call (I32[_sfa::P32])(R1) returns to cgf, args: 4, res: 4, upd: 4;
      cgf:
          R1 = P32[R1 + 7];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.union_entry() //  []
        { info_tbl: [(cgf,
                      label: block_cgf_info
                      rep:StackRep []),
                     (cgk,
                      label: T2902_Sum.union_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cgk:
          _sfa::P32 = P32[Sp];
          I32[Sp] = cgf;
          R1 = _sfa::P32;
          if (_sfa::P32 & 3 != 0) goto cgf; else goto cgg;
      cgg:
          call (I32[_sfa::P32])(R1) returns to cgf, args: 4, res: 4, upd: 4;
      cgf:
          R1 = P32[R1 + 7];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.union_closure:
         const T2902_Sum.union_info;
 },
 T2902_Sum.union_entry() //  []
         { info_tbl: [(cgf,
                       label: block_cgf_info
                       rep:StackRep []),
                      (cgk,
                       label: T2902_Sum.union_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgk:
           _sfa::P32 = P32[Sp];
           I32[Sp] = cgf;
           R1 = _sfa::P32;
           if (_sfa::P32 & 3 != 0) goto cgf; else goto cgg;
       cgg:
           call (I32[_sfa::P32])(R1) returns to cgf, args: 4, res: 4, upd: 4;
       cgf:
           R1 = P32[R1 + 7];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.union_closure:
         const T2902_Sum.union_info;
 },
 T2902_Sum.union_entry() //  []
         { info_tbl: [(cgf,
                       label: block_cgf_info
                       rep:StackRep []),
                      (cgk,
                       label: T2902_Sum.union_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgk:
           _sfa::P32 = P32[Sp];
           I32[Sp] = cgf;
           R1 = _sfa::P32;
           if (_sfa::P32 & 3 != 0) goto cgf; else goto cgg;
       cgg:
           call (I32[_sfa::P32])(R1) returns to cgf, args: 4, res: 4, upd: 4;
       cgf:
           R1 = P32[R1 + 7];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.unions_closure:
         const T2902_Sum.unions_info;
 },
 T2902_Sum.unions_entry() //  []
         { info_tbl: [(cgC,
                       label: T2902_Sum.unions_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgC:
           _sfi::P32 = P32[(old + 8)];
           goto cgx;
       cgx:
           if (Sp - <highSp> < SpLim) goto cgD; else goto cgE;
       cgD:
           R1 = T2902_Sum.unions_closure;
           P32[(old + 8)] = _sfi::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cgE:
           I32[(young<cgz> + 4)] = cgz;
           R1 = _sfi::P32;
           if (R1 & 3 != 0) goto cgz; else goto cgA;
       cgA:
           call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
       cgz:
           _sfj::P32 = R1;
           _sfk::P32 = P32[_sfj::P32 + 3];
           _sfl::P32 = P32[_sfj::P32 + 7];
           _sfm::P32 = P32[_sfj::P32 + 11];
           _sfn::P32 = P32[_sfj::P32 + 15];
           _sfo::P32 = P32[_sfj::P32 + 19];
           _sfp::P32 = P32[_sfj::P32 + 23];
           R1 = _sfm::P32;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cgC:
      _sfi::P32 = P32[(old + 8)];
      goto cgx;
  cgx:
      if (Sp - <highSp> < SpLim) goto cgD; else goto cgE;
  cgD:
      R1 = T2902_Sum.unions_closure;
      P32[(old + 8)] = _sfi::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgE:
      I32[(young<cgz> + 4)] = cgz;
      R1 = _sfi::P32;
      if (R1 & 3 != 0) goto cgz; else goto cgA;
  cgA:
      call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
  cgz:
      _sfj::P32 = R1;
      _sfk::P32 = P32[_sfj::P32 + 3];
      _sfl::P32 = P32[_sfj::P32 + 7];
      _sfm::P32 = P32[_sfj::P32 + 11];
      _sfn::P32 = P32[_sfj::P32 + 15];
      _sfo::P32 = P32[_sfj::P32 + 19];
      _sfp::P32 = P32[_sfj::P32 + 23];
      R1 = _sfm::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cgC:
      _sfi::P32 = P32[(old + 8)];
      goto cgx;
  cgx:
      if (Sp - <highSp> < SpLim) goto cgD; else goto cgE;
  cgD:
      R1 = T2902_Sum.unions_closure;
      P32[(old + 8)] = _sfi::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgE:
      I32[(young<cgz> + 4)] = cgz;
      R1 = _sfi::P32;
      if (R1 & 3 != 0) goto cgz; else goto cgA;
  cgA:
      call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
  cgz:
      _sfj::P32 = R1;
      _sfk::P32 = P32[_sfj::P32 + 3];
      _sfl::P32 = P32[_sfj::P32 + 7];
      _sfm::P32 = P32[_sfj::P32 + 11];
      _sfn::P32 = P32[_sfj::P32 + 15];
      _sfo::P32 = P32[_sfj::P32 + 19];
      _sfp::P32 = P32[_sfj::P32 + 23];
      R1 = _sfm::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cgC:
      _sfi::P32 = P32[(old + 8)];
      goto cgx;
  cgx:
      if (Sp - <highSp> < SpLim) goto cgD; else goto cgE;
  cgD:
      R1 = T2902_Sum.unions_closure;
      P32[(old + 8)] = _sfi::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgE:
      I32[(young<cgz> + 4)] = cgz;
      R1 = _sfi::P32;
      if (R1 & 3 != 0) goto cgz; else goto cgA;
  cgA:
      call (I32[R1])(R1) returns to cgz, args: 4, res: 4, upd: 4;
  cgz:
      _sfj::P32 = R1;
      _sfk::P32 = P32[_sfj::P32 + 3];
      _sfl::P32 = P32[_sfj::P32 + 7];
      _sfm::P32 = P32[_sfj::P32 + 11];
      _sfn::P32 = P32[_sfj::P32 + 15];
      _sfo::P32 = P32[_sfj::P32 + 19];
      _sfp::P32 = P32[_sfj::P32 + 23];
      R1 = _sfm::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cgC:
      _sfi::P32 = P32[(old + 8)];
      goto cgx;
  cgx:
      if (Sp - <highSp> < SpLim) goto cgD; else goto cgE;
  cgD:
      R1 = T2902_Sum.unions_closure;
      P32[(old + 8)] = _sfi::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgE:
      I32[(young<cgz> + 4)] = cgz;
      R1 = _sfi::P32;
      if (_sfi::P32 & 3 != 0) goto cgz; else goto cgA;
  cgA:
      call (I32[_sfi::P32])(R1) returns to cgz, args: 4, res: 4, upd: 4;
  cgz:
      _sfj::P32 = R1;
      _sfk::P32 = P32[R1 + 3];
      _sfl::P32 = P32[R1 + 7];
      _sfm::P32 = P32[R1 + 11];
      _sfn::P32 = P32[R1 + 15];
      _sfo::P32 = P32[R1 + 19];
      _sfp::P32 = P32[R1 + 23];
      R1 = _sfm::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cgC:
      _sfi::P32 = P32[Sp];
      goto cgx;
  cgx:
      goto cgE;
  cgE:
      I32[Sp] = cgz;
      R1 = _sfi::P32;
      if (_sfi::P32 & 3 != 0) goto cgz; else goto cgA;
  cgA:
      call (I32[_sfi::P32])(R1) returns to cgz, args: 4, res: 4, upd: 4;
  cgz:
      _sfj::P32 = R1;
      _sfk::P32 = P32[R1 + 3];
      _sfl::P32 = P32[R1 + 7];
      _sfm::P32 = P32[R1 + 11];
      _sfn::P32 = P32[R1 + 15];
      _sfo::P32 = P32[R1 + 19];
      _sfp::P32 = P32[R1 + 23];
      R1 = _sfm::P32;
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cgC:
      goto cgx;
  cgx:
      goto cgE;
  cgE:
      _sfi::P32 = P32[Sp];
      I32[Sp] = cgz;
      R1 = _sfi::P32;
      if (_sfi::P32 & 3 != 0) goto cgz; else goto cgA;
  cgA:
      call (I32[_sfi::P32])(R1) returns to cgz, args: 4, res: 4, upd: 4;
  cgz:
      R1 = P32[R1 + 11];
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cgx, {}), (cgz, {}), (cgA, {}), (cgC, {}), (cgE, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.unions_entry() //  []
        { info_tbl: [(cgz,
                      label: block_cgz_info
                      rep:StackRep []),
                     (cgC,
                      label: T2902_Sum.unions_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cgC:
          goto cgx;
      cgx:
          goto cgE;
      cgE:
          _sfi::P32 = P32[Sp];
          I32[Sp] = cgz;
          R1 = _sfi::P32;
          if (_sfi::P32 & 3 != 0) goto cgz; else goto cgA;
      cgA:
          call (I32[_sfi::P32])(R1) returns to cgz, args: 4, res: 4, upd: 4;
      cgz:
          R1 = P32[R1 + 11];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.unions_entry() //  []
        { info_tbl: [(cgz,
                      label: block_cgz_info
                      rep:StackRep []),
                     (cgE,
                      label: T2902_Sum.unions_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cgE:
          _sfi::P32 = P32[Sp];
          I32[Sp] = cgz;
          R1 = _sfi::P32;
          if (_sfi::P32 & 3 != 0) goto cgz; else goto cgA;
      cgA:
          call (I32[_sfi::P32])(R1) returns to cgz, args: 4, res: 4, upd: 4;
      cgz:
          R1 = P32[R1 + 11];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.unions_closure:
         const T2902_Sum.unions_info;
 },
 T2902_Sum.unions_entry() //  []
         { info_tbl: [(cgz,
                       label: block_cgz_info
                       rep:StackRep []),
                      (cgE,
                       label: T2902_Sum.unions_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgE:
           _sfi::P32 = P32[Sp];
           I32[Sp] = cgz;
           R1 = _sfi::P32;
           if (_sfi::P32 & 3 != 0) goto cgz; else goto cgA;
       cgA:
           call (I32[_sfi::P32])(R1) returns to cgz, args: 4, res: 4, upd: 4;
       cgz:
           R1 = P32[R1 + 11];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.unions_closure:
         const T2902_Sum.unions_info;
 },
 T2902_Sum.unions_entry() //  []
         { info_tbl: [(cgz,
                       label: block_cgz_info
                       rep:StackRep []),
                      (cgE,
                       label: T2902_Sum.unions_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgE:
           _sfi::P32 = P32[Sp];
           I32[Sp] = cgz;
           R1 = _sfi::P32;
           if (_sfi::P32 & 3 != 0) goto cgz; else goto cgA;
       cgA:
           call (I32[_sfi::P32])(R1) returns to cgz, args: 4, res: 4, upd: 4;
       cgz:
           R1 = P32[R1 + 11];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.extractMin_closure:
         const T2902_Sum.extractMin_info;
 },
 T2902_Sum.extractMin_entry() //  []
         { info_tbl: [(cgW,
                       label: T2902_Sum.extractMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgW:
           _sfq::P32 = P32[(old + 8)];
           goto cgR;
       cgR:
           if (Sp - <highSp> < SpLim) goto cgX; else goto cgY;
       cgX:
           R1 = T2902_Sum.extractMin_closure;
           P32[(old + 8)] = _sfq::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cgY:
           I32[(young<cgT> + 4)] = cgT;
           R1 = _sfq::P32;
           if (R1 & 3 != 0) goto cgT; else goto cgU;
       cgU:
           call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
       cgT:
           _sfr::P32 = R1;
           _sfs::P32 = P32[_sfr::P32 + 3];
           _sft::P32 = P32[_sfr::P32 + 7];
           _sfu::P32 = P32[_sfr::P32 + 11];
           _sfv::P32 = P32[_sfr::P32 + 15];
           _sfw::P32 = P32[_sfr::P32 + 19];
           _sfx::P32 = P32[_sfr::P32 + 23];
           R1 = _sfv::P32;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cgW:
      _sfq::P32 = P32[(old + 8)];
      goto cgR;
  cgR:
      if (Sp - <highSp> < SpLim) goto cgX; else goto cgY;
  cgX:
      R1 = T2902_Sum.extractMin_closure;
      P32[(old + 8)] = _sfq::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgY:
      I32[(young<cgT> + 4)] = cgT;
      R1 = _sfq::P32;
      if (R1 & 3 != 0) goto cgT; else goto cgU;
  cgU:
      call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
  cgT:
      _sfr::P32 = R1;
      _sfs::P32 = P32[_sfr::P32 + 3];
      _sft::P32 = P32[_sfr::P32 + 7];
      _sfu::P32 = P32[_sfr::P32 + 11];
      _sfv::P32 = P32[_sfr::P32 + 15];
      _sfw::P32 = P32[_sfr::P32 + 19];
      _sfx::P32 = P32[_sfr::P32 + 23];
      R1 = _sfv::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cgW:
      _sfq::P32 = P32[(old + 8)];
      goto cgR;
  cgR:
      if (Sp - <highSp> < SpLim) goto cgX; else goto cgY;
  cgX:
      R1 = T2902_Sum.extractMin_closure;
      P32[(old + 8)] = _sfq::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgY:
      I32[(young<cgT> + 4)] = cgT;
      R1 = _sfq::P32;
      if (R1 & 3 != 0) goto cgT; else goto cgU;
  cgU:
      call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
  cgT:
      _sfr::P32 = R1;
      _sfs::P32 = P32[_sfr::P32 + 3];
      _sft::P32 = P32[_sfr::P32 + 7];
      _sfu::P32 = P32[_sfr::P32 + 11];
      _sfv::P32 = P32[_sfr::P32 + 15];
      _sfw::P32 = P32[_sfr::P32 + 19];
      _sfx::P32 = P32[_sfr::P32 + 23];
      R1 = _sfv::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cgW:
      _sfq::P32 = P32[(old + 8)];
      goto cgR;
  cgR:
      if (Sp - <highSp> < SpLim) goto cgX; else goto cgY;
  cgX:
      R1 = T2902_Sum.extractMin_closure;
      P32[(old + 8)] = _sfq::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgY:
      I32[(young<cgT> + 4)] = cgT;
      R1 = _sfq::P32;
      if (R1 & 3 != 0) goto cgT; else goto cgU;
  cgU:
      call (I32[R1])(R1) returns to cgT, args: 4, res: 4, upd: 4;
  cgT:
      _sfr::P32 = R1;
      _sfs::P32 = P32[_sfr::P32 + 3];
      _sft::P32 = P32[_sfr::P32 + 7];
      _sfu::P32 = P32[_sfr::P32 + 11];
      _sfv::P32 = P32[_sfr::P32 + 15];
      _sfw::P32 = P32[_sfr::P32 + 19];
      _sfx::P32 = P32[_sfr::P32 + 23];
      R1 = _sfv::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cgW:
      _sfq::P32 = P32[(old + 8)];
      goto cgR;
  cgR:
      if (Sp - <highSp> < SpLim) goto cgX; else goto cgY;
  cgX:
      R1 = T2902_Sum.extractMin_closure;
      P32[(old + 8)] = _sfq::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cgY:
      I32[(young<cgT> + 4)] = cgT;
      R1 = _sfq::P32;
      if (_sfq::P32 & 3 != 0) goto cgT; else goto cgU;
  cgU:
      call (I32[_sfq::P32])(R1) returns to cgT, args: 4, res: 4, upd: 4;
  cgT:
      _sfr::P32 = R1;
      _sfs::P32 = P32[R1 + 3];
      _sft::P32 = P32[R1 + 7];
      _sfu::P32 = P32[R1 + 11];
      _sfv::P32 = P32[R1 + 15];
      _sfw::P32 = P32[R1 + 19];
      _sfx::P32 = P32[R1 + 23];
      R1 = _sfv::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cgW:
      _sfq::P32 = P32[Sp];
      goto cgR;
  cgR:
      goto cgY;
  cgY:
      I32[Sp] = cgT;
      R1 = _sfq::P32;
      if (_sfq::P32 & 3 != 0) goto cgT; else goto cgU;
  cgU:
      call (I32[_sfq::P32])(R1) returns to cgT, args: 4, res: 4, upd: 4;
  cgT:
      _sfr::P32 = R1;
      _sfs::P32 = P32[R1 + 3];
      _sft::P32 = P32[R1 + 7];
      _sfu::P32 = P32[R1 + 11];
      _sfv::P32 = P32[R1 + 15];
      _sfw::P32 = P32[R1 + 19];
      _sfx::P32 = P32[R1 + 23];
      R1 = _sfv::P32;
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cgW:
      goto cgR;
  cgR:
      goto cgY;
  cgY:
      _sfq::P32 = P32[Sp];
      I32[Sp] = cgT;
      R1 = _sfq::P32;
      if (_sfq::P32 & 3 != 0) goto cgT; else goto cgU;
  cgU:
      call (I32[_sfq::P32])(R1) returns to cgT, args: 4, res: 4, upd: 4;
  cgT:
      R1 = P32[R1 + 15];
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cgR, {}), (cgT, {}), (cgU, {}), (cgW, {}), (cgY, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.extractMin_entry() //  []
        { info_tbl: [(cgT,
                      label: block_cgT_info
                      rep:StackRep []),
                     (cgW,
                      label: T2902_Sum.extractMin_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cgW:
          goto cgR;
      cgR:
          goto cgY;
      cgY:
          _sfq::P32 = P32[Sp];
          I32[Sp] = cgT;
          R1 = _sfq::P32;
          if (_sfq::P32 & 3 != 0) goto cgT; else goto cgU;
      cgU:
          call (I32[_sfq::P32])(R1) returns to cgT, args: 4, res: 4, upd: 4;
      cgT:
          R1 = P32[R1 + 15];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.extractMin_entry() //  []
        { info_tbl: [(cgT,
                      label: block_cgT_info
                      rep:StackRep []),
                     (cgY,
                      label: T2902_Sum.extractMin_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cgY:
          _sfq::P32 = P32[Sp];
          I32[Sp] = cgT;
          R1 = _sfq::P32;
          if (_sfq::P32 & 3 != 0) goto cgT; else goto cgU;
      cgU:
          call (I32[_sfq::P32])(R1) returns to cgT, args: 4, res: 4, upd: 4;
      cgT:
          R1 = P32[R1 + 15];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.extractMin_closure:
         const T2902_Sum.extractMin_info;
 },
 T2902_Sum.extractMin_entry() //  []
         { info_tbl: [(cgT,
                       label: block_cgT_info
                       rep:StackRep []),
                      (cgY,
                       label: T2902_Sum.extractMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgY:
           _sfq::P32 = P32[Sp];
           I32[Sp] = cgT;
           R1 = _sfq::P32;
           if (_sfq::P32 & 3 != 0) goto cgT; else goto cgU;
       cgU:
           call (I32[_sfq::P32])(R1) returns to cgT, args: 4, res: 4, upd: 4;
       cgT:
           R1 = P32[R1 + 15];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.extractMin_closure:
         const T2902_Sum.extractMin_info;
 },
 T2902_Sum.extractMin_entry() //  []
         { info_tbl: [(cgT,
                       label: block_cgT_info
                       rep:StackRep []),
                      (cgY,
                       label: T2902_Sum.extractMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cgY:
           _sfq::P32 = P32[Sp];
           I32[Sp] = cgT;
           R1 = _sfq::P32;
           if (_sfq::P32 & 3 != 0) goto cgT; else goto cgU;
       cgU:
           call (I32[_sfq::P32])(R1) returns to cgT, args: 4, res: 4, upd: 4;
       cgT:
           R1 = P32[R1 + 15];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.fromList_closure:
         const T2902_Sum.fromList_info;
 },
 T2902_Sum.fromList_entry() //  []
         { info_tbl: [(chg,
                       label: T2902_Sum.fromList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       chg:
           _sfy::P32 = P32[(old + 8)];
           goto chb;
       chb:
           if (Sp - <highSp> < SpLim) goto chh; else goto chi;
       chh:
           R1 = T2902_Sum.fromList_closure;
           P32[(old + 8)] = _sfy::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       chi:
           I32[(young<chd> + 4)] = chd;
           R1 = _sfy::P32;
           if (R1 & 3 != 0) goto chd; else goto che;
       che:
           call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
       chd:
           _sfz::P32 = R1;
           _sfA::P32 = P32[_sfz::P32 + 3];
           _sfB::P32 = P32[_sfz::P32 + 7];
           _sfC::P32 = P32[_sfz::P32 + 11];
           _sfD::P32 = P32[_sfz::P32 + 15];
           _sfE::P32 = P32[_sfz::P32 + 19];
           _sfF::P32 = P32[_sfz::P32 + 23];
           R1 = _sfE::P32;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  chg:
      _sfy::P32 = P32[(old + 8)];
      goto chb;
  chb:
      if (Sp - <highSp> < SpLim) goto chh; else goto chi;
  chh:
      R1 = T2902_Sum.fromList_closure;
      P32[(old + 8)] = _sfy::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chi:
      I32[(young<chd> + 4)] = chd;
      R1 = _sfy::P32;
      if (R1 & 3 != 0) goto chd; else goto che;
  che:
      call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
  chd:
      _sfz::P32 = R1;
      _sfA::P32 = P32[_sfz::P32 + 3];
      _sfB::P32 = P32[_sfz::P32 + 7];
      _sfC::P32 = P32[_sfz::P32 + 11];
      _sfD::P32 = P32[_sfz::P32 + 15];
      _sfE::P32 = P32[_sfz::P32 + 19];
      _sfF::P32 = P32[_sfz::P32 + 23];
      R1 = _sfE::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  chg:
      _sfy::P32 = P32[(old + 8)];
      goto chb;
  chb:
      if (Sp - <highSp> < SpLim) goto chh; else goto chi;
  chh:
      R1 = T2902_Sum.fromList_closure;
      P32[(old + 8)] = _sfy::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chi:
      I32[(young<chd> + 4)] = chd;
      R1 = _sfy::P32;
      if (R1 & 3 != 0) goto chd; else goto che;
  che:
      call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
  chd:
      _sfz::P32 = R1;
      _sfA::P32 = P32[_sfz::P32 + 3];
      _sfB::P32 = P32[_sfz::P32 + 7];
      _sfC::P32 = P32[_sfz::P32 + 11];
      _sfD::P32 = P32[_sfz::P32 + 15];
      _sfE::P32 = P32[_sfz::P32 + 19];
      _sfF::P32 = P32[_sfz::P32 + 23];
      R1 = _sfE::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  chg:
      _sfy::P32 = P32[(old + 8)];
      goto chb;
  chb:
      if (Sp - <highSp> < SpLim) goto chh; else goto chi;
  chh:
      R1 = T2902_Sum.fromList_closure;
      P32[(old + 8)] = _sfy::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chi:
      I32[(young<chd> + 4)] = chd;
      R1 = _sfy::P32;
      if (R1 & 3 != 0) goto chd; else goto che;
  che:
      call (I32[R1])(R1) returns to chd, args: 4, res: 4, upd: 4;
  chd:
      _sfz::P32 = R1;
      _sfA::P32 = P32[_sfz::P32 + 3];
      _sfB::P32 = P32[_sfz::P32 + 7];
      _sfC::P32 = P32[_sfz::P32 + 11];
      _sfD::P32 = P32[_sfz::P32 + 15];
      _sfE::P32 = P32[_sfz::P32 + 19];
      _sfF::P32 = P32[_sfz::P32 + 23];
      R1 = _sfE::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  chg:
      _sfy::P32 = P32[(old + 8)];
      goto chb;
  chb:
      if (Sp - <highSp> < SpLim) goto chh; else goto chi;
  chh:
      R1 = T2902_Sum.fromList_closure;
      P32[(old + 8)] = _sfy::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chi:
      I32[(young<chd> + 4)] = chd;
      R1 = _sfy::P32;
      if (_sfy::P32 & 3 != 0) goto chd; else goto che;
  che:
      call (I32[_sfy::P32])(R1) returns to chd, args: 4, res: 4, upd: 4;
  chd:
      _sfz::P32 = R1;
      _sfA::P32 = P32[R1 + 3];
      _sfB::P32 = P32[R1 + 7];
      _sfC::P32 = P32[R1 + 11];
      _sfD::P32 = P32[R1 + 15];
      _sfE::P32 = P32[R1 + 19];
      _sfF::P32 = P32[R1 + 23];
      R1 = _sfE::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  chg:
      _sfy::P32 = P32[Sp];
      goto chb;
  chb:
      goto chi;
  chi:
      I32[Sp] = chd;
      R1 = _sfy::P32;
      if (_sfy::P32 & 3 != 0) goto chd; else goto che;
  che:
      call (I32[_sfy::P32])(R1) returns to chd, args: 4, res: 4, upd: 4;
  chd:
      _sfz::P32 = R1;
      _sfA::P32 = P32[R1 + 3];
      _sfB::P32 = P32[R1 + 7];
      _sfC::P32 = P32[R1 + 11];
      _sfD::P32 = P32[R1 + 15];
      _sfE::P32 = P32[R1 + 19];
      _sfF::P32 = P32[R1 + 23];
      R1 = _sfE::P32;
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  chg:
      goto chb;
  chb:
      goto chi;
  chi:
      _sfy::P32 = P32[Sp];
      I32[Sp] = chd;
      R1 = _sfy::P32;
      if (_sfy::P32 & 3 != 0) goto chd; else goto che;
  che:
      call (I32[_sfy::P32])(R1) returns to chd, args: 4, res: 4, upd: 4;
  chd:
      R1 = P32[R1 + 19];
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(chb, {}), (chd, {}), (che, {}), (chg, {}), (chi, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.fromList_entry() //  []
        { info_tbl: [(chd,
                      label: block_chd_info
                      rep:StackRep []),
                     (chg,
                      label: T2902_Sum.fromList_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      chg:
          goto chb;
      chb:
          goto chi;
      chi:
          _sfy::P32 = P32[Sp];
          I32[Sp] = chd;
          R1 = _sfy::P32;
          if (_sfy::P32 & 3 != 0) goto chd; else goto che;
      che:
          call (I32[_sfy::P32])(R1) returns to chd, args: 4, res: 4, upd: 4;
      chd:
          R1 = P32[R1 + 19];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.fromList_entry() //  []
        { info_tbl: [(chd,
                      label: block_chd_info
                      rep:StackRep []),
                     (chi,
                      label: T2902_Sum.fromList_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      chi:
          _sfy::P32 = P32[Sp];
          I32[Sp] = chd;
          R1 = _sfy::P32;
          if (_sfy::P32 & 3 != 0) goto chd; else goto che;
      che:
          call (I32[_sfy::P32])(R1) returns to chd, args: 4, res: 4, upd: 4;
      chd:
          R1 = P32[R1 + 19];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.fromList_closure:
         const T2902_Sum.fromList_info;
 },
 T2902_Sum.fromList_entry() //  []
         { info_tbl: [(chd,
                       label: block_chd_info
                       rep:StackRep []),
                      (chi,
                       label: T2902_Sum.fromList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       chi:
           _sfy::P32 = P32[Sp];
           I32[Sp] = chd;
           R1 = _sfy::P32;
           if (_sfy::P32 & 3 != 0) goto chd; else goto che;
       che:
           call (I32[_sfy::P32])(R1) returns to chd, args: 4, res: 4, upd: 4;
       chd:
           R1 = P32[R1 + 19];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.fromList_closure:
         const T2902_Sum.fromList_info;
 },
 T2902_Sum.fromList_entry() //  []
         { info_tbl: [(chd,
                       label: block_chd_info
                       rep:StackRep []),
                      (chi,
                       label: T2902_Sum.fromList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       chi:
           _sfy::P32 = P32[Sp];
           I32[Sp] = chd;
           R1 = _sfy::P32;
           if (_sfy::P32 & 3 != 0) goto chd; else goto che;
       che:
           call (I32[_sfy::P32])(R1) returns to chd, args: 4, res: 4, upd: 4;
       chd:
           R1 = P32[R1 + 19];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.toList_closure:
         const T2902_Sum.toList_info;
 },
 T2902_Sum.toList_entry() //  []
         { info_tbl: [(chA,
                       label: T2902_Sum.toList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       chA:
           _sfG::P32 = P32[(old + 8)];
           goto chv;
       chv:
           if (Sp - <highSp> < SpLim) goto chB; else goto chC;
       chB:
           R1 = T2902_Sum.toList_closure;
           P32[(old + 8)] = _sfG::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       chC:
           I32[(young<chx> + 4)] = chx;
           R1 = _sfG::P32;
           if (R1 & 3 != 0) goto chx; else goto chy;
       chy:
           call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
       chx:
           _sfH::P32 = R1;
           _sfI::P32 = P32[_sfH::P32 + 3];
           _sfJ::P32 = P32[_sfH::P32 + 7];
           _sfK::P32 = P32[_sfH::P32 + 11];
           _sfL::P32 = P32[_sfH::P32 + 15];
           _sfM::P32 = P32[_sfH::P32 + 19];
           _sfN::P32 = P32[_sfH::P32 + 23];
           R1 = _sfN::P32;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  chA:
      _sfG::P32 = P32[(old + 8)];
      goto chv;
  chv:
      if (Sp - <highSp> < SpLim) goto chB; else goto chC;
  chB:
      R1 = T2902_Sum.toList_closure;
      P32[(old + 8)] = _sfG::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chC:
      I32[(young<chx> + 4)] = chx;
      R1 = _sfG::P32;
      if (R1 & 3 != 0) goto chx; else goto chy;
  chy:
      call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
  chx:
      _sfH::P32 = R1;
      _sfI::P32 = P32[_sfH::P32 + 3];
      _sfJ::P32 = P32[_sfH::P32 + 7];
      _sfK::P32 = P32[_sfH::P32 + 11];
      _sfL::P32 = P32[_sfH::P32 + 15];
      _sfM::P32 = P32[_sfH::P32 + 19];
      _sfN::P32 = P32[_sfH::P32 + 23];
      R1 = _sfN::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  chA:
      _sfG::P32 = P32[(old + 8)];
      goto chv;
  chv:
      if (Sp - <highSp> < SpLim) goto chB; else goto chC;
  chB:
      R1 = T2902_Sum.toList_closure;
      P32[(old + 8)] = _sfG::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chC:
      I32[(young<chx> + 4)] = chx;
      R1 = _sfG::P32;
      if (R1 & 3 != 0) goto chx; else goto chy;
  chy:
      call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
  chx:
      _sfH::P32 = R1;
      _sfI::P32 = P32[_sfH::P32 + 3];
      _sfJ::P32 = P32[_sfH::P32 + 7];
      _sfK::P32 = P32[_sfH::P32 + 11];
      _sfL::P32 = P32[_sfH::P32 + 15];
      _sfM::P32 = P32[_sfH::P32 + 19];
      _sfN::P32 = P32[_sfH::P32 + 23];
      R1 = _sfN::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  chA:
      _sfG::P32 = P32[(old + 8)];
      goto chv;
  chv:
      if (Sp - <highSp> < SpLim) goto chB; else goto chC;
  chB:
      R1 = T2902_Sum.toList_closure;
      P32[(old + 8)] = _sfG::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chC:
      I32[(young<chx> + 4)] = chx;
      R1 = _sfG::P32;
      if (R1 & 3 != 0) goto chx; else goto chy;
  chy:
      call (I32[R1])(R1) returns to chx, args: 4, res: 4, upd: 4;
  chx:
      _sfH::P32 = R1;
      _sfI::P32 = P32[_sfH::P32 + 3];
      _sfJ::P32 = P32[_sfH::P32 + 7];
      _sfK::P32 = P32[_sfH::P32 + 11];
      _sfL::P32 = P32[_sfH::P32 + 15];
      _sfM::P32 = P32[_sfH::P32 + 19];
      _sfN::P32 = P32[_sfH::P32 + 23];
      R1 = _sfN::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  chA:
      _sfG::P32 = P32[(old + 8)];
      goto chv;
  chv:
      if (Sp - <highSp> < SpLim) goto chB; else goto chC;
  chB:
      R1 = T2902_Sum.toList_closure;
      P32[(old + 8)] = _sfG::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  chC:
      I32[(young<chx> + 4)] = chx;
      R1 = _sfG::P32;
      if (_sfG::P32 & 3 != 0) goto chx; else goto chy;
  chy:
      call (I32[_sfG::P32])(R1) returns to chx, args: 4, res: 4, upd: 4;
  chx:
      _sfH::P32 = R1;
      _sfI::P32 = P32[R1 + 3];
      _sfJ::P32 = P32[R1 + 7];
      _sfK::P32 = P32[R1 + 11];
      _sfL::P32 = P32[R1 + 15];
      _sfM::P32 = P32[R1 + 19];
      _sfN::P32 = P32[R1 + 23];
      R1 = _sfN::P32;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  chA:
      _sfG::P32 = P32[Sp];
      goto chv;
  chv:
      goto chC;
  chC:
      I32[Sp] = chx;
      R1 = _sfG::P32;
      if (_sfG::P32 & 3 != 0) goto chx; else goto chy;
  chy:
      call (I32[_sfG::P32])(R1) returns to chx, args: 4, res: 4, upd: 4;
  chx:
      _sfH::P32 = R1;
      _sfI::P32 = P32[R1 + 3];
      _sfJ::P32 = P32[R1 + 7];
      _sfK::P32 = P32[R1 + 11];
      _sfL::P32 = P32[R1 + 15];
      _sfM::P32 = P32[R1 + 19];
      _sfN::P32 = P32[R1 + 23];
      R1 = _sfN::P32;
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  chA:
      goto chv;
  chv:
      goto chC;
  chC:
      _sfG::P32 = P32[Sp];
      I32[Sp] = chx;
      R1 = _sfG::P32;
      if (_sfG::P32 & 3 != 0) goto chx; else goto chy;
  chy:
      call (I32[_sfG::P32])(R1) returns to chx, args: 4, res: 4, upd: 4;
  chx:
      R1 = P32[R1 + 23];
      Sp = Sp + 4;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(chv, {}), (chx, {}), (chy, {}), (chA, {}), (chC, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.toList_entry() //  []
        { info_tbl: [(chx,
                      label: block_chx_info
                      rep:StackRep []),
                     (chA,
                      label: T2902_Sum.toList_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      chA:
          goto chv;
      chv:
          goto chC;
      chC:
          _sfG::P32 = P32[Sp];
          I32[Sp] = chx;
          R1 = _sfG::P32;
          if (_sfG::P32 & 3 != 0) goto chx; else goto chy;
      chy:
          call (I32[_sfG::P32])(R1) returns to chx, args: 4, res: 4, upd: 4;
      chx:
          R1 = P32[R1 + 23];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.toList_entry() //  []
        { info_tbl: [(chx,
                      label: block_chx_info
                      rep:StackRep []),
                     (chC,
                      label: T2902_Sum.toList_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      chC:
          _sfG::P32 = P32[Sp];
          I32[Sp] = chx;
          R1 = _sfG::P32;
          if (_sfG::P32 & 3 != 0) goto chx; else goto chy;
      chy:
          call (I32[_sfG::P32])(R1) returns to chx, args: 4, res: 4, upd: 4;
      chx:
          R1 = P32[R1 + 23];
          Sp = Sp + 4;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.toList_closure:
         const T2902_Sum.toList_info;
 },
 T2902_Sum.toList_entry() //  []
         { info_tbl: [(chx,
                       label: block_chx_info
                       rep:StackRep []),
                      (chC,
                       label: T2902_Sum.toList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       chC:
           _sfG::P32 = P32[Sp];
           I32[Sp] = chx;
           R1 = _sfG::P32;
           if (_sfG::P32 & 3 != 0) goto chx; else goto chy;
       chy:
           call (I32[_sfG::P32])(R1) returns to chx, args: 4, res: 4, upd: 4;
       chx:
           R1 = P32[R1 + 23];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.toList_closure:
         const T2902_Sum.toList_info;
 },
 T2902_Sum.toList_entry() //  []
         { info_tbl: [(chx,
                       label: block_chx_info
                       rep:StackRep []),
                      (chC,
                       label: T2902_Sum.toList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       chC:
           _sfG::P32 = P32[Sp];
           I32[Sp] = chx;
           R1 = _sfG::P32;
           if (_sfG::P32 & 3 != 0) goto chx; else goto chy;
       chy:
           call (I32[_sfG::P32])(R1) returns to chx, args: 4, res: 4, upd: 4;
       chx:
           R1 = P32[R1 + 23];
           Sp = Sp + 4;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_Sum.D:Sum_closure:
         const T2902_Sum.D:Sum_info;
 },
 T2902_Sum.D:Sum_entry() //  []
         { info_tbl: [(chP,
                       label: T2902_Sum.D:Sum_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 28 updfr_space: Just 4
         }
     {offset
       chP:
           _B6::P32 = P32[(old + 28)];
           _B5::P32 = P32[(old + 24)];
           _B4::P32 = P32[(old + 20)];
           _B3::P32 = P32[(old + 16)];
           _B2::P32 = P32[(old + 12)];
           _B1::P32 = P32[(old + 8)];
           goto chM;
       chM:
           if (Sp - <highSp> < SpLim) goto chQ; else goto chR;
       chR:
           Hp = Hp + 28;
           if (Hp > HpLim) goto chT; else goto chS;
       chT:
           HpAlloc = 28;
           goto chQ;
       chQ:
           R1 = T2902_Sum.D:Sum_closure;
           P32[(old + 28)] = _B6::P32;
           P32[(old + 24)] = _B5::P32;
           P32[(old + 20)] = _B4::P32;
           P32[(old + 16)] = _B3::P32;
           P32[(old + 12)] = _B2::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
       chS:
           I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
           P32[Hp - 20] = _B6::P32;
           P32[Hp - 16] = _B5::P32;
           P32[Hp - 12] = _B4::P32;
           P32[Hp - 8] = _B3::P32;
           P32[Hp - 4] = _B2::P32;
           P32[Hp] = _B1::P32;
           _chO::P32 = Hp - 23;
           R1 = _chO::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  chP:
      _B6::P32 = P32[(old + 28)];
      _B5::P32 = P32[(old + 24)];
      _B4::P32 = P32[(old + 20)];
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto chM;
  chM:
      if (Sp - <highSp> < SpLim) goto chQ; else goto chR;
  chR:
      Hp = Hp + 28;
      if (Hp > HpLim) goto chT; else goto chS;
  chT:
      HpAlloc = 28;
      goto chQ;
  chQ:
      R1 = T2902_Sum.D:Sum_closure;
      P32[(old + 28)] = _B6::P32;
      P32[(old + 24)] = _B5::P32;
      P32[(old + 20)] = _B4::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  chS:
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _B6::P32;
      P32[Hp - 16] = _B5::P32;
      P32[Hp - 12] = _B4::P32;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _chO::P32 = Hp - 23;
      R1 = _chO::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  chP:
      _B6::P32 = P32[(old + 28)];
      _B5::P32 = P32[(old + 24)];
      _B4::P32 = P32[(old + 20)];
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto chM;
  chM:
      if (Sp - <highSp> < SpLim) goto chQ; else goto chR;
  chR:
      Hp = Hp + 28;
      if (Hp > HpLim) goto chT; else goto chS;
  chT:
      HpAlloc = 28;
      goto chQ;
  chQ:
      R1 = T2902_Sum.D:Sum_closure;
      P32[(old + 28)] = _B6::P32;
      P32[(old + 24)] = _B5::P32;
      P32[(old + 20)] = _B4::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  chS:
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _B6::P32;
      P32[Hp - 16] = _B5::P32;
      P32[Hp - 12] = _B4::P32;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _chO::P32 = Hp - 23;
      R1 = _chO::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  chP:
      _B6::P32 = P32[(old + 28)];
      _B5::P32 = P32[(old + 24)];
      _B4::P32 = P32[(old + 20)];
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto chM;
  chM:
      if (Sp - <highSp> < SpLim) goto chQ; else goto chR;
  chR:
      Hp = Hp + 28;
      if (Hp > HpLim) goto chT; else goto chS;
  chT:
      HpAlloc = 28;
      goto chQ;
  chQ:
      R1 = T2902_Sum.D:Sum_closure;
      P32[(old + 28)] = _B6::P32;
      P32[(old + 24)] = _B5::P32;
      P32[(old + 20)] = _B4::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  chS:
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _B6::P32;
      P32[Hp - 16] = _B5::P32;
      P32[Hp - 12] = _B4::P32;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _chO::P32 = Hp - 23;
      R1 = _chO::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  chP:
      _B6::P32 = P32[(old + 28)];
      _B5::P32 = P32[(old + 24)];
      _B4::P32 = P32[(old + 20)];
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto chM;
  chM:
      if (Sp - <highSp> < SpLim) goto chQ; else goto chR;
  chR:
      Hp = Hp + 28;
      if (Hp > HpLim) goto chT; else goto chS;
  chT:
      HpAlloc = 28;
      goto chQ;
  chQ:
      R1 = T2902_Sum.D:Sum_closure;
      P32[(old + 28)] = _B6::P32;
      P32[(old + 24)] = _B5::P32;
      P32[(old + 20)] = _B4::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  chS:
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _B6::P32;
      P32[Hp - 16] = _B5::P32;
      P32[Hp - 12] = _B4::P32;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _chO::P32 = Hp - 23;
      R1 = _chO::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  chP:
      _B6::P32 = P32[Sp];
      _B5::P32 = P32[Sp + 4];
      _B4::P32 = P32[Sp + 8];
      _B3::P32 = P32[Sp + 12];
      _B2::P32 = P32[Sp + 16];
      _B1::P32 = P32[Sp + 20];
      goto chM;
  chM:
      goto chR;
  chR:
      Hp = Hp + 28;
      if (Hp > HpLim) goto chT; else goto chS;
  chT:
      HpAlloc = 28;
      goto chQ;
  chQ:
      R1 = T2902_Sum.D:Sum_closure;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  chS:
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _B6::P32;
      P32[Hp - 16] = _B5::P32;
      P32[Hp - 12] = _B4::P32;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _chO::P32 = Hp - 23;
      R1 = _chO::P32;
      Sp = Sp + 24;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  chP:
      goto chM;
  chM:
      goto chR;
  chR:
      Hp = Hp + 28;
      if (Hp > HpLim) goto chT; else goto chS;
  chT:
      HpAlloc = 28;
      goto chQ;
  chQ:
      R1 = T2902_Sum.D:Sum_closure;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  chS:
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = P32[Sp];
      P32[Hp - 16] = P32[Sp + 4];
      P32[Hp - 12] = P32[Sp + 8];
      P32[Hp - 8] = P32[Sp + 12];
      P32[Hp - 4] = P32[Sp + 16];
      P32[Hp] = P32[Sp + 20];
      R1 = Hp - 23;
      Sp = Sp + 24;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(chM, {}), (chP, {}), (chQ, {}), (chR, {}), (chS, {}), (chT, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.D:Sum_entry() //  []
        { info_tbl: [(chP,
                      label: T2902_Sum.D:Sum_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 28 updfr_space: Just 4
        }
    {offset
      chP:
          goto chM;
      chM:
          goto chR;
      chR:
          Hp = Hp + 28;
          if (Hp > HpLim) goto chT; else goto chS;
      chT:
          HpAlloc = 28;
          goto chQ;
      chQ:
          R1 = T2902_Sum.D:Sum_closure;
          call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
      chS:
          I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
          P32[Hp - 20] = P32[Sp];
          P32[Hp - 16] = P32[Sp + 4];
          P32[Hp - 12] = P32[Sp + 8];
          P32[Hp - 8] = P32[Sp + 12];
          P32[Hp - 4] = P32[Sp + 16];
          P32[Hp] = P32[Sp + 20];
          R1 = Hp - 23;
          Sp = Sp + 24;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.D:Sum_entry() //  []
        { info_tbl: [(chR,
                      label: T2902_Sum.D:Sum_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 28 updfr_space: Just 4
        }
    {offset
      chR:
          Hp = Hp + 28;
          if (Hp > HpLim) goto chT; else goto chS;
      chT:
          HpAlloc = 28;
          goto chQ;
      chQ:
          R1 = T2902_Sum.D:Sum_closure;
          call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
      chS:
          I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
          P32[Hp - 20] = P32[Sp];
          P32[Hp - 16] = P32[Sp + 4];
          P32[Hp - 12] = P32[Sp + 8];
          P32[Hp - 8] = P32[Sp + 12];
          P32[Hp - 4] = P32[Sp + 16];
          P32[Hp] = P32[Sp + 20];
          R1 = Hp - 23;
          Sp = Sp + 24;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_Sum.D:Sum_closure:
         const T2902_Sum.D:Sum_info;
 },
 T2902_Sum.D:Sum_entry() //  []
         { info_tbl: [(chR,
                       label: T2902_Sum.D:Sum_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 28 updfr_space: Just 4
         }
     {offset
       chR:
           Hp = Hp + 28;
           if (Hp > HpLim) goto chT; else goto chS;
       chT:
           HpAlloc = 28;
           goto chQ;
       chQ:
           R1 = T2902_Sum.D:Sum_closure;
           call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
       chS:
           I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
           P32[Hp - 20] = P32[Sp];
           P32[Hp - 16] = P32[Sp + 4];
           P32[Hp - 12] = P32[Sp + 8];
           P32[Hp - 8] = P32[Sp + 12];
           P32[Hp - 4] = P32[Sp + 16];
           P32[Hp] = P32[Sp + 20];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_Sum.D:Sum_closure:
         const T2902_Sum.D:Sum_info;
 },
 T2902_Sum.D:Sum_entry() //  []
         { info_tbl: [(chR,
                       label: T2902_Sum.D:Sum_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 28 updfr_space: Just 4
         }
     {offset
       chR:
           Hp = Hp + 28;
           if (Hp > HpLim) goto chT; else goto chS;
       chT:
           HpAlloc = 28;
           goto chQ;
       chQ:
           R1 = T2902_Sum.D:Sum_closure;
           call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
       chS:
           I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
           P32[Hp - 20] = P32[Sp];
           P32[Hp - 16] = P32[Sp + 4];
           P32[Hp - 12] = P32[Sp + 8];
           P32[Hp - 8] = P32[Sp + 12];
           P32[Hp - 4] = P32[Sp + 16];
           P32[Hp] = P32[Sp + 20];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[T2902_Sum.D:Sum_con_entry() //  []
         { info_tbl: [(ci4,
                       label: T2902_Sum.D:Sum_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       ci4:
           R1 = R1 + 1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 },
 T2902_Sum.D:Sum_static_entry() //  []
         { info_tbl: [(ci5,
                       label: T2902_Sum.D:Sum_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       ci5:
           R1 = R1 + 1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  ci4:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  ci4:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  ci4:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  ci4:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  ci4:
      R1 = R1 + 1;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  ci4:
      R1 = R1 + 1;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(ci4, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.D:Sum_con_entry() //  []
        { info_tbl: [(ci4,
                      label: T2902_Sum.D:Sum_con_info
                      rep:HeapRep 6 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      ci4:
          R1 = R1 + 1;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.D:Sum_con_entry() //  []
        { info_tbl: [(ci4,
                      label: T2902_Sum.D:Sum_con_info
                      rep:HeapRep 6 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      ci4:
          R1 = R1 + 1;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  ci5:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  ci5:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  ci5:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  ci5:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  ci5:
      R1 = R1 + 1;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  ci5:
      R1 = R1 + 1;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(ci5, {})]



==================== after setInfoTableStackMap ====================
T2902_Sum.D:Sum_static_entry() //  []
        { info_tbl: [(ci5,
                      label: T2902_Sum.D:Sum_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      ci5:
          R1 = R1 + 1;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_Sum.D:Sum_static_entry() //  []
        { info_tbl: [(ci5,
                      label: T2902_Sum.D:Sum_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      ci5:
          R1 = R1 + 1;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[T2902_Sum.D:Sum_con_entry() //  []
         { info_tbl: [(ci4,
                       label: T2902_Sum.D:Sum_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       ci4:
           R1 = R1 + 1;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 },
 T2902_Sum.D:Sum_static_entry() //  []
         { info_tbl: [(ci5,
                       label: T2902_Sum.D:Sum_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       ci5:
           R1 = R1 + 1;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[T2902_Sum.D:Sum_con_entry() //  []
         { info_tbl: [(ci4,
                       label: T2902_Sum.D:Sum_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       ci4:
           R1 = R1 + 1;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 },
 T2902_Sum.D:Sum_static_entry() //  []
         { info_tbl: [(ci5,
                       label: T2902_Sum.D:Sum_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,83,117,109,46,68,58,83,117,109]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       ci5:
           R1 = R1 + 1;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "relreadonly" { Sie_srt:
 }]


[2 of 3] Compiling T2902_B_PairingSum ( T2902_B_PairingSum.hs, T2902_B_PairingSum.o )

==================== Cmm produced by new codegen ====================
[section "data" { __stginit_main:T2902_B_PairingSum:
 }]



==================== Post CPS Cmm ====================
[section "data" { __stginit_main:T2902_B_PairingSum:
 }]



==================== Output Cmm ====================
[section "data" { __stginit_main:T2902_B_PairingSum:
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     lvl_rHo_closure:
         const GHC.Integer.Type.S#_static_info;
         const 0;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     lvl_rHo_closure:
         const GHC.Integer.Type.S#_static_info;
         const 0;
 }]



==================== Output Cmm ====================
[section "data" {
     lvl_rHo_closure:
         const GHC.Integer.Type.S#_static_info;
         const 0;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cunions_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cunions_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cunions_entry() //  []
         { info_tbl: [(cJP,
                       label: T2902_B_PairingSum.$fSumPSumab_$cunions_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cJP:
           _sHs::P32 = P32[(old + 20)];
           _sHt::P32 = P32[(old + 16)];
           _sHu::P32 = P32[(old + 12)];
           _sHv::P32 = P32[(old + 8)];
           goto cJD;
       cJD:
           if (Sp - <highSp> < SpLim) goto cJQ; else goto cJR;
       cJQ:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
           P32[(old + 20)] = _sHs::P32;
           P32[(old + 16)] = _sHt::P32;
           P32[(old + 12)] = _sHu::P32;
           P32[(old + 8)] = _sHv::P32;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cJR:
           I32[(young<cJF> + 4)] = cJF;
           R1 = _sHv::P32;
           if (R1 & 3 != 0) goto cJF; else goto cJG;
       cJG:
           call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
       cJF:
           _sHw::P32 = R1;
           _cJL::P32 = _sHw::P32 & 3;
           if (_cJL::P32 >= 2) goto cJN; else goto cJO;
       cJN:
           goto cJK;
       cJK:
           _sHx::P32 = P32[_sHw::P32 + 2];
           _sHy::P32 = P32[_sHw::P32 + 6];
           I32[(young<cJX> + 4)] = cJX;
           R1 = _sHy::P32;
           if (R1 & 3 != 0) goto cJX; else goto cJZ;
       cJZ:
           call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
       cJX:
           _sHz::P32 = R1;
           _cKk::P32 = _sHz::P32 & 3;
           if (_cKk::P32 >= 2) goto cKm; else goto cKn;
       cKm:
           goto cKe;
       cKe:
           _sHA::P32 = P32[_sHz::P32 + 2];
           _sHB::P32 = P32[_sHz::P32 + 6];
           I32[(young<cK8> + 4)] = cK8;
           P32[(young<cK8> + 20)] = _sHs::P32;
           P32[(young<cK8> + 16)] = _sHt::P32;
           P32[(young<cK8> + 12)] = _sHu::P32;
           P32[(young<cK8> + 8)] = _sHB::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
       cK8:
           _sHD::P32 = R1;
           I32[(young<cKc> + 4)] = cKc;
           P32[(young<cKc> + 24)] = _sHs::P32;
           P32[(young<cKc> + 20)] = _sHt::P32;
           P32[(young<cKc> + 16)] = _sHu::P32;
           P32[(young<cKc> + 12)] = _sHx::P32;
           P32[(young<cKc> + 8)] = _sHA::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
       cKc:
           _sHC::P32 = R1;
           P32[(old + 24)] = _sHs::P32;
           P32[(old + 20)] = _sHt::P32;
           P32[(old + 16)] = _sHu::P32;
           P32[(old + 12)] = _sHC::P32;
           P32[(old + 8)] = _sHD::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
       cKn:
           goto cK5;
       cK5:
           R1 = _sHx::P32 & (-4);
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cJO:
           goto cJJ;
       cJJ:
           R1 = T2902_B_PairingSum.Empty_closure+1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 },
 section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cunion_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cunion_info;
         const 0;
 },
 ds1_sHT_entry() //  [R1]
         { info_tbl: [(cKM,
                       label: ds1_sHT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cKM:
           _sHT::P32 = R1;
           goto cKK;
       cKK:
           if (Sp - <highSp> < SpLim) goto cKN; else goto cKO;
       cKN:
           R1 = _sHT::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cKO:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _sHT::P32;
           _sHG::P32 = P32[_sHT::P32 + 8];
           _sHL::P32 = P32[_sHT::P32 + 12];
           _sHP::P32 = P32[_sHT::P32 + 16];
           P32[(old + 28)] = _sHG::P32;
           I32[(old + 24)] = stg_ap_pp_info;
           P32[(old + 20)] = _sHP::P32;
           P32[(old + 16)] = _sHL::P32;
           call GHC.Num.+_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_sHX_entry() //  [R1]
         { info_tbl: [(cL5,
                       label: sat_sHX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cL5:
           _sHX::P32 = R1;
           goto cL3;
       cL3:
           if (Sp - <highSp> < SpLim) goto cL6; else goto cL7;
       cL6:
           R1 = _sHX::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cL7:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _sHX::P32;
           _sHG::P32 = P32[_sHX::P32 + 8];
           P32[(old + 24)] = _sHG::P32;
           I32[(old + 20)] = stg_ap_p_info;
           P32[(old + 16)] = lvl_rHo_closure+1;
           call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$cunion_entry() //  []
         { info_tbl: [(cLf,
                       label: T2902_B_PairingSum.$fSumPSumab_$cunion_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 24 updfr_space: Just 4
         }
     {offset
       cLf:
           _sHE::P32 = P32[(old + 24)];
           _sHF::P32 = P32[(old + 20)];
           _sHG::P32 = P32[(old + 16)];
           _sHH::P32 = P32[(old + 12)];
           _sHI::P32 = P32[(old + 8)];
           goto cKp;
       cKp:
           if (Sp - <highSp> < SpLim) goto cLg; else goto cLh;
       cLg:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
           P32[(old + 24)] = _sHE::P32;
           P32[(old + 20)] = _sHF::P32;
           P32[(old + 16)] = _sHG::P32;
           P32[(old + 12)] = _sHH::P32;
           P32[(old + 8)] = _sHI::P32;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
       cLh:
           I32[(young<cKr> + 4)] = cKr;
           R1 = _sHI::P32;
           if (R1 & 3 != 0) goto cKr; else goto cKs;
       cKs:
           call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
       cKr:
           _sHJ::P32 = R1;
           _cLb::P32 = _sHJ::P32 & 3;
           if (_cLb::P32 >= 2) goto cLd; else goto cLe;
       cLd:
           goto cLa;
       cLa:
           _sHK::P32 = P32[_sHJ::P32 + 2];
           _sHL::P32 = P32[_sHJ::P32 + 6];
           _sHM::P32 = P32[_sHJ::P32 + 10];
           I32[(young<cKx> + 4)] = cKx;
           R1 = _sHH::P32;
           if (R1 & 3 != 0) goto cKx; else goto cKy;
       cKy:
           call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
       cKx:
           _sHN::P32 = R1;
           _cMc::P32 = _sHN::P32 & 3;
           if (_cMc::P32 >= 2) goto cMe; else goto cMf;
       cMe:
           goto cLq;
       cLq:
           _sHO::P32 = P32[_sHN::P32 + 2];
           _sHP::P32 = P32[_sHN::P32 + 6];
           _sHQ::P32 = P32[_sHN::P32 + 10];
           I32[(young<cKD> + 4)] = cKD;
           P32[(young<cKD> + 20)] = _sHE::P32;
           I32[(young<cKD> + 16)] = stg_ap_pp_info;
           P32[(young<cKD> + 12)] = _sHO::P32;
           P32[(young<cKD> + 8)] = _sHK::P32;
           call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
       cKD:
           _sHR::P32 = R1;
           _cM5::P32 = _sHR::P32 & 3;
           if (_cM5::P32 >= 2) goto cMa; else goto cMb;
       cMa:
           if (_cM5::P32 >= 3) goto cM7; else goto cM8;
       cM7:
           goto cM1;
       cM1:
           Hp = Hp + 28;
           if (Hp > HpLim) goto cM4; else goto cM3;
       cM4:
           HpAlloc = 28;
           goto cM2;
       cM2:
           R1 = _sHR::P32;
           call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
       cM3:
           I32[Hp - 24] = :_con_info;
           P32[Hp - 20] = _sHN::P32;
           P32[Hp - 16] = _sHM::P32;
           _cLZ::P32 = Hp - 22;
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = _sHK::P32;
           P32[Hp - 4] = _sHL::P32;
           P32[Hp] = _cLZ::P32;
           _cM0::P32 = Hp - 10;
           R1 = _cM0::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
       cM8:
           goto cLz;
       cLz:
           Hp = Hp + 20;
           if (Hp > HpLim) goto cLC; else goto cLB;
       cLC:
           HpAlloc = 20;
           goto cLA;
       cLA:
           R1 = _sHR::P32;
           call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
       cLB:
           I32[Hp - 16] = ds1_sHT_info;
           P32[Hp - 8] = _sHG::P32;
           P32[Hp - 4] = _sHL::P32;
           P32[Hp] = _sHP::P32;
           _cKI::P32 = Hp - 16;
           I32[(young<cKP> + 4)] = cKP;
           P32[(young<cKP> + 20)] = _sHE::P32;
           P32[(young<cKP> + 16)] = _sHF::P32;
           P32[(young<cKP> + 12)] = _sHG::P32;
           P32[(young<cKP> + 8)] = _sHM::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
       cKP:
           _sHW::P32 = R1;
           I32[(young<cKT> + 4)] = cKT;
           P32[(young<cKT> + 20)] = _sHE::P32;
           P32[(young<cKT> + 16)] = _sHF::P32;
           P32[(young<cKT> + 12)] = _sHG::P32;
           P32[(young<cKT> + 8)] = _sHQ::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
       cKT:
           _sHV::P32 = R1;
           I32[(young<cKX> + 4)] = cKX;
           P32[(young<cKX> + 24)] = _sHE::P32;
           P32[(young<cKX> + 20)] = _sHF::P32;
           P32[(young<cKX> + 16)] = _sHG::P32;
           P32[(young<cKX> + 12)] = _sHV::P32;
           P32[(young<cKX> + 8)] = _sHW::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
       cKX:
           _sHU::P32 = R1;
           Hp = Hp + 12;
           if (Hp > HpLim) goto cLI; else goto cLH;
       cLI:
           HpAlloc = 12;
           goto cLG;
       cLG:
           R1 = _sHU::P32;
           call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
       cLH:
           I32[Hp - 8] = sat_sHX_info;
           P32[Hp] = _sHG::P32;
           _cL1::P32 = Hp - 8;
           I32[(young<cLF> + 4)] = cLF;
           P32[(young<cLF> + 20)] = _sHF::P32;
           I32[(young<cLF> + 16)] = stg_ap_pp_info;
           P32[(young<cLF> + 12)] = _cKI::P32;
           P32[(young<cLF> + 8)] = _cL1::P32;
           call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
       cLF:
           _sHY::P32 = R1;
           _cLT::P32 = _sHY::P32 & 3;
           if (_cLT::P32 >= 2) goto cLV; else goto cLW;
       cLV:
           goto cLS;
       cLS:
           R1 = _sHU::P32 & (-4);
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cLW:
           goto cLO;
       cLO:
           P32[(old + 28)] = _sHE::P32;
           P32[(old + 24)] = _sHF::P32;
           P32[(old + 20)] = _sHG::P32;
           P32[(old + 16)] = _sHO::P32;
           P32[(old + 12)] = _cKI::P32;
           P32[(old + 8)] = _sHU::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
       cMb:
           goto cLv;
       cLv:
           Hp = Hp + 28;
           if (Hp > HpLim) goto cLy; else goto cLx;
       cLy:
           HpAlloc = 28;
           goto cLw;
       cLw:
           R1 = _sHR::P32;
           call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
       cLx:
           I32[Hp - 24] = :_con_info;
           P32[Hp - 20] = _sHJ::P32;
           P32[Hp - 16] = _sHQ::P32;
           _cLs::P32 = Hp - 22;
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = _sHO::P32;
           P32[Hp - 4] = _sHP::P32;
           P32[Hp] = _cLs::P32;
           _cLt::P32 = Hp - 10;
           R1 = _cLt::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
       cMf:
           goto cLo;
       cLo:
           R1 = _sHJ::P32 & (-4);
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cLe:
           goto cL9;
       cL9:
           R1 = _sHH::P32 & (-4);
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
     }
 },
 section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cinsert_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cinsert_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cinsert_entry() //  []
         { info_tbl: [(cMk,
                       label: T2902_B_PairingSum.$fSumPSumab_$cinsert_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 28 updfr_space: Just 4
         }
     {offset
       cMk:
           _sI0::P32 = P32[(old + 28)];
           _sI1::P32 = P32[(old + 24)];
           _sI2::P32 = P32[(old + 20)];
           _sI3::P32 = P32[(old + 16)];
           _sI4::P32 = P32[(old + 12)];
           _sI5::P32 = P32[(old + 8)];
           goto cMh;
       cMh:
           if (Sp - <highSp> < SpLim) goto cMl; else goto cMm;
       cMm:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cMo; else goto cMn;
       cMo:
           HpAlloc = 16;
           goto cMl;
       cMl:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
           P32[(old + 28)] = _sI0::P32;
           P32[(old + 24)] = _sI1::P32;
           P32[(old + 20)] = _sI2::P32;
           P32[(old + 16)] = _sI3::P32;
           P32[(old + 12)] = _sI4::P32;
           P32[(old + 8)] = _sI5::P32;
           call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
       cMn:
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = _sI3::P32;
           P32[Hp - 4] = _sI4::P32;
           P32[Hp] = GHC.Types.[]_closure+1;
           _cMj::P32 = Hp - 10;
           P32[(old + 24)] = _sI0::P32;
           P32[(old + 20)] = _sI1::P32;
           P32[(old + 16)] = _sI2::P32;
           P32[(old + 12)] = _cMj::P32;
           P32[(old + 8)] = _sI5::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cJP:
      _sHs::P32 = P32[(old + 20)];
      _sHt::P32 = P32[(old + 16)];
      _sHu::P32 = P32[(old + 12)];
      _sHv::P32 = P32[(old + 8)];
      goto cJD;
  cJD:
      if (Sp - <highSp> < SpLim) goto cJQ; else goto cJR;
  cJQ:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
      P32[(old + 20)] = _sHs::P32;
      P32[(old + 16)] = _sHt::P32;
      P32[(old + 12)] = _sHu::P32;
      P32[(old + 8)] = _sHv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cJR:
      I32[(young<cJF> + 4)] = cJF;
      R1 = _sHv::P32;
      if (R1 & 3 != 0) goto cJF; else goto cJG;
  cJG:
      call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
  cJF:
      _sHw::P32 = R1;
      _cJL::P32 = _sHw::P32 & 3;
      if (_cJL::P32 >= 2) goto cJK; else goto cJJ;
  cJK:
      _sHx::P32 = P32[_sHw::P32 + 2];
      _sHy::P32 = P32[_sHw::P32 + 6];
      I32[(young<cJX> + 4)] = cJX;
      R1 = _sHy::P32;
      if (R1 & 3 != 0) goto cJX; else goto cJZ;
  cJZ:
      call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
  cJX:
      _sHz::P32 = R1;
      _cKk::P32 = _sHz::P32 & 3;
      if (_cKk::P32 >= 2) goto cKe; else goto cK5;
  cKe:
      _sHA::P32 = P32[_sHz::P32 + 2];
      _sHB::P32 = P32[_sHz::P32 + 6];
      I32[(young<cK8> + 4)] = cK8;
      P32[(young<cK8> + 20)] = _sHs::P32;
      P32[(young<cK8> + 16)] = _sHt::P32;
      P32[(young<cK8> + 12)] = _sHu::P32;
      P32[(young<cK8> + 8)] = _sHB::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
  cK8:
      _sHD::P32 = R1;
      I32[(young<cKc> + 4)] = cKc;
      P32[(young<cKc> + 24)] = _sHs::P32;
      P32[(young<cKc> + 20)] = _sHt::P32;
      P32[(young<cKc> + 16)] = _sHu::P32;
      P32[(young<cKc> + 12)] = _sHx::P32;
      P32[(young<cKc> + 8)] = _sHA::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
  cKc:
      _sHC::P32 = R1;
      P32[(old + 24)] = _sHs::P32;
      P32[(old + 20)] = _sHt::P32;
      P32[(old + 16)] = _sHu::P32;
      P32[(old + 12)] = _sHC::P32;
      P32[(old + 8)] = _sHD::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
  cK5:
      R1 = _sHx::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cJJ:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cJP:
      _sHs::P32 = P32[(old + 20)];
      _sHt::P32 = P32[(old + 16)];
      _sHu::P32 = P32[(old + 12)];
      _sHv::P32 = P32[(old + 8)];
      goto cJD;
  cJD:
      if (Sp - <highSp> < SpLim) goto cJQ; else goto cJR;
  cJQ:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
      P32[(old + 20)] = _sHs::P32;
      P32[(old + 16)] = _sHt::P32;
      P32[(old + 12)] = _sHu::P32;
      P32[(old + 8)] = _sHv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cJR:
      I32[(young<cJF> + 4)] = cJF;
      R1 = _sHv::P32;
      if (R1 & 3 != 0) goto cJF; else goto cJG;
  cJG:
      call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
  cJF:
      _sHw::P32 = R1;
      _cJL::P32 = _sHw::P32 & 3;
      if (_cJL::P32 >= 2) goto cJK; else goto cJJ;
  cJK:
      _sHx::P32 = P32[_sHw::P32 + 2];
      _sHy::P32 = P32[_sHw::P32 + 6];
      I32[(young<cJX> + 4)] = cJX;
      R1 = _sHy::P32;
      if (R1 & 3 != 0) goto cJX; else goto cJZ;
  cJZ:
      call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
  cJX:
      _sHz::P32 = R1;
      _cKk::P32 = _sHz::P32 & 3;
      if (_cKk::P32 >= 2) goto cKe; else goto cK5;
  cKe:
      _sHA::P32 = P32[_sHz::P32 + 2];
      _sHB::P32 = P32[_sHz::P32 + 6];
      I32[(young<cK8> + 4)] = cK8;
      P32[(young<cK8> + 20)] = _sHs::P32;
      P32[(young<cK8> + 16)] = _sHt::P32;
      P32[(young<cK8> + 12)] = _sHu::P32;
      P32[(young<cK8> + 8)] = _sHB::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
  cK8:
      _sHD::P32 = R1;
      I32[(young<cKc> + 4)] = cKc;
      P32[(young<cKc> + 24)] = _sHs::P32;
      P32[(young<cKc> + 20)] = _sHt::P32;
      P32[(young<cKc> + 16)] = _sHu::P32;
      P32[(young<cKc> + 12)] = _sHx::P32;
      P32[(young<cKc> + 8)] = _sHA::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
  cKc:
      _sHC::P32 = R1;
      P32[(old + 24)] = _sHs::P32;
      P32[(old + 20)] = _sHt::P32;
      P32[(old + 16)] = _sHu::P32;
      P32[(old + 12)] = _sHC::P32;
      P32[(old + 8)] = _sHD::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
  cK5:
      R1 = _sHx::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cJJ:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cJP:
      _sHs::P32 = P32[(old + 20)];
      _sHt::P32 = P32[(old + 16)];
      _sHu::P32 = P32[(old + 12)];
      _sHv::P32 = P32[(old + 8)];
      goto cJD;
  cJD:
      if (Sp - <highSp> < SpLim) goto cJQ; else goto cJR;
  cJQ:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
      P32[(old + 20)] = _sHs::P32;
      P32[(old + 16)] = _sHt::P32;
      P32[(old + 12)] = _sHu::P32;
      P32[(old + 8)] = _sHv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cJR:
      I32[(young<cJF> + 4)] = cJF;
      R1 = _sHv::P32;
      if (R1 & 3 != 0) goto cJF; else goto cJG;
  cJG:
      call (I32[R1])(R1) returns to cJF, args: 4, res: 4, upd: 4;
  cJF:
      _sHw::P32 = R1;
      _cJL::P32 = _sHw::P32 & 3;
      if (_cJL::P32 >= 2) goto cJK; else goto cJJ;
  cJK:
      _sHx::P32 = P32[_sHw::P32 + 2];
      _sHy::P32 = P32[_sHw::P32 + 6];
      I32[(young<cJX> + 4)] = cJX;
      R1 = _sHy::P32;
      if (R1 & 3 != 0) goto cJX; else goto cJZ;
  cJZ:
      call (I32[R1])(R1) returns to cJX, args: 4, res: 4, upd: 4;
  cJX:
      _sHz::P32 = R1;
      _cKk::P32 = _sHz::P32 & 3;
      if (_cKk::P32 >= 2) goto cKe; else goto cK5;
  cKe:
      _sHA::P32 = P32[_sHz::P32 + 2];
      _sHB::P32 = P32[_sHz::P32 + 6];
      I32[(young<cK8> + 4)] = cK8;
      P32[(young<cK8> + 20)] = _sHs::P32;
      P32[(young<cK8> + 16)] = _sHt::P32;
      P32[(young<cK8> + 12)] = _sHu::P32;
      P32[(young<cK8> + 8)] = _sHB::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
  cK8:
      _sHD::P32 = R1;
      I32[(young<cKc> + 4)] = cKc;
      P32[(young<cKc> + 24)] = _sHs::P32;
      P32[(young<cKc> + 20)] = _sHt::P32;
      P32[(young<cKc> + 16)] = _sHu::P32;
      P32[(young<cKc> + 12)] = _sHx::P32;
      P32[(young<cKc> + 8)] = _sHA::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
  cKc:
      _sHC::P32 = R1;
      P32[(old + 24)] = _sHs::P32;
      P32[(old + 20)] = _sHt::P32;
      P32[(old + 16)] = _sHu::P32;
      P32[(old + 12)] = _sHC::P32;
      P32[(old + 8)] = _sHD::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
  cK5:
      R1 = _sHx::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cJJ:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cJP:
      _sHs::P32 = P32[(old + 20)];
      _sHt::P32 = P32[(old + 16)];
      _sHu::P32 = P32[(old + 12)];
      _sHv::P32 = P32[(old + 8)];
      goto cJD;
  cJD:
      if (Sp - <highSp> < SpLim) goto cJQ; else goto cJR;
  cJQ:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
      P32[(old + 20)] = _sHs::P32;
      P32[(old + 16)] = _sHt::P32;
      P32[(old + 12)] = _sHu::P32;
      P32[(old + 8)] = _sHv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cJR:
      I32[(young<cJF> + 4)] = cJF;
      R1 = _sHv::P32;
      if (_sHv::P32 & 3 != 0) goto cJF; else goto cJG;
  cJG:
      call (I32[_sHv::P32])(R1) returns to cJF, args: 4, res: 4, upd: 4;
  cJF:
      _sHw::P32 = R1;
      _cJL::P32 = R1 & 3;
      if (_cJL::P32 >= 2) goto cJK; else goto cJJ;
  cJK:
      _sHx::P32 = P32[R1 + 2];
      _sHy::P32 = P32[R1 + 6];
      I32[(young<cJX> + 4)] = cJX;
      R1 = _sHy::P32;
      if (_sHy::P32 & 3 != 0) goto cJX; else goto cJZ;
  cJZ:
      call (I32[_sHy::P32])(R1) returns to cJX, args: 4, res: 4, upd: 4;
  cJX:
      _sHz::P32 = R1;
      _cKk::P32 = R1 & 3;
      if (_cKk::P32 >= 2) goto cKe; else goto cK5;
  cKe:
      _sHA::P32 = P32[R1 + 2];
      _sHB::P32 = P32[R1 + 6];
      I32[(young<cK8> + 4)] = cK8;
      P32[(young<cK8> + 20)] = _sHs::P32;
      P32[(young<cK8> + 16)] = _sHt::P32;
      P32[(young<cK8> + 12)] = _sHu::P32;
      P32[(young<cK8> + 8)] = _sHB::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
  cK8:
      _sHD::P32 = R1;
      I32[(young<cKc> + 4)] = cKc;
      P32[(young<cKc> + 24)] = _sHs::P32;
      P32[(young<cKc> + 20)] = _sHt::P32;
      P32[(young<cKc> + 16)] = _sHu::P32;
      P32[(young<cKc> + 12)] = _sHx::P32;
      P32[(young<cKc> + 8)] = _sHA::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
  cKc:
      _sHC::P32 = R1;
      P32[(old + 24)] = _sHs::P32;
      P32[(old + 20)] = _sHt::P32;
      P32[(old + 16)] = _sHu::P32;
      P32[(old + 12)] = R1;
      P32[(old + 8)] = _sHD::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
  cK5:
      R1 = _sHx::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cJJ:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cJP:
      _sHs::P32 = P32[Sp];
      _sHt::P32 = P32[Sp + 4];
      _sHu::P32 = P32[Sp + 8];
      _sHv::P32 = P32[Sp + 12];
      goto cJD;
  cJD:
      if (Sp - 24 < SpLim) goto cJQ; else goto cJR;
  cJQ:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cJR:
      I32[Sp - 4] = cJF;
      R1 = _sHv::P32;
      Sp = Sp - 4;
      if (_sHv::P32 & 3 != 0) goto cJF; else goto cJG;
  cJG:
      call (I32[_sHv::P32])(R1) returns to cJF, args: 4, res: 4, upd: 4;
  cJF:
      _sHs::P32 = P32[Sp + 4];
      _sHt::P32 = P32[Sp + 8];
      _sHu::P32 = P32[Sp + 12];
      _sHw::P32 = R1;
      _cJL::P32 = R1 & 3;
      if (_cJL::P32 >= 2) goto cJK; else goto cJJ;
  cJK:
      _sHx::P32 = P32[R1 + 2];
      _sHy::P32 = P32[R1 + 6];
      I32[Sp] = cJX;
      R1 = _sHy::P32;
      P32[Sp + 16] = _sHx::P32;
      if (_sHy::P32 & 3 != 0) goto cJX; else goto cJZ;
  cJZ:
      call (I32[_sHy::P32])(R1) returns to cJX, args: 4, res: 4, upd: 4;
  cJX:
      _sHs::P32 = P32[Sp + 4];
      _sHt::P32 = P32[Sp + 8];
      _sHu::P32 = P32[Sp + 12];
      _sHx::P32 = P32[Sp + 16];
      _sHz::P32 = R1;
      _cKk::P32 = R1 & 3;
      if (_cKk::P32 >= 2) goto cKe; else goto cK5;
  cKe:
      _sHA::P32 = P32[R1 + 2];
      _sHB::P32 = P32[R1 + 6];
      I32[Sp - 4] = cK8;
      P32[Sp - 20] = _sHs::P32;
      P32[Sp - 16] = _sHt::P32;
      P32[Sp - 12] = _sHu::P32;
      P32[Sp - 8] = _sHB::P32;
      P32[Sp] = _sHA::P32;
      Sp = Sp - 20;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
  cK8:
      _sHs::P32 = P32[Sp + 8];
      _sHt::P32 = P32[Sp + 12];
      _sHu::P32 = P32[Sp + 16];
      _sHx::P32 = P32[Sp + 20];
      _sHA::P32 = P32[Sp + 4];
      _sHD::P32 = R1;
      I32[Sp + 4] = cKc;
      P32[Sp - 16] = _sHs::P32;
      P32[Sp - 12] = _sHt::P32;
      P32[Sp - 8] = _sHu::P32;
      P32[Sp - 4] = _sHx::P32;
      P32[Sp] = _sHA::P32;
      P32[Sp + 20] = _sHD::P32;
      Sp = Sp - 16;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
  cKc:
      _sHs::P32 = P32[Sp + 4];
      _sHt::P32 = P32[Sp + 8];
      _sHu::P32 = P32[Sp + 12];
      _sHD::P32 = P32[Sp + 16];
      _sHC::P32 = R1;
      P32[Sp] = _sHs::P32;
      P32[Sp + 4] = _sHt::P32;
      P32[Sp + 8] = _sHu::P32;
      P32[Sp + 12] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
  cK5:
      R1 = _sHx::P32 & (-4);
      Sp = Sp + 20;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cJJ:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cJP:
      goto cJD;
  cJD:
      if ((Sp + -24) < SpLim) goto cJQ; else goto cJR;
  cJQ:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cJR:
      I32[Sp - 4] = cJF;
      _sHv::P32 = P32[Sp + 12];
      R1 = _sHv::P32;
      Sp = Sp - 4;
      if (_sHv::P32 & 3 != 0) goto cJF; else goto cJG;
  cJG:
      call (I32[_sHv::P32])(R1) returns to cJF, args: 4, res: 4, upd: 4;
  cJF:
      if (R1 & 3 >= 2) goto cJK; else goto cJJ;
  cJK:
      I32[Sp] = cJX;
      _sHx::P32 = P32[R1 + 2];
      _sHy::P32 = P32[R1 + 6];
      R1 = _sHy::P32;
      P32[Sp + 16] = _sHx::P32;
      if (_sHy::P32 & 3 != 0) goto cJX; else goto cJZ;
  cJZ:
      call (I32[_sHy::P32])(R1) returns to cJX, args: 4, res: 4, upd: 4;
  cJX:
      if (R1 & 3 >= 2) goto cKe; else goto cK5;
  cKe:
      I32[Sp - 4] = cK8;
      P32[Sp - 20] = P32[Sp + 4];
      P32[Sp - 16] = P32[Sp + 8];
      P32[Sp - 12] = P32[Sp + 12];
      P32[Sp - 8] = P32[R1 + 6];
      P32[Sp] = P32[R1 + 2];
      Sp = Sp - 20;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
  cK8:
      _sHA::P32 = P32[Sp + 4];
      I32[Sp + 4] = cKc;
      P32[Sp - 16] = P32[Sp + 8];
      P32[Sp - 12] = P32[Sp + 12];
      P32[Sp - 8] = P32[Sp + 16];
      P32[Sp - 4] = P32[Sp + 20];
      P32[Sp] = _sHA::P32;
      P32[Sp + 20] = R1;
      Sp = Sp - 16;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
  cKc:
      P32[Sp] = P32[Sp + 4];
      P32[Sp + 4] = P32[Sp + 8];
      P32[Sp + 8] = P32[Sp + 12];
      P32[Sp + 12] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
  cK5:
      R1 = P32[Sp + 16] & (-4);
      Sp = Sp + 20;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cJJ:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cJD,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJF,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJG,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJJ, {}),
 (cJK,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJP,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJQ, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cJR,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJX,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cJZ,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cK5, {}), (cK8, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cKc, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cKe,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_$cunions_entry() //  []
        { info_tbl: [(cJF,
                      label: block_cJF_info
                      rep:StackRep [False, False, False, True]),
                     (cJP,
                      label: T2902_B_PairingSum.$fSumPSumab_$cunions_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                     (cJX,
                      label: block_cJX_info
                      rep:StackRep [False, False, False, False]),
                     (cK8,
                      label: block_cK8_info
                      rep:StackRep [False, False, False, False, False]),
                     (cKc,
                      label: block_cKc_info
                      rep:StackRep [False, False, False, False])]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cJP:
          goto cJD;
      cJD:
          if ((Sp + -24) < SpLim) goto cJQ; else goto cJR;
      cJQ:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cJR:
          I32[Sp - 4] = cJF;
          _sHv::P32 = P32[Sp + 12];
          R1 = _sHv::P32;
          Sp = Sp - 4;
          if (_sHv::P32 & 3 != 0) goto cJF; else goto cJG;
      cJG:
          call (I32[_sHv::P32])(R1) returns to cJF, args: 4, res: 4, upd: 4;
      cJF:
          if (R1 & 3 >= 2) goto cJK; else goto cJJ;
      cJK:
          I32[Sp] = cJX;
          _sHx::P32 = P32[R1 + 2];
          _sHy::P32 = P32[R1 + 6];
          R1 = _sHy::P32;
          P32[Sp + 16] = _sHx::P32;
          if (_sHy::P32 & 3 != 0) goto cJX; else goto cJZ;
      cJZ:
          call (I32[_sHy::P32])(R1) returns to cJX, args: 4, res: 4, upd: 4;
      cJX:
          if (R1 & 3 >= 2) goto cKe; else goto cK5;
      cKe:
          I32[Sp - 4] = cK8;
          P32[Sp - 20] = P32[Sp + 4];
          P32[Sp - 16] = P32[Sp + 8];
          P32[Sp - 12] = P32[Sp + 12];
          P32[Sp - 8] = P32[R1 + 6];
          P32[Sp] = P32[R1 + 2];
          Sp = Sp - 20;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
      cK8:
          _sHA::P32 = P32[Sp + 4];
          I32[Sp + 4] = cKc;
          P32[Sp - 16] = P32[Sp + 8];
          P32[Sp - 12] = P32[Sp + 12];
          P32[Sp - 8] = P32[Sp + 16];
          P32[Sp - 4] = P32[Sp + 20];
          P32[Sp] = _sHA::P32;
          P32[Sp + 20] = R1;
          Sp = Sp - 16;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
      cKc:
          P32[Sp] = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp + 8];
          P32[Sp + 8] = P32[Sp + 12];
          P32[Sp + 12] = R1;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
      cK5:
          R1 = P32[Sp + 16] & (-4);
          Sp = Sp + 20;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
      cJJ:
          R1 = T2902_B_PairingSum.Empty_closure+1;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_$cunions_entry() //  []
        { info_tbl: [(cJD,
                      label: T2902_B_PairingSum.$fSumPSumab_$cunions_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                     (cJF,
                      label: block_cJF_info
                      rep:StackRep [False, False, False, True]),
                     (cJX,
                      label: block_cJX_info
                      rep:StackRep [False, False, False, False]),
                     (cK8,
                      label: block_cK8_info
                      rep:StackRep [False, False, False, False, False]),
                     (cKc,
                      label: block_cKc_info
                      rep:StackRep [False, False, False, False])]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cJD:
          if ((Sp + -24) < SpLim) goto cJQ; else goto cJR;
      cJQ:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cJR:
          I32[Sp - 4] = cJF;
          _sHv::P32 = P32[Sp + 12];
          R1 = _sHv::P32;
          Sp = Sp - 4;
          if (_sHv::P32 & 3 != 0) goto cJF; else goto cJG;
      cJG:
          call (I32[_sHv::P32])(R1) returns to cJF, args: 4, res: 4, upd: 4;
      cJF:
          if (R1 & 3 >= 2) goto cJK; else goto cJJ;
      cJK:
          I32[Sp] = cJX;
          _sHx::P32 = P32[R1 + 2];
          _sHy::P32 = P32[R1 + 6];
          R1 = _sHy::P32;
          P32[Sp + 16] = _sHx::P32;
          if (_sHy::P32 & 3 != 0) goto cJX; else goto cJZ;
      cJZ:
          call (I32[_sHy::P32])(R1) returns to cJX, args: 4, res: 4, upd: 4;
      cJX:
          if (R1 & 3 >= 2) goto cKe; else goto cK5;
      cKe:
          I32[Sp - 4] = cK8;
          P32[Sp - 20] = P32[Sp + 4];
          P32[Sp - 16] = P32[Sp + 8];
          P32[Sp - 12] = P32[Sp + 12];
          P32[Sp - 8] = P32[R1 + 6];
          P32[Sp] = P32[R1 + 2];
          Sp = Sp - 20;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
      cK8:
          _sHA::P32 = P32[Sp + 4];
          I32[Sp + 4] = cKc;
          P32[Sp - 16] = P32[Sp + 8];
          P32[Sp - 12] = P32[Sp + 12];
          P32[Sp - 8] = P32[Sp + 16];
          P32[Sp - 4] = P32[Sp + 20];
          P32[Sp] = _sHA::P32;
          P32[Sp + 20] = R1;
          Sp = Sp - 16;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
      cKc:
          P32[Sp] = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp + 8];
          P32[Sp + 8] = P32[Sp + 12];
          P32[Sp + 12] = R1;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
      cK5:
          R1 = P32[Sp + 16] & (-4);
          Sp = Sp + 20;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
      cJJ:
          R1 = T2902_B_PairingSum.Empty_closure+1;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cKM:
      _sHT::P32 = R1;
      goto cKK;
  cKK:
      if (Sp - <highSp> < SpLim) goto cKN; else goto cKO;
  cKN:
      R1 = _sHT::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cKO:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sHT::P32;
      _sHG::P32 = P32[_sHT::P32 + 8];
      _sHL::P32 = P32[_sHT::P32 + 12];
      _sHP::P32 = P32[_sHT::P32 + 16];
      P32[(old + 28)] = _sHG::P32;
      I32[(old + 24)] = stg_ap_pp_info;
      P32[(old + 20)] = _sHP::P32;
      P32[(old + 16)] = _sHL::P32;
      call GHC.Num.+_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  cKM:
      _sHT::P32 = R1;
      goto cKK;
  cKK:
      if (Sp - <highSp> < SpLim) goto cKN; else goto cKO;
  cKN:
      R1 = _sHT::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cKO:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sHT::P32;
      _sHG::P32 = P32[_sHT::P32 + 8];
      _sHL::P32 = P32[_sHT::P32 + 12];
      _sHP::P32 = P32[_sHT::P32 + 16];
      P32[(old + 28)] = _sHG::P32;
      I32[(old + 24)] = stg_ap_pp_info;
      P32[(old + 20)] = _sHP::P32;
      P32[(old + 16)] = _sHL::P32;
      call GHC.Num.+_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  cKM:
      _sHT::P32 = R1;
      goto cKK;
  cKK:
      if (Sp - <highSp> < SpLim) goto cKN; else goto cKO;
  cKN:
      R1 = _sHT::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cKO:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sHT::P32;
      _sHG::P32 = P32[_sHT::P32 + 8];
      _sHL::P32 = P32[_sHT::P32 + 12];
      _sHP::P32 = P32[_sHT::P32 + 16];
      P32[(old + 28)] = _sHG::P32;
      I32[(old + 24)] = stg_ap_pp_info;
      P32[(old + 20)] = _sHP::P32;
      P32[(old + 16)] = _sHL::P32;
      call GHC.Num.+_info() args: 28, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  cKM:
      _sHT::P32 = R1;
      goto cKK;
  cKK:
      if (Sp - <highSp> < SpLim) goto cKN; else goto cKO;
  cKN:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cKO:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _sHG::P32 = P32[R1 + 8];
      _sHL::P32 = P32[R1 + 12];
      _sHP::P32 = P32[R1 + 16];
      P32[(old + 28)] = _sHG::P32;
      I32[(old + 24)] = stg_ap_pp_info;
      P32[(old + 20)] = _sHP::P32;
      P32[(old + 16)] = _sHL::P32;
      call GHC.Num.+_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  cKM:
      _sHT::P32 = R1;
      goto cKK;
  cKK:
      if (Sp - 24 < SpLim) goto cKN; else goto cKO;
  cKN:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cKO:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _sHG::P32 = P32[R1 + 8];
      _sHL::P32 = P32[R1 + 12];
      _sHP::P32 = P32[R1 + 16];
      P32[Sp - 24] = _sHG::P32;
      I32[Sp - 20] = stg_ap_pp_info;
      P32[Sp - 16] = _sHP::P32;
      P32[Sp - 12] = _sHL::P32;
      Sp = Sp - 24;
      call GHC.Num.+_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  cKM:
      goto cKK;
  cKK:
      if ((Sp + -24) < SpLim) goto cKN; else goto cKO;
  cKN:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cKO:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      P32[Sp - 24] = P32[R1 + 8];
      I32[Sp - 20] = stg_ap_pp_info;
      P32[Sp - 16] = P32[R1 + 16];
      P32[Sp - 12] = P32[R1 + 12];
      Sp = Sp - 24;
      call GHC.Num.+_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(cKK, {}), (cKM, {}), (cKN, {}), (cKO, {})]



==================== after setInfoTableStackMap ====================
ds1_sHT_entry() //  [R1]
        { info_tbl: [(cKM,
                      label: ds1_sHT_info
                      rep:HeapRep 3 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cKM:
          goto cKK;
      cKK:
          if ((Sp + -24) < SpLim) goto cKN; else goto cKO;
      cKN:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cKO:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          P32[Sp - 24] = P32[R1 + 8];
          I32[Sp - 20] = stg_ap_pp_info;
          P32[Sp - 16] = P32[R1 + 16];
          P32[Sp - 12] = P32[R1 + 12];
          Sp = Sp - 24;
          call GHC.Num.+_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
ds1_sHT_entry() //  [R1]
        { info_tbl: [(cKK,
                      label: ds1_sHT_info
                      rep:HeapRep 3 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cKK:
          if ((Sp + -24) < SpLim) goto cKN; else goto cKO;
      cKN:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cKO:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          P32[Sp - 24] = P32[R1 + 8];
          I32[Sp - 20] = stg_ap_pp_info;
          P32[Sp - 16] = P32[R1 + 16];
          P32[Sp - 12] = P32[R1 + 12];
          Sp = Sp - 24;
          call GHC.Num.+_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cL5:
      _sHX::P32 = R1;
      goto cL3;
  cL3:
      if (Sp - <highSp> < SpLim) goto cL6; else goto cL7;
  cL6:
      R1 = _sHX::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cL7:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sHX::P32;
      _sHG::P32 = P32[_sHX::P32 + 8];
      P32[(old + 24)] = _sHG::P32;
      I32[(old + 20)] = stg_ap_p_info;
      P32[(old + 16)] = lvl_rHo_closure+1;
      call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  cL5:
      _sHX::P32 = R1;
      goto cL3;
  cL3:
      if (Sp - <highSp> < SpLim) goto cL6; else goto cL7;
  cL6:
      R1 = _sHX::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cL7:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sHX::P32;
      _sHG::P32 = P32[_sHX::P32 + 8];
      P32[(old + 24)] = _sHG::P32;
      I32[(old + 20)] = stg_ap_p_info;
      P32[(old + 16)] = lvl_rHo_closure+1;
      call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  cL5:
      _sHX::P32 = R1;
      goto cL3;
  cL3:
      if (Sp - <highSp> < SpLim) goto cL6; else goto cL7;
  cL6:
      R1 = _sHX::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cL7:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sHX::P32;
      _sHG::P32 = P32[_sHX::P32 + 8];
      P32[(old + 24)] = _sHG::P32;
      I32[(old + 20)] = stg_ap_p_info;
      P32[(old + 16)] = lvl_rHo_closure+1;
      call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  cL5:
      _sHX::P32 = R1;
      goto cL3;
  cL3:
      if (Sp - <highSp> < SpLim) goto cL6; else goto cL7;
  cL6:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cL7:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _sHG::P32 = P32[R1 + 8];
      P32[(old + 24)] = _sHG::P32;
      I32[(old + 20)] = stg_ap_p_info;
      P32[(old + 16)] = lvl_rHo_closure+1;
      call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  cL5:
      _sHX::P32 = R1;
      goto cL3;
  cL3:
      if (Sp - 20 < SpLim) goto cL6; else goto cL7;
  cL6:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cL7:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _sHG::P32 = P32[R1 + 8];
      P32[Sp - 20] = _sHG::P32;
      I32[Sp - 16] = stg_ap_p_info;
      P32[Sp - 12] = lvl_rHo_closure+1;
      Sp = Sp - 20;
      call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  cL5:
      goto cL3;
  cL3:
      if ((Sp + -20) < SpLim) goto cL6; else goto cL7;
  cL6:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cL7:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      P32[Sp - 20] = P32[R1 + 8];
      I32[Sp - 16] = stg_ap_p_info;
      P32[Sp - 12] = lvl_rHo_closure+1;
      Sp = Sp - 20;
      call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(cL3, {lvl_rHo_closure}), (cL5, {lvl_rHo_closure}), (cL6, {}),
 (cL7, {lvl_rHo_closure})]



==================== after setInfoTableStackMap ====================
sat_sHX_entry() //  [R1]
        { info_tbl: [(cL5,
                      label: sat_sHX_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cL5:
          goto cL3;
      cL3:
          if ((Sp + -20) < SpLim) goto cL6; else goto cL7;
      cL6:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cL7:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          P32[Sp - 20] = P32[R1 + 8];
          I32[Sp - 16] = stg_ap_p_info;
          P32[Sp - 12] = lvl_rHo_closure+1;
          Sp = Sp - 20;
          call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_sHX_entry() //  [R1]
        { info_tbl: [(cL3,
                      label: sat_sHX_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cL3:
          if ((Sp + -20) < SpLim) goto cL6; else goto cL7;
      cL6:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cL7:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          P32[Sp - 20] = P32[R1 + 8];
          I32[Sp - 16] = stg_ap_p_info;
          P32[Sp - 12] = lvl_rHo_closure+1;
          Sp = Sp - 20;
          call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cLf:
      _sHE::P32 = P32[(old + 24)];
      _sHF::P32 = P32[(old + 20)];
      _sHG::P32 = P32[(old + 16)];
      _sHH::P32 = P32[(old + 12)];
      _sHI::P32 = P32[(old + 8)];
      goto cKp;
  cKp:
      if (Sp - <highSp> < SpLim) goto cLg; else goto cLh;
  cLg:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
      P32[(old + 24)] = _sHE::P32;
      P32[(old + 20)] = _sHF::P32;
      P32[(old + 16)] = _sHG::P32;
      P32[(old + 12)] = _sHH::P32;
      P32[(old + 8)] = _sHI::P32;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
  cLh:
      I32[(young<cKr> + 4)] = cKr;
      R1 = _sHI::P32;
      if (R1 & 3 != 0) goto cKr; else goto cKs;
  cKs:
      call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
  cKr:
      _sHJ::P32 = R1;
      _cLb::P32 = _sHJ::P32 & 3;
      if (_cLb::P32 >= 2) goto cLa; else goto cL9;
  cLa:
      _sHK::P32 = P32[_sHJ::P32 + 2];
      _sHL::P32 = P32[_sHJ::P32 + 6];
      _sHM::P32 = P32[_sHJ::P32 + 10];
      I32[(young<cKx> + 4)] = cKx;
      R1 = _sHH::P32;
      if (R1 & 3 != 0) goto cKx; else goto cKy;
  cKy:
      call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
  cKx:
      _sHN::P32 = R1;
      _cMc::P32 = _sHN::P32 & 3;
      if (_cMc::P32 >= 2) goto cLq; else goto cLo;
  cLq:
      _sHO::P32 = P32[_sHN::P32 + 2];
      _sHP::P32 = P32[_sHN::P32 + 6];
      _sHQ::P32 = P32[_sHN::P32 + 10];
      I32[(young<cKD> + 4)] = cKD;
      P32[(young<cKD> + 20)] = _sHE::P32;
      I32[(young<cKD> + 16)] = stg_ap_pp_info;
      P32[(young<cKD> + 12)] = _sHO::P32;
      P32[(young<cKD> + 8)] = _sHK::P32;
      call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
  cKD:
      _sHR::P32 = R1;
      _cM5::P32 = _sHR::P32 & 3;
      if (_cM5::P32 >= 2) goto cMa; else goto cLv;
  cMa:
      if (_cM5::P32 >= 3) goto cM1; else goto cLz;
  cM1:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cM3;
  cM4:
      HpAlloc = 28;
      goto cM2;
  cM2:
      R1 = _sHR::P32;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cM3:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHN::P32;
      P32[Hp - 16] = _sHM::P32;
      _cLZ::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHK::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _cLZ::P32;
      _cM0::P32 = Hp - 10;
      R1 = _cM0::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLz:
      Hp = Hp + 20;
      if (Hp > HpLim) goto cLC; else goto cLB;
  cLC:
      HpAlloc = 20;
      goto cLA;
  cLA:
      R1 = _sHR::P32;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLB:
      I32[Hp - 16] = ds1_sHT_info;
      P32[Hp - 8] = _sHG::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _sHP::P32;
      _cKI::P32 = Hp - 16;
      I32[(young<cKP> + 4)] = cKP;
      P32[(young<cKP> + 20)] = _sHE::P32;
      P32[(young<cKP> + 16)] = _sHF::P32;
      P32[(young<cKP> + 12)] = _sHG::P32;
      P32[(young<cKP> + 8)] = _sHM::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
  cKP:
      _sHW::P32 = R1;
      I32[(young<cKT> + 4)] = cKT;
      P32[(young<cKT> + 20)] = _sHE::P32;
      P32[(young<cKT> + 16)] = _sHF::P32;
      P32[(young<cKT> + 12)] = _sHG::P32;
      P32[(young<cKT> + 8)] = _sHQ::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
  cKT:
      _sHV::P32 = R1;
      I32[(young<cKX> + 4)] = cKX;
      P32[(young<cKX> + 24)] = _sHE::P32;
      P32[(young<cKX> + 20)] = _sHF::P32;
      P32[(young<cKX> + 16)] = _sHG::P32;
      P32[(young<cKX> + 12)] = _sHV::P32;
      P32[(young<cKX> + 8)] = _sHW::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
  cKX:
      _sHU::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto cLI; else goto cLH;
  cLI:
      HpAlloc = 12;
      goto cLG;
  cLG:
      R1 = _sHU::P32;
      call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
  cLH:
      I32[Hp - 8] = sat_sHX_info;
      P32[Hp] = _sHG::P32;
      _cL1::P32 = Hp - 8;
      I32[(young<cLF> + 4)] = cLF;
      P32[(young<cLF> + 20)] = _sHF::P32;
      I32[(young<cLF> + 16)] = stg_ap_pp_info;
      P32[(young<cLF> + 12)] = _cKI::P32;
      P32[(young<cLF> + 8)] = _cL1::P32;
      call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
  cLF:
      _sHY::P32 = R1;
      _cLT::P32 = _sHY::P32 & 3;
      if (_cLT::P32 >= 2) goto cLS; else goto cLO;
  cLS:
      R1 = _sHU::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cLO:
      P32[(old + 28)] = _sHE::P32;
      P32[(old + 24)] = _sHF::P32;
      P32[(old + 20)] = _sHG::P32;
      P32[(old + 16)] = _sHO::P32;
      P32[(old + 12)] = _cKI::P32;
      P32[(old + 8)] = _sHU::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cLv:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cLy; else goto cLx;
  cLy:
      HpAlloc = 28;
      goto cLw;
  cLw:
      R1 = _sHR::P32;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLx:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHJ::P32;
      P32[Hp - 16] = _sHQ::P32;
      _cLs::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHO::P32;
      P32[Hp - 4] = _sHP::P32;
      P32[Hp] = _cLs::P32;
      _cLt::P32 = Hp - 10;
      R1 = _cLt::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLo:
      R1 = _sHJ::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cL9:
      R1 = _sHH::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cLf:
      _sHE::P32 = P32[(old + 24)];
      _sHF::P32 = P32[(old + 20)];
      _sHG::P32 = P32[(old + 16)];
      _sHH::P32 = P32[(old + 12)];
      _sHI::P32 = P32[(old + 8)];
      goto cKp;
  cKp:
      if (Sp - <highSp> < SpLim) goto cLg; else goto cLh;
  cLg:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
      P32[(old + 24)] = _sHE::P32;
      P32[(old + 20)] = _sHF::P32;
      P32[(old + 16)] = _sHG::P32;
      P32[(old + 12)] = _sHH::P32;
      P32[(old + 8)] = _sHI::P32;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
  cLh:
      I32[(young<cKr> + 4)] = cKr;
      R1 = _sHI::P32;
      if (R1 & 3 != 0) goto cKr; else goto cKs;
  cKs:
      call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
  cKr:
      _sHJ::P32 = R1;
      _cLb::P32 = _sHJ::P32 & 3;
      if (_cLb::P32 >= 2) goto cLa; else goto cL9;
  cLa:
      _sHK::P32 = P32[_sHJ::P32 + 2];
      _sHL::P32 = P32[_sHJ::P32 + 6];
      _sHM::P32 = P32[_sHJ::P32 + 10];
      I32[(young<cKx> + 4)] = cKx;
      R1 = _sHH::P32;
      if (R1 & 3 != 0) goto cKx; else goto cKy;
  cKy:
      call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
  cKx:
      _sHN::P32 = R1;
      _cMc::P32 = _sHN::P32 & 3;
      if (_cMc::P32 >= 2) goto cLq; else goto cLo;
  cLq:
      _sHO::P32 = P32[_sHN::P32 + 2];
      _sHP::P32 = P32[_sHN::P32 + 6];
      _sHQ::P32 = P32[_sHN::P32 + 10];
      I32[(young<cKD> + 4)] = cKD;
      P32[(young<cKD> + 20)] = _sHE::P32;
      I32[(young<cKD> + 16)] = stg_ap_pp_info;
      P32[(young<cKD> + 12)] = _sHO::P32;
      P32[(young<cKD> + 8)] = _sHK::P32;
      call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
  cKD:
      _sHR::P32 = R1;
      _cM5::P32 = _sHR::P32 & 3;
      if (_cM5::P32 >= 2) goto cMa; else goto cLv;
  cMa:
      if (_cM5::P32 >= 3) goto cM1; else goto cLz;
  cM1:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cM3;
  cM3:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHN::P32;
      P32[Hp - 16] = _sHM::P32;
      _cLZ::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHK::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _cLZ::P32;
      _cM0::P32 = Hp - 10;
      R1 = _cM0::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLz:
      Hp = Hp + 20;
      if (Hp > HpLim) goto cLC; else goto cLB;
  cLC:
      HpAlloc = 20;
      goto cM2;
  cLB:
      I32[Hp - 16] = ds1_sHT_info;
      P32[Hp - 8] = _sHG::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _sHP::P32;
      _cKI::P32 = Hp - 16;
      I32[(young<cKP> + 4)] = cKP;
      P32[(young<cKP> + 20)] = _sHE::P32;
      P32[(young<cKP> + 16)] = _sHF::P32;
      P32[(young<cKP> + 12)] = _sHG::P32;
      P32[(young<cKP> + 8)] = _sHM::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
  cKP:
      _sHW::P32 = R1;
      I32[(young<cKT> + 4)] = cKT;
      P32[(young<cKT> + 20)] = _sHE::P32;
      P32[(young<cKT> + 16)] = _sHF::P32;
      P32[(young<cKT> + 12)] = _sHG::P32;
      P32[(young<cKT> + 8)] = _sHQ::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
  cKT:
      _sHV::P32 = R1;
      I32[(young<cKX> + 4)] = cKX;
      P32[(young<cKX> + 24)] = _sHE::P32;
      P32[(young<cKX> + 20)] = _sHF::P32;
      P32[(young<cKX> + 16)] = _sHG::P32;
      P32[(young<cKX> + 12)] = _sHV::P32;
      P32[(young<cKX> + 8)] = _sHW::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
  cKX:
      _sHU::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto cLI; else goto cLH;
  cLI:
      HpAlloc = 12;
      goto cLG;
  cLG:
      R1 = _sHU::P32;
      call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
  cLH:
      I32[Hp - 8] = sat_sHX_info;
      P32[Hp] = _sHG::P32;
      _cL1::P32 = Hp - 8;
      I32[(young<cLF> + 4)] = cLF;
      P32[(young<cLF> + 20)] = _sHF::P32;
      I32[(young<cLF> + 16)] = stg_ap_pp_info;
      P32[(young<cLF> + 12)] = _cKI::P32;
      P32[(young<cLF> + 8)] = _cL1::P32;
      call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
  cLF:
      _sHY::P32 = R1;
      _cLT::P32 = _sHY::P32 & 3;
      if (_cLT::P32 >= 2) goto cLS; else goto cLO;
  cLS:
      R1 = _sHU::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cLO:
      P32[(old + 28)] = _sHE::P32;
      P32[(old + 24)] = _sHF::P32;
      P32[(old + 20)] = _sHG::P32;
      P32[(old + 16)] = _sHO::P32;
      P32[(old + 12)] = _cKI::P32;
      P32[(old + 8)] = _sHU::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cLv:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cLx;
  cM4:
      HpAlloc = 28;
      goto cM2;
  cM2:
      R1 = _sHR::P32;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLx:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHJ::P32;
      P32[Hp - 16] = _sHQ::P32;
      _cLs::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHO::P32;
      P32[Hp - 4] = _sHP::P32;
      P32[Hp] = _cLs::P32;
      _cLt::P32 = Hp - 10;
      R1 = _cLt::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLo:
      R1 = _sHJ::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cL9:
      R1 = _sHH::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cLf:
      _sHE::P32 = P32[(old + 24)];
      _sHF::P32 = P32[(old + 20)];
      _sHG::P32 = P32[(old + 16)];
      _sHH::P32 = P32[(old + 12)];
      _sHI::P32 = P32[(old + 8)];
      goto cKp;
  cKp:
      if (Sp - <highSp> < SpLim) goto cLg; else goto cLh;
  cLg:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
      P32[(old + 24)] = _sHE::P32;
      P32[(old + 20)] = _sHF::P32;
      P32[(old + 16)] = _sHG::P32;
      P32[(old + 12)] = _sHH::P32;
      P32[(old + 8)] = _sHI::P32;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
  cLh:
      I32[(young<cKr> + 4)] = cKr;
      R1 = _sHI::P32;
      if (R1 & 3 != 0) goto cKr; else goto cKs;
  cKs:
      call (I32[R1])(R1) returns to cKr, args: 4, res: 4, upd: 4;
  cKr:
      _sHJ::P32 = R1;
      _cLb::P32 = _sHJ::P32 & 3;
      if (_cLb::P32 >= 2) goto cLa; else goto cL9;
  cLa:
      _sHK::P32 = P32[_sHJ::P32 + 2];
      _sHL::P32 = P32[_sHJ::P32 + 6];
      _sHM::P32 = P32[_sHJ::P32 + 10];
      I32[(young<cKx> + 4)] = cKx;
      R1 = _sHH::P32;
      if (R1 & 3 != 0) goto cKx; else goto cKy;
  cKy:
      call (I32[R1])(R1) returns to cKx, args: 4, res: 4, upd: 4;
  cKx:
      _sHN::P32 = R1;
      _cMc::P32 = _sHN::P32 & 3;
      if (_cMc::P32 >= 2) goto cLq; else goto cLo;
  cLq:
      _sHO::P32 = P32[_sHN::P32 + 2];
      _sHP::P32 = P32[_sHN::P32 + 6];
      _sHQ::P32 = P32[_sHN::P32 + 10];
      I32[(young<cKD> + 4)] = cKD;
      P32[(young<cKD> + 20)] = _sHE::P32;
      I32[(young<cKD> + 16)] = stg_ap_pp_info;
      P32[(young<cKD> + 12)] = _sHO::P32;
      P32[(young<cKD> + 8)] = _sHK::P32;
      call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
  cKD:
      _sHR::P32 = R1;
      _cM5::P32 = _sHR::P32 & 3;
      if (_cM5::P32 >= 2) goto cMa; else goto cLv;
  cMa:
      if (_cM5::P32 >= 3) goto cM1; else goto cLz;
  cM1:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cM3;
  cM3:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHN::P32;
      P32[Hp - 16] = _sHM::P32;
      _cLZ::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHK::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _cLZ::P32;
      _cM0::P32 = Hp - 10;
      R1 = _cM0::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLz:
      Hp = Hp + 20;
      if (Hp > HpLim) goto cLC; else goto cLB;
  cLC:
      HpAlloc = 20;
      goto cM2;
  cLB:
      I32[Hp - 16] = ds1_sHT_info;
      P32[Hp - 8] = _sHG::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _sHP::P32;
      _cKI::P32 = Hp - 16;
      I32[(young<cKP> + 4)] = cKP;
      P32[(young<cKP> + 20)] = _sHE::P32;
      P32[(young<cKP> + 16)] = _sHF::P32;
      P32[(young<cKP> + 12)] = _sHG::P32;
      P32[(young<cKP> + 8)] = _sHM::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
  cKP:
      _sHW::P32 = R1;
      I32[(young<cKT> + 4)] = cKT;
      P32[(young<cKT> + 20)] = _sHE::P32;
      P32[(young<cKT> + 16)] = _sHF::P32;
      P32[(young<cKT> + 12)] = _sHG::P32;
      P32[(young<cKT> + 8)] = _sHQ::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
  cKT:
      _sHV::P32 = R1;
      I32[(young<cKX> + 4)] = cKX;
      P32[(young<cKX> + 24)] = _sHE::P32;
      P32[(young<cKX> + 20)] = _sHF::P32;
      P32[(young<cKX> + 16)] = _sHG::P32;
      P32[(young<cKX> + 12)] = _sHV::P32;
      P32[(young<cKX> + 8)] = _sHW::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
  cKX:
      _sHU::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto cLI; else goto cLH;
  cLI:
      HpAlloc = 12;
      goto cLG;
  cLG:
      R1 = _sHU::P32;
      call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
  cLH:
      I32[Hp - 8] = sat_sHX_info;
      P32[Hp] = _sHG::P32;
      _cL1::P32 = Hp - 8;
      I32[(young<cLF> + 4)] = cLF;
      P32[(young<cLF> + 20)] = _sHF::P32;
      I32[(young<cLF> + 16)] = stg_ap_pp_info;
      P32[(young<cLF> + 12)] = _cKI::P32;
      P32[(young<cLF> + 8)] = _cL1::P32;
      call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
  cLF:
      _sHY::P32 = R1;
      _cLT::P32 = _sHY::P32 & 3;
      if (_cLT::P32 >= 2) goto cLS; else goto cLO;
  cLS:
      R1 = _sHU::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cLO:
      P32[(old + 28)] = _sHE::P32;
      P32[(old + 24)] = _sHF::P32;
      P32[(old + 20)] = _sHG::P32;
      P32[(old + 16)] = _sHO::P32;
      P32[(old + 12)] = _cKI::P32;
      P32[(old + 8)] = _sHU::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cLv:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cLx;
  cM4:
      HpAlloc = 28;
      goto cM2;
  cM2:
      R1 = _sHR::P32;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLx:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHJ::P32;
      P32[Hp - 16] = _sHQ::P32;
      _cLs::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHO::P32;
      P32[Hp - 4] = _sHP::P32;
      P32[Hp] = _cLs::P32;
      _cLt::P32 = Hp - 10;
      R1 = _cLt::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLo:
      R1 = _sHJ::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cL9:
      R1 = _sHH::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cLf:
      _sHE::P32 = P32[(old + 24)];
      _sHF::P32 = P32[(old + 20)];
      _sHG::P32 = P32[(old + 16)];
      _sHH::P32 = P32[(old + 12)];
      _sHI::P32 = P32[(old + 8)];
      goto cKp;
  cKp:
      if (Sp - <highSp> < SpLim) goto cLg; else goto cLh;
  cLg:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
      P32[(old + 24)] = _sHE::P32;
      P32[(old + 20)] = _sHF::P32;
      P32[(old + 16)] = _sHG::P32;
      P32[(old + 12)] = _sHH::P32;
      P32[(old + 8)] = _sHI::P32;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
  cLh:
      I32[(young<cKr> + 4)] = cKr;
      R1 = _sHI::P32;
      if (_sHI::P32 & 3 != 0) goto cKr; else goto cKs;
  cKs:
      call (I32[_sHI::P32])(R1) returns to cKr, args: 4, res: 4, upd: 4;
  cKr:
      _sHJ::P32 = R1;
      _cLb::P32 = R1 & 3;
      if (_cLb::P32 >= 2) goto cLa; else goto cL9;
  cLa:
      _sHK::P32 = P32[R1 + 2];
      _sHL::P32 = P32[R1 + 6];
      _sHM::P32 = P32[R1 + 10];
      I32[(young<cKx> + 4)] = cKx;
      R1 = _sHH::P32;
      if (_sHH::P32 & 3 != 0) goto cKx; else goto cKy;
  cKy:
      call (I32[_sHH::P32])(R1) returns to cKx, args: 4, res: 4, upd: 4;
  cKx:
      _sHN::P32 = R1;
      _cMc::P32 = R1 & 3;
      if (_cMc::P32 >= 2) goto cLq; else goto cLo;
  cLq:
      _sHO::P32 = P32[R1 + 2];
      _sHP::P32 = P32[R1 + 6];
      _sHQ::P32 = P32[R1 + 10];
      I32[(young<cKD> + 4)] = cKD;
      P32[(young<cKD> + 20)] = _sHE::P32;
      I32[(young<cKD> + 16)] = stg_ap_pp_info;
      P32[(young<cKD> + 12)] = _sHO::P32;
      P32[(young<cKD> + 8)] = _sHK::P32;
      call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
  cKD:
      _sHR::P32 = R1;
      _cM5::P32 = R1 & 3;
      if (_cM5::P32 >= 2) goto cMa; else goto cLv;
  cMa:
      if (_cM5::P32 >= 3) goto cM1; else goto cLz;
  cM1:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cM3;
  cM3:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHN::P32;
      P32[Hp - 16] = _sHM::P32;
      _cLZ::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHK::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _cLZ::P32;
      _cM0::P32 = Hp - 10;
      R1 = _cM0::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLz:
      Hp = Hp + 20;
      if (Hp > HpLim) goto cLC; else goto cLB;
  cLC:
      HpAlloc = 20;
      goto cM2;
  cLB:
      I32[Hp - 16] = ds1_sHT_info;
      P32[Hp - 8] = _sHG::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _sHP::P32;
      _cKI::P32 = Hp - 16;
      I32[(young<cKP> + 4)] = cKP;
      P32[(young<cKP> + 20)] = _sHE::P32;
      P32[(young<cKP> + 16)] = _sHF::P32;
      P32[(young<cKP> + 12)] = _sHG::P32;
      P32[(young<cKP> + 8)] = _sHM::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
  cKP:
      _sHW::P32 = R1;
      I32[(young<cKT> + 4)] = cKT;
      P32[(young<cKT> + 20)] = _sHE::P32;
      P32[(young<cKT> + 16)] = _sHF::P32;
      P32[(young<cKT> + 12)] = _sHG::P32;
      P32[(young<cKT> + 8)] = _sHQ::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
  cKT:
      _sHV::P32 = R1;
      I32[(young<cKX> + 4)] = cKX;
      P32[(young<cKX> + 24)] = _sHE::P32;
      P32[(young<cKX> + 20)] = _sHF::P32;
      P32[(young<cKX> + 16)] = _sHG::P32;
      P32[(young<cKX> + 12)] = R1;
      P32[(young<cKX> + 8)] = _sHW::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
  cKX:
      _sHU::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto cLI; else goto cLH;
  cLI:
      HpAlloc = 12;
      goto cLG;
  cLG:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
  cLH:
      I32[Hp - 8] = sat_sHX_info;
      P32[Hp] = _sHG::P32;
      _cL1::P32 = Hp - 8;
      I32[(young<cLF> + 4)] = cLF;
      P32[(young<cLF> + 20)] = _sHF::P32;
      I32[(young<cLF> + 16)] = stg_ap_pp_info;
      P32[(young<cLF> + 12)] = _cKI::P32;
      P32[(young<cLF> + 8)] = _cL1::P32;
      call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
  cLF:
      _sHY::P32 = R1;
      _cLT::P32 = R1 & 3;
      if (_cLT::P32 >= 2) goto cLS; else goto cLO;
  cLS:
      R1 = _sHU::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cLO:
      P32[(old + 28)] = _sHE::P32;
      P32[(old + 24)] = _sHF::P32;
      P32[(old + 20)] = _sHG::P32;
      P32[(old + 16)] = _sHO::P32;
      P32[(old + 12)] = _cKI::P32;
      P32[(old + 8)] = _sHU::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cLv:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cLx;
  cM4:
      HpAlloc = 28;
      goto cM2;
  cM2:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLx:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHJ::P32;
      P32[Hp - 16] = _sHQ::P32;
      _cLs::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHO::P32;
      P32[Hp - 4] = _sHP::P32;
      P32[Hp] = _cLs::P32;
      _cLt::P32 = Hp - 10;
      R1 = _cLt::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cLo:
      R1 = _sHJ::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cL9:
      R1 = _sHH::P32 & (-4);
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cLf:
      _sHE::P32 = P32[Sp];
      _sHF::P32 = P32[Sp + 4];
      _sHG::P32 = P32[Sp + 8];
      _sHH::P32 = P32[Sp + 12];
      _sHI::P32 = P32[Sp + 16];
      goto cKp;
  cKp:
      if (Sp - 48 < SpLim) goto cLg; else goto cLh;
  cLg:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
  cLh:
      I32[Sp - 4] = cKr;
      R1 = _sHI::P32;
      Sp = Sp - 4;
      if (_sHI::P32 & 3 != 0) goto cKr; else goto cKs;
  cKs:
      call (I32[_sHI::P32])(R1) returns to cKr, args: 4, res: 4, upd: 4;
  cKr:
      _sHE::P32 = P32[Sp + 4];
      _sHF::P32 = P32[Sp + 8];
      _sHG::P32 = P32[Sp + 12];
      _sHH::P32 = P32[Sp + 16];
      _sHJ::P32 = R1;
      _cLb::P32 = R1 & 3;
      if (_cLb::P32 >= 2) goto cLa; else goto cL9;
  cLa:
      _sHK::P32 = P32[R1 + 2];
      _sHL::P32 = P32[R1 + 6];
      _sHM::P32 = P32[R1 + 10];
      I32[Sp - 8] = cKx;
      R1 = _sHH::P32;
      P32[Sp - 4] = _sHM::P32;
      P32[Sp] = _sHL::P32;
      P32[Sp + 16] = _sHK::P32;
      P32[Sp + 20] = _sHJ::P32;
      Sp = Sp - 8;
      if (_sHH::P32 & 3 != 0) goto cKx; else goto cKy;
  cKy:
      call (I32[_sHH::P32])(R1) returns to cKx, args: 4, res: 4, upd: 4;
  cKx:
      _sHE::P32 = P32[Sp + 12];
      _sHF::P32 = P32[Sp + 16];
      _sHG::P32 = P32[Sp + 20];
      _sHJ::P32 = P32[Sp + 28];
      _sHK::P32 = P32[Sp + 24];
      _sHL::P32 = P32[Sp + 8];
      _sHM::P32 = P32[Sp + 4];
      _sHN::P32 = R1;
      _cMc::P32 = R1 & 3;
      if (_cMc::P32 >= 2) goto cLq; else goto cLo;
  cLq:
      _sHO::P32 = P32[R1 + 2];
      _sHP::P32 = P32[R1 + 6];
      _sHQ::P32 = P32[R1 + 10];
      I32[Sp - 16] = cKD;
      P32[Sp - 32] = _sHE::P32;
      I32[Sp - 28] = stg_ap_pp_info;
      P32[Sp - 24] = _sHO::P32;
      P32[Sp - 20] = _sHK::P32;
      P32[Sp - 12] = _sHO::P32;
      P32[Sp - 8] = _sHP::P32;
      P32[Sp - 4] = _sHQ::P32;
      P32[Sp] = _sHN::P32;
      Sp = Sp - 32;
      call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
  cKD:
      _sHE::P32 = P32[Sp + 28];
      _sHF::P32 = P32[Sp + 32];
      _sHG::P32 = P32[Sp + 36];
      _sHJ::P32 = P32[Sp + 44];
      _sHK::P32 = P32[Sp + 40];
      _sHL::P32 = P32[Sp + 24];
      _sHM::P32 = P32[Sp + 20];
      _sHN::P32 = P32[Sp + 16];
      _sHO::P32 = P32[Sp + 4];
      _sHP::P32 = P32[Sp + 8];
      _sHQ::P32 = P32[Sp + 12];
      _sHR::P32 = R1;
      _cM5::P32 = R1 & 3;
      if (_cM5::P32 >= 2) goto cMa; else goto cLv;
  cMa:
      if (_cM5::P32 >= 3) goto cM1; else goto cLz;
  cM1:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cM3;
  cM3:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHN::P32;
      P32[Hp - 16] = _sHM::P32;
      _cLZ::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHK::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _cLZ::P32;
      _cM0::P32 = Hp - 10;
      R1 = _cM0::P32;
      Sp = Sp + 48;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cLz:
      Hp = Hp + 20;
      if (Hp > HpLim) goto cLC; else goto cLB;
  cLC:
      HpAlloc = 20;
      goto cM2;
  cLB:
      I32[Hp - 16] = ds1_sHT_info;
      P32[Hp - 8] = _sHG::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _sHP::P32;
      _cKI::P32 = Hp - 16;
      I32[Sp] = cKP;
      P32[Sp - 16] = _sHE::P32;
      P32[Sp - 12] = _sHF::P32;
      P32[Sp - 8] = _sHG::P32;
      P32[Sp - 4] = _sHM::P32;
      P32[Sp + 44] = _cKI::P32;
      Sp = Sp - 16;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
  cKP:
      _cKI::P32 = P32[Sp + 44];
      _sHE::P32 = P32[Sp + 28];
      _sHF::P32 = P32[Sp + 32];
      _sHG::P32 = P32[Sp + 36];
      _sHO::P32 = P32[Sp + 4];
      _sHQ::P32 = P32[Sp + 12];
      _sHW::P32 = R1;
      I32[Sp] = cKT;
      P32[Sp - 16] = _sHE::P32;
      P32[Sp - 12] = _sHF::P32;
      P32[Sp - 8] = _sHG::P32;
      P32[Sp - 4] = _sHQ::P32;
      P32[Sp + 40] = _sHW::P32;
      Sp = Sp - 16;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
  cKT:
      _cKI::P32 = P32[Sp + 44];
      _sHE::P32 = P32[Sp + 28];
      _sHF::P32 = P32[Sp + 32];
      _sHG::P32 = P32[Sp + 36];
      _sHO::P32 = P32[Sp + 4];
      _sHW::P32 = P32[Sp + 40];
      _sHV::P32 = R1;
      I32[Sp] = cKX;
      P32[Sp - 20] = _sHE::P32;
      P32[Sp - 16] = _sHF::P32;
      P32[Sp - 12] = _sHG::P32;
      P32[Sp - 8] = R1;
      P32[Sp - 4] = _sHW::P32;
      Sp = Sp - 20;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
  cKX:
      _cKI::P32 = P32[Sp + 44];
      _sHE::P32 = P32[Sp + 28];
      _sHF::P32 = P32[Sp + 32];
      _sHG::P32 = P32[Sp + 36];
      _sHO::P32 = P32[Sp + 4];
      _sHU::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto cLI; else goto cLH;
  cLI:
      HpAlloc = 12;
      goto cLG;
  cLG:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
  cLH:
      I32[Hp - 8] = sat_sHX_info;
      P32[Hp] = _sHG::P32;
      _cL1::P32 = Hp - 8;
      I32[Sp] = cLF;
      P32[Sp - 16] = _sHF::P32;
      I32[Sp - 12] = stg_ap_pp_info;
      P32[Sp - 8] = _cKI::P32;
      P32[Sp - 4] = _cL1::P32;
      P32[Sp + 40] = _sHU::P32;
      Sp = Sp - 16;
      call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
  cLF:
      _cKI::P32 = P32[Sp + 44];
      _sHE::P32 = P32[Sp + 28];
      _sHF::P32 = P32[Sp + 32];
      _sHG::P32 = P32[Sp + 36];
      _sHO::P32 = P32[Sp + 4];
      _sHU::P32 = P32[Sp + 40];
      _sHY::P32 = R1;
      _cLT::P32 = R1 & 3;
      if (_cLT::P32 >= 2) goto cLS; else goto cLO;
  cLS:
      R1 = _sHU::P32 & (-4);
      Sp = Sp + 48;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cLO:
      P32[Sp + 24] = _sHE::P32;
      P32[Sp + 28] = _sHF::P32;
      P32[Sp + 32] = _sHG::P32;
      P32[Sp + 36] = _sHO::P32;
      P32[Sp + 40] = _cKI::P32;
      P32[Sp + 44] = _sHU::P32;
      Sp = Sp + 24;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cLv:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cLx;
  cM4:
      HpAlloc = 28;
      goto cM2;
  cM2:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLx:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = _sHJ::P32;
      P32[Hp - 16] = _sHQ::P32;
      _cLs::P32 = Hp - 22;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sHO::P32;
      P32[Hp - 4] = _sHP::P32;
      P32[Hp] = _cLs::P32;
      _cLt::P32 = Hp - 10;
      R1 = _cLt::P32;
      Sp = Sp + 48;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cLo:
      R1 = _sHJ::P32 & (-4);
      Sp = Sp + 32;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cL9:
      R1 = _sHH::P32 & (-4);
      Sp = Sp + 24;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cLf:
      goto cKp;
  cKp:
      if ((Sp + -48) < SpLim) goto cLg; else goto cLh;
  cLg:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
  cLh:
      I32[Sp - 4] = cKr;
      _sHI::P32 = P32[Sp + 16];
      R1 = _sHI::P32;
      Sp = Sp - 4;
      if (_sHI::P32 & 3 != 0) goto cKr; else goto cKs;
  cKs:
      call (I32[_sHI::P32])(R1) returns to cKr, args: 4, res: 4, upd: 4;
  cKr:
      _sHH::P32 = P32[Sp + 16];
      if (R1 & 3 >= 2) goto cLa; else goto cL9;
  cLa:
      I32[Sp - 8] = cKx;
      _sHJ::P32 = R1;
      _sHK::P32 = P32[R1 + 2];
      _sHL::P32 = P32[R1 + 6];
      _sHM::P32 = P32[R1 + 10];
      R1 = _sHH::P32;
      P32[Sp - 4] = _sHM::P32;
      P32[Sp] = _sHL::P32;
      P32[Sp + 16] = _sHK::P32;
      P32[Sp + 20] = _sHJ::P32;
      Sp = Sp - 8;
      if (_sHH::P32 & 3 != 0) goto cKx; else goto cKy;
  cKy:
      call (I32[_sHH::P32])(R1) returns to cKx, args: 4, res: 4, upd: 4;
  cKx:
      if (R1 & 3 >= 2) goto cLq; else goto cLo;
  cLq:
      I32[Sp - 16] = cKD;
      P32[Sp - 32] = P32[Sp + 12];
      I32[Sp - 28] = stg_ap_pp_info;
      _sHO::P32 = P32[R1 + 2];
      P32[Sp - 24] = _sHO::P32;
      P32[Sp - 20] = P32[Sp + 24];
      P32[Sp - 12] = _sHO::P32;
      P32[Sp - 8] = P32[R1 + 6];
      P32[Sp - 4] = P32[R1 + 10];
      P32[Sp] = R1;
      Sp = Sp - 32;
      call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
  cKD:
      _sHP::P32 = P32[Sp + 8];
      _cM5::P32 = R1 & 3;
      if (_cM5::P32 >= 2) goto cMa; else goto cLv;
  cMa:
      _sHL::P32 = P32[Sp + 24];
      _sHM::P32 = P32[Sp + 20];
      if (_cM5::P32 >= 3) goto cM1; else goto cLz;
  cM1:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cM3;
  cM3:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = P32[Sp + 16];
      P32[Hp - 16] = _sHM::P32;
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = P32[Sp + 40];
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = Hp - 22;
      R1 = Hp - 10;
      Sp = Sp + 48;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cLz:
      Hp = Hp + 20;
      if (Hp > HpLim) goto cLC; else goto cLB;
  cLC:
      HpAlloc = 20;
      goto cM2;
  cLB:
      I32[Hp - 16] = ds1_sHT_info;
      _sHG::P32 = P32[Sp + 36];
      P32[Hp - 8] = _sHG::P32;
      P32[Hp - 4] = _sHL::P32;
      P32[Hp] = _sHP::P32;
      I32[Sp] = cKP;
      P32[Sp - 16] = P32[Sp + 28];
      P32[Sp - 12] = P32[Sp + 32];
      P32[Sp - 8] = _sHG::P32;
      P32[Sp - 4] = _sHM::P32;
      P32[Sp + 44] = Hp - 16;
      Sp = Sp - 16;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
  cKP:
      I32[Sp] = cKT;
      P32[Sp - 16] = P32[Sp + 28];
      P32[Sp - 12] = P32[Sp + 32];
      P32[Sp - 8] = P32[Sp + 36];
      P32[Sp - 4] = P32[Sp + 12];
      P32[Sp + 40] = R1;
      Sp = Sp - 16;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
  cKT:
      I32[Sp] = cKX;
      P32[Sp - 20] = P32[Sp + 28];
      P32[Sp - 16] = P32[Sp + 32];
      P32[Sp - 12] = P32[Sp + 36];
      P32[Sp - 8] = R1;
      P32[Sp - 4] = P32[Sp + 40];
      Sp = Sp - 20;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
  cKX:
      Hp = Hp + 12;
      if (Hp > HpLim) goto cLI; else goto cLH;
  cLI:
      HpAlloc = 12;
      goto cLG;
  cLG:
      call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
  cLH:
      I32[Hp - 8] = sat_sHX_info;
      P32[Hp] = P32[Sp + 36];
      I32[Sp] = cLF;
      P32[Sp - 16] = P32[Sp + 32];
      I32[Sp - 12] = stg_ap_pp_info;
      P32[Sp - 8] = P32[Sp + 44];
      P32[Sp - 4] = Hp - 8;
      P32[Sp + 40] = R1;
      Sp = Sp - 16;
      call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
  cLF:
      _sHU::P32 = P32[Sp + 40];
      if (R1 & 3 >= 2) goto cLS; else goto cLO;
  cLS:
      R1 = _sHU::P32 & (-4);
      Sp = Sp + 48;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cLO:
      P32[Sp + 24] = P32[Sp + 28];
      P32[Sp + 28] = P32[Sp + 32];
      P32[Sp + 32] = P32[Sp + 36];
      P32[Sp + 36] = P32[Sp + 4];
      P32[Sp + 40] = P32[Sp + 44];
      P32[Sp + 44] = _sHU::P32;
      Sp = Sp + 24;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cLv:
      Hp = Hp + 28;
      if (Hp > HpLim) goto cM4; else goto cLx;
  cM4:
      HpAlloc = 28;
      goto cM2;
  cM2:
      call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
  cLx:
      I32[Hp - 24] = :_con_info;
      P32[Hp - 20] = P32[Sp + 44];
      P32[Hp - 16] = P32[Sp + 12];
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = P32[Sp + 4];
      P32[Hp - 4] = _sHP::P32;
      P32[Hp] = Hp - 22;
      R1 = Hp - 10;
      Sp = Sp + 48;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cLo:
      R1 = P32[Sp + 28] & (-4);
      Sp = Sp + 32;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  cL9:
      R1 = _sHH::P32 & (-4);
      Sp = Sp + 24;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cKp,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cKr,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cKs,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cKx,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cKy,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cKD,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cKP,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, sat_sHX_closure}),
 (cKT,
  {T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, sat_sHX_closure}),
 (cKX,
  {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure,
   sat_sHX_closure}),
 (cL9, {}),
 (cLa,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLf,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLg, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cLh,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLo, {}),
 (cLq,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLv,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLx, {}),
 (cLz,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLB,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLC,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cLF, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cLG,
  {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure,
   sat_sHX_closure}),
 (cLH,
  {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure,
   sat_sHX_closure}),
 (cLI,
  {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure,
   sat_sHX_closure}),
 (cLO, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cLS, {}),
 (cM1,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cM2,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cM3, {}),
 (cM4,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure}),
 (cMa,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure, ds1_sHT_closure,
   sat_sHX_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_$cunion_entry() //  []
        { info_tbl: [(cKr,
                      label: block_cKr_info
                      rep:StackRep [False, False, False, False, True]),
                     (cKx,
                      label: block_cKx_info
                      rep:StackRep [False, False, False, False, False, False, False]),
                     (cKD,
                      label: block_cKD_info
                      rep:StackRep [False, False, False, False, False, False, False,
                                    False, False, False, False]),
                     (cKP,
                      label: block_cKP_info
                      rep:StackRep [False, True, False, True, True, True, False, False,
                                    False, True, False]),
                     (cKT,
                      label: block_cKT_info
                      rep:StackRep [False, True, True, True, True, True, False, False,
                                    False, False, False]),
                     (cKX,
                      label: block_cKX_info
                      rep:StackRep [False, True, True, True, True, True, False, False,
                                    False, True, False]),
                     (cLf,
                      label: T2902_B_PairingSum.$fSumPSumab_$cunion_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 23} }),
                     (cLF,
                      label: block_cLF_info
                      rep:StackRep [False, True, True, True, True, True, False, False,
                                    False, False, False])]
          stack_info: arg_space: 24 updfr_space: Just 4
        }
    {offset
      cLf:
          goto cKp;
      cKp:
          if ((Sp + -48) < SpLim) goto cLg; else goto cLh;
      cLg:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
      cLh:
          I32[Sp - 4] = cKr;
          _sHI::P32 = P32[Sp + 16];
          R1 = _sHI::P32;
          Sp = Sp - 4;
          if (_sHI::P32 & 3 != 0) goto cKr; else goto cKs;
      cKs:
          call (I32[_sHI::P32])(R1) returns to cKr, args: 4, res: 4, upd: 4;
      cKr:
          _sHH::P32 = P32[Sp + 16];
          if (R1 & 3 >= 2) goto cLa; else goto cL9;
      cLa:
          I32[Sp - 8] = cKx;
          _sHJ::P32 = R1;
          _sHK::P32 = P32[R1 + 2];
          _sHL::P32 = P32[R1 + 6];
          _sHM::P32 = P32[R1 + 10];
          R1 = _sHH::P32;
          P32[Sp - 4] = _sHM::P32;
          P32[Sp] = _sHL::P32;
          P32[Sp + 16] = _sHK::P32;
          P32[Sp + 20] = _sHJ::P32;
          Sp = Sp - 8;
          if (_sHH::P32 & 3 != 0) goto cKx; else goto cKy;
      cKy:
          call (I32[_sHH::P32])(R1) returns to cKx, args: 4, res: 4, upd: 4;
      cKx:
          if (R1 & 3 >= 2) goto cLq; else goto cLo;
      cLq:
          I32[Sp - 16] = cKD;
          P32[Sp - 32] = P32[Sp + 12];
          I32[Sp - 28] = stg_ap_pp_info;
          _sHO::P32 = P32[R1 + 2];
          P32[Sp - 24] = _sHO::P32;
          P32[Sp - 20] = P32[Sp + 24];
          P32[Sp - 12] = _sHO::P32;
          P32[Sp - 8] = P32[R1 + 6];
          P32[Sp - 4] = P32[R1 + 10];
          P32[Sp] = R1;
          Sp = Sp - 32;
          call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
      cKD:
          _sHP::P32 = P32[Sp + 8];
          _cM5::P32 = R1 & 3;
          if (_cM5::P32 >= 2) goto cMa; else goto cLv;
      cMa:
          _sHL::P32 = P32[Sp + 24];
          _sHM::P32 = P32[Sp + 20];
          if (_cM5::P32 >= 3) goto cM1; else goto cLz;
      cM1:
          Hp = Hp + 28;
          if (Hp > HpLim) goto cM4; else goto cM3;
      cM3:
          I32[Hp - 24] = :_con_info;
          P32[Hp - 20] = P32[Sp + 16];
          P32[Hp - 16] = _sHM::P32;
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp + 40];
          P32[Hp - 4] = _sHL::P32;
          P32[Hp] = Hp - 22;
          R1 = Hp - 10;
          Sp = Sp + 48;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cLz:
          Hp = Hp + 20;
          if (Hp > HpLim) goto cLC; else goto cLB;
      cLC:
          HpAlloc = 20;
          goto cM2;
      cLB:
          I32[Hp - 16] = ds1_sHT_info;
          _sHG::P32 = P32[Sp + 36];
          P32[Hp - 8] = _sHG::P32;
          P32[Hp - 4] = _sHL::P32;
          P32[Hp] = _sHP::P32;
          I32[Sp] = cKP;
          P32[Sp - 16] = P32[Sp + 28];
          P32[Sp - 12] = P32[Sp + 32];
          P32[Sp - 8] = _sHG::P32;
          P32[Sp - 4] = _sHM::P32;
          P32[Sp + 44] = Hp - 16;
          Sp = Sp - 16;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
      cKP:
          I32[Sp] = cKT;
          P32[Sp - 16] = P32[Sp + 28];
          P32[Sp - 12] = P32[Sp + 32];
          P32[Sp - 8] = P32[Sp + 36];
          P32[Sp - 4] = P32[Sp + 12];
          P32[Sp + 40] = R1;
          Sp = Sp - 16;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
      cKT:
          I32[Sp] = cKX;
          P32[Sp - 20] = P32[Sp + 28];
          P32[Sp - 16] = P32[Sp + 32];
          P32[Sp - 12] = P32[Sp + 36];
          P32[Sp - 8] = R1;
          P32[Sp - 4] = P32[Sp + 40];
          Sp = Sp - 20;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
      cKX:
          Hp = Hp + 12;
          if (Hp > HpLim) goto cLI; else goto cLH;
      cLI:
          HpAlloc = 12;
          goto cLG;
      cLG:
          call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
      cLH:
          I32[Hp - 8] = sat_sHX_info;
          P32[Hp] = P32[Sp + 36];
          I32[Sp] = cLF;
          P32[Sp - 16] = P32[Sp + 32];
          I32[Sp - 12] = stg_ap_pp_info;
          P32[Sp - 8] = P32[Sp + 44];
          P32[Sp - 4] = Hp - 8;
          P32[Sp + 40] = R1;
          Sp = Sp - 16;
          call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
      cLF:
          _sHU::P32 = P32[Sp + 40];
          if (R1 & 3 >= 2) goto cLS; else goto cLO;
      cLS:
          R1 = _sHU::P32 & (-4);
          Sp = Sp + 48;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
      cLO:
          P32[Sp + 24] = P32[Sp + 28];
          P32[Sp + 28] = P32[Sp + 32];
          P32[Sp + 32] = P32[Sp + 36];
          P32[Sp + 36] = P32[Sp + 4];
          P32[Sp + 40] = P32[Sp + 44];
          P32[Sp + 44] = _sHU::P32;
          Sp = Sp + 24;
          call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
      cLv:
          Hp = Hp + 28;
          if (Hp > HpLim) goto cM4; else goto cLx;
      cM4:
          HpAlloc = 28;
          goto cM2;
      cM2:
          call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
      cLx:
          I32[Hp - 24] = :_con_info;
          P32[Hp - 20] = P32[Sp + 44];
          P32[Hp - 16] = P32[Sp + 12];
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp + 4];
          P32[Hp - 4] = _sHP::P32;
          P32[Hp] = Hp - 22;
          R1 = Hp - 10;
          Sp = Sp + 48;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cLo:
          R1 = P32[Sp + 28] & (-4);
          Sp = Sp + 32;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
      cL9:
          R1 = _sHH::P32 & (-4);
          Sp = Sp + 24;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_$cunion_entry() //  []
        { info_tbl: [(cKp,
                      label: T2902_B_PairingSum.$fSumPSumab_$cunion_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 23} }),
                     (cKr,
                      label: block_cKr_info
                      rep:StackRep [False, False, False, False, True]),
                     (cKx,
                      label: block_cKx_info
                      rep:StackRep [False, False, False, False, False, False, False]),
                     (cKD,
                      label: block_cKD_info
                      rep:StackRep [False, False, False, False, False, False, False,
                                    False, False, False, False]),
                     (cKP,
                      label: block_cKP_info
                      rep:StackRep [False, True, False, True, True, True, False, False,
                                    False, True, False]),
                     (cKT,
                      label: block_cKT_info
                      rep:StackRep [False, True, True, True, True, True, False, False,
                                    False, False, False]),
                     (cKX,
                      label: block_cKX_info
                      rep:StackRep [False, True, True, True, True, True, False, False,
                                    False, True, False]),
                     (cLF,
                      label: block_cLF_info
                      rep:StackRep [False, True, True, True, True, True, False, False,
                                    False, False, False])]
          stack_info: arg_space: 24 updfr_space: Just 4
        }
    {offset
      cKp:
          if ((Sp + -48) < SpLim) goto cLg; else goto cLh;
      cLg:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
      cLh:
          I32[Sp - 4] = cKr;
          _sHI::P32 = P32[Sp + 16];
          R1 = _sHI::P32;
          Sp = Sp - 4;
          if (_sHI::P32 & 3 != 0) goto cKr; else goto cKs;
      cKs:
          call (I32[_sHI::P32])(R1) returns to cKr, args: 4, res: 4, upd: 4;
      cKr:
          _sHH::P32 = P32[Sp + 16];
          if (R1 & 3 >= 2) goto cLa; else goto cL9;
      cLa:
          I32[Sp - 8] = cKx;
          _sHJ::P32 = R1;
          _sHK::P32 = P32[R1 + 2];
          _sHL::P32 = P32[R1 + 6];
          _sHM::P32 = P32[R1 + 10];
          R1 = _sHH::P32;
          P32[Sp - 4] = _sHM::P32;
          P32[Sp] = _sHL::P32;
          P32[Sp + 16] = _sHK::P32;
          P32[Sp + 20] = _sHJ::P32;
          Sp = Sp - 8;
          if (_sHH::P32 & 3 != 0) goto cKx; else goto cKy;
      cKy:
          call (I32[_sHH::P32])(R1) returns to cKx, args: 4, res: 4, upd: 4;
      cKx:
          if (R1 & 3 >= 2) goto cLq; else goto cLo;
      cLq:
          I32[Sp - 16] = cKD;
          P32[Sp - 32] = P32[Sp + 12];
          I32[Sp - 28] = stg_ap_pp_info;
          _sHO::P32 = P32[R1 + 2];
          P32[Sp - 24] = _sHO::P32;
          P32[Sp - 20] = P32[Sp + 24];
          P32[Sp - 12] = _sHO::P32;
          P32[Sp - 8] = P32[R1 + 6];
          P32[Sp - 4] = P32[R1 + 10];
          P32[Sp] = R1;
          Sp = Sp - 32;
          call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
      cKD:
          _sHP::P32 = P32[Sp + 8];
          _cM5::P32 = R1 & 3;
          if (_cM5::P32 >= 2) goto cMa; else goto cLv;
      cMa:
          _sHL::P32 = P32[Sp + 24];
          _sHM::P32 = P32[Sp + 20];
          if (_cM5::P32 >= 3) goto cM1; else goto cLz;
      cM1:
          Hp = Hp + 28;
          if (Hp > HpLim) goto cM4; else goto cM3;
      cM3:
          I32[Hp - 24] = :_con_info;
          P32[Hp - 20] = P32[Sp + 16];
          P32[Hp - 16] = _sHM::P32;
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp + 40];
          P32[Hp - 4] = _sHL::P32;
          P32[Hp] = Hp - 22;
          R1 = Hp - 10;
          Sp = Sp + 48;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cLz:
          Hp = Hp + 20;
          if (Hp > HpLim) goto cLC; else goto cLB;
      cLC:
          HpAlloc = 20;
          goto cM2;
      cLB:
          I32[Hp - 16] = ds1_sHT_info;
          _sHG::P32 = P32[Sp + 36];
          P32[Hp - 8] = _sHG::P32;
          P32[Hp - 4] = _sHL::P32;
          P32[Hp] = _sHP::P32;
          I32[Sp] = cKP;
          P32[Sp - 16] = P32[Sp + 28];
          P32[Sp - 12] = P32[Sp + 32];
          P32[Sp - 8] = _sHG::P32;
          P32[Sp - 4] = _sHM::P32;
          P32[Sp + 44] = Hp - 16;
          Sp = Sp - 16;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
      cKP:
          I32[Sp] = cKT;
          P32[Sp - 16] = P32[Sp + 28];
          P32[Sp - 12] = P32[Sp + 32];
          P32[Sp - 8] = P32[Sp + 36];
          P32[Sp - 4] = P32[Sp + 12];
          P32[Sp + 40] = R1;
          Sp = Sp - 16;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
      cKT:
          I32[Sp] = cKX;
          P32[Sp - 20] = P32[Sp + 28];
          P32[Sp - 16] = P32[Sp + 32];
          P32[Sp - 12] = P32[Sp + 36];
          P32[Sp - 8] = R1;
          P32[Sp - 4] = P32[Sp + 40];
          Sp = Sp - 20;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
      cKX:
          Hp = Hp + 12;
          if (Hp > HpLim) goto cLI; else goto cLH;
      cLI:
          HpAlloc = 12;
          goto cLG;
      cLG:
          call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
      cLH:
          I32[Hp - 8] = sat_sHX_info;
          P32[Hp] = P32[Sp + 36];
          I32[Sp] = cLF;
          P32[Sp - 16] = P32[Sp + 32];
          I32[Sp - 12] = stg_ap_pp_info;
          P32[Sp - 8] = P32[Sp + 44];
          P32[Sp - 4] = Hp - 8;
          P32[Sp + 40] = R1;
          Sp = Sp - 16;
          call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
      cLF:
          _sHU::P32 = P32[Sp + 40];
          if (R1 & 3 >= 2) goto cLS; else goto cLO;
      cLS:
          R1 = _sHU::P32 & (-4);
          Sp = Sp + 48;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
      cLO:
          P32[Sp + 24] = P32[Sp + 28];
          P32[Sp + 28] = P32[Sp + 32];
          P32[Sp + 32] = P32[Sp + 36];
          P32[Sp + 36] = P32[Sp + 4];
          P32[Sp + 40] = P32[Sp + 44];
          P32[Sp + 44] = _sHU::P32;
          Sp = Sp + 24;
          call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
      cLv:
          Hp = Hp + 28;
          if (Hp > HpLim) goto cM4; else goto cLx;
      cM4:
          HpAlloc = 28;
          goto cM2;
      cM2:
          call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
      cLx:
          I32[Hp - 24] = :_con_info;
          P32[Hp - 20] = P32[Sp + 44];
          P32[Hp - 16] = P32[Sp + 12];
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp + 4];
          P32[Hp - 4] = _sHP::P32;
          P32[Hp] = Hp - 22;
          R1 = Hp - 10;
          Sp = Sp + 48;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cLo:
          R1 = P32[Sp + 28] & (-4);
          Sp = Sp + 32;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
      cL9:
          R1 = _sHH::P32 & (-4);
          Sp = Sp + 24;
          call (I32[R1])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cMk:
      _sI0::P32 = P32[(old + 28)];
      _sI1::P32 = P32[(old + 24)];
      _sI2::P32 = P32[(old + 20)];
      _sI3::P32 = P32[(old + 16)];
      _sI4::P32 = P32[(old + 12)];
      _sI5::P32 = P32[(old + 8)];
      goto cMh;
  cMh:
      if (Sp - <highSp> < SpLim) goto cMl; else goto cMm;
  cMm:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cMo; else goto cMn;
  cMo:
      HpAlloc = 16;
      goto cMl;
  cMl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
      P32[(old + 28)] = _sI0::P32;
      P32[(old + 24)] = _sI1::P32;
      P32[(old + 20)] = _sI2::P32;
      P32[(old + 16)] = _sI3::P32;
      P32[(old + 12)] = _sI4::P32;
      P32[(old + 8)] = _sI5::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  cMn:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sI3::P32;
      P32[Hp - 4] = _sI4::P32;
      P32[Hp] = GHC.Types.[]_closure+1;
      _cMj::P32 = Hp - 10;
      P32[(old + 24)] = _sI0::P32;
      P32[(old + 20)] = _sI1::P32;
      P32[(old + 16)] = _sI2::P32;
      P32[(old + 12)] = _cMj::P32;
      P32[(old + 8)] = _sI5::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cMk:
      _sI0::P32 = P32[(old + 28)];
      _sI1::P32 = P32[(old + 24)];
      _sI2::P32 = P32[(old + 20)];
      _sI3::P32 = P32[(old + 16)];
      _sI4::P32 = P32[(old + 12)];
      _sI5::P32 = P32[(old + 8)];
      goto cMh;
  cMh:
      if (Sp - <highSp> < SpLim) goto cMl; else goto cMm;
  cMm:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cMo; else goto cMn;
  cMo:
      HpAlloc = 16;
      goto cMl;
  cMl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
      P32[(old + 28)] = _sI0::P32;
      P32[(old + 24)] = _sI1::P32;
      P32[(old + 20)] = _sI2::P32;
      P32[(old + 16)] = _sI3::P32;
      P32[(old + 12)] = _sI4::P32;
      P32[(old + 8)] = _sI5::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  cMn:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sI3::P32;
      P32[Hp - 4] = _sI4::P32;
      P32[Hp] = GHC.Types.[]_closure+1;
      _cMj::P32 = Hp - 10;
      P32[(old + 24)] = _sI0::P32;
      P32[(old + 20)] = _sI1::P32;
      P32[(old + 16)] = _sI2::P32;
      P32[(old + 12)] = _cMj::P32;
      P32[(old + 8)] = _sI5::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cMk:
      _sI0::P32 = P32[(old + 28)];
      _sI1::P32 = P32[(old + 24)];
      _sI2::P32 = P32[(old + 20)];
      _sI3::P32 = P32[(old + 16)];
      _sI4::P32 = P32[(old + 12)];
      _sI5::P32 = P32[(old + 8)];
      goto cMh;
  cMh:
      if (Sp - <highSp> < SpLim) goto cMl; else goto cMm;
  cMm:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cMo; else goto cMn;
  cMo:
      HpAlloc = 16;
      goto cMl;
  cMl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
      P32[(old + 28)] = _sI0::P32;
      P32[(old + 24)] = _sI1::P32;
      P32[(old + 20)] = _sI2::P32;
      P32[(old + 16)] = _sI3::P32;
      P32[(old + 12)] = _sI4::P32;
      P32[(old + 8)] = _sI5::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  cMn:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sI3::P32;
      P32[Hp - 4] = _sI4::P32;
      P32[Hp] = GHC.Types.[]_closure+1;
      _cMj::P32 = Hp - 10;
      P32[(old + 24)] = _sI0::P32;
      P32[(old + 20)] = _sI1::P32;
      P32[(old + 16)] = _sI2::P32;
      P32[(old + 12)] = _cMj::P32;
      P32[(old + 8)] = _sI5::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cMk:
      _sI0::P32 = P32[(old + 28)];
      _sI1::P32 = P32[(old + 24)];
      _sI2::P32 = P32[(old + 20)];
      _sI3::P32 = P32[(old + 16)];
      _sI4::P32 = P32[(old + 12)];
      _sI5::P32 = P32[(old + 8)];
      goto cMh;
  cMh:
      if (Sp - <highSp> < SpLim) goto cMl; else goto cMm;
  cMm:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cMo; else goto cMn;
  cMo:
      HpAlloc = 16;
      goto cMl;
  cMl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
      P32[(old + 28)] = _sI0::P32;
      P32[(old + 24)] = _sI1::P32;
      P32[(old + 20)] = _sI2::P32;
      P32[(old + 16)] = _sI3::P32;
      P32[(old + 12)] = _sI4::P32;
      P32[(old + 8)] = _sI5::P32;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  cMn:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sI3::P32;
      P32[Hp - 4] = _sI4::P32;
      P32[Hp] = GHC.Types.[]_closure+1;
      _cMj::P32 = Hp - 10;
      P32[(old + 24)] = _sI0::P32;
      P32[(old + 20)] = _sI1::P32;
      P32[(old + 16)] = _sI2::P32;
      P32[(old + 12)] = _cMj::P32;
      P32[(old + 8)] = _sI5::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cMk:
      _sI0::P32 = P32[Sp];
      _sI1::P32 = P32[Sp + 4];
      _sI2::P32 = P32[Sp + 8];
      _sI3::P32 = P32[Sp + 12];
      _sI4::P32 = P32[Sp + 16];
      _sI5::P32 = P32[Sp + 20];
      goto cMh;
  cMh:
      goto cMm;
  cMm:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cMo; else goto cMn;
  cMo:
      HpAlloc = 16;
      goto cMl;
  cMl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  cMn:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _sI3::P32;
      P32[Hp - 4] = _sI4::P32;
      P32[Hp] = GHC.Types.[]_closure+1;
      _cMj::P32 = Hp - 10;
      P32[Sp + 4] = _sI0::P32;
      P32[Sp + 8] = _sI1::P32;
      P32[Sp + 12] = _sI2::P32;
      P32[Sp + 16] = _cMj::P32;
      Sp = Sp + 4;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cMk:
      goto cMh;
  cMh:
      goto cMm;
  cMm:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cMo; else goto cMn;
  cMo:
      HpAlloc = 16;
      goto cMl;
  cMl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
      call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
  cMn:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = P32[Sp + 12];
      P32[Hp - 4] = P32[Sp + 16];
      P32[Hp] = GHC.Types.[]_closure+1;
      _sI1::P32 = P32[Sp + 4];
      P32[Sp + 4] = P32[Sp];
      _sI2::P32 = P32[Sp + 8];
      P32[Sp + 8] = _sI1::P32;
      P32[Sp + 12] = _sI2::P32;
      P32[Sp + 16] = Hp - 10;
      Sp = Sp + 4;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cMh,
  {T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cMk,
  {T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cMl, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cMm,
  {T2902_B_PairingSum.$fSumPSumab_$cunion_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cMn, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cMo, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_$cinsert_entry() //  []
        { info_tbl: [(cMk,
                      label: T2902_B_PairingSum.$fSumPSumab_$cinsert_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 28 updfr_space: Just 4
        }
    {offset
      cMk:
          goto cMh;
      cMh:
          goto cMm;
      cMm:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cMo; else goto cMn;
      cMo:
          HpAlloc = 16;
          goto cMl;
      cMl:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
          call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
      cMn:
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp + 12];
          P32[Hp - 4] = P32[Sp + 16];
          P32[Hp] = GHC.Types.[]_closure+1;
          _sI1::P32 = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp];
          _sI2::P32 = P32[Sp + 8];
          P32[Sp + 8] = _sI1::P32;
          P32[Sp + 12] = _sI2::P32;
          P32[Sp + 16] = Hp - 10;
          Sp = Sp + 4;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_$cinsert_entry() //  []
        { info_tbl: [(cMm,
                      label: T2902_B_PairingSum.$fSumPSumab_$cinsert_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 28 updfr_space: Just 4
        }
    {offset
      cMm:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cMo; else goto cMn;
      cMo:
          HpAlloc = 16;
          goto cMl;
      cMl:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
          call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
      cMn:
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp + 12];
          P32[Hp - 4] = P32[Sp + 16];
          P32[Hp] = GHC.Types.[]_closure+1;
          _sI1::P32 = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp];
          _sI2::P32 = P32[Sp + 8];
          P32[Sp + 8] = _sI1::P32;
          P32[Sp + 12] = _sI2::P32;
          P32[Sp + 16] = Hp - 10;
          Sp = Sp + 4;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cunions_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cunions_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cunions_entry() //  []
         { info_tbl: [(cJD,
                       label: T2902_B_PairingSum.$fSumPSumab_$cunions_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cJF,
                       label: block_cJF_info
                       rep:StackRep [False, False, False, True]),
                      (cJX,
                       label: block_cJX_info
                       rep:StackRep [False, False, False, False]),
                      (cK8,
                       label: block_cK8_info
                       rep:StackRep [False, False, False, False, False]),
                      (cKc,
                       label: block_cKc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cJD:
           if ((Sp + -24) < SpLim) goto cJQ; else goto cJR;
       cJQ:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cJR:
           I32[Sp - 4] = cJF;
           _sHv::P32 = P32[Sp + 12];
           R1 = _sHv::P32;
           Sp = Sp - 4;
           if (_sHv::P32 & 3 != 0) goto cJF; else goto cJG;
       cJG:
           call (I32[_sHv::P32])(R1) returns to cJF, args: 4, res: 4, upd: 4;
       cJF:
           if (R1 & 3 >= 2) goto cJK; else goto cJJ;
       cJK:
           I32[Sp] = cJX;
           _sHx::P32 = P32[R1 + 2];
           _sHy::P32 = P32[R1 + 6];
           R1 = _sHy::P32;
           P32[Sp + 16] = _sHx::P32;
           if (_sHy::P32 & 3 != 0) goto cJX; else goto cJZ;
       cJZ:
           call (I32[_sHy::P32])(R1) returns to cJX, args: 4, res: 4, upd: 4;
       cJX:
           if (R1 & 3 >= 2) goto cKe; else goto cK5;
       cKe:
           I32[Sp - 4] = cK8;
           P32[Sp - 20] = P32[Sp + 4];
           P32[Sp - 16] = P32[Sp + 8];
           P32[Sp - 12] = P32[Sp + 12];
           P32[Sp - 8] = P32[R1 + 6];
           P32[Sp] = P32[R1 + 2];
           Sp = Sp - 20;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
       cK8:
           _sHA::P32 = P32[Sp + 4];
           I32[Sp + 4] = cKc;
           P32[Sp - 16] = P32[Sp + 8];
           P32[Sp - 12] = P32[Sp + 12];
           P32[Sp - 8] = P32[Sp + 16];
           P32[Sp - 4] = P32[Sp + 20];
           P32[Sp] = _sHA::P32;
           P32[Sp + 20] = R1;
           Sp = Sp - 16;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
       cKc:
           P32[Sp] = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp + 8];
           P32[Sp + 8] = P32[Sp + 12];
           P32[Sp + 12] = R1;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
       cK5:
           R1 = P32[Sp + 16] & (-4);
           Sp = Sp + 20;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cJJ:
           R1 = T2902_B_PairingSum.Empty_closure+1;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 },
 section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cunion_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cunion_info;
         const 0;
 },
 ds1_sHT_entry() //  [R1]
         { info_tbl: [(cKK,
                       label: ds1_sHT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cKK:
           if ((Sp + -24) < SpLim) goto cKN; else goto cKO;
       cKN:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cKO:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           P32[Sp - 24] = P32[R1 + 8];
           I32[Sp - 20] = stg_ap_pp_info;
           P32[Sp - 16] = P32[R1 + 16];
           P32[Sp - 12] = P32[R1 + 12];
           Sp = Sp - 24;
           call GHC.Num.+_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_sHX_entry() //  [R1]
         { info_tbl: [(cL3,
                       label: sat_sHX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cL3:
           if ((Sp + -20) < SpLim) goto cL6; else goto cL7;
       cL6:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cL7:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           P32[Sp - 20] = P32[R1 + 8];
           I32[Sp - 16] = stg_ap_p_info;
           P32[Sp - 12] = lvl_rHo_closure+1;
           Sp = Sp - 20;
           call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$cunion_entry() //  []
         { info_tbl: [(cKp,
                       label: T2902_B_PairingSum.$fSumPSumab_$cunion_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 23} }),
                      (cKr,
                       label: block_cKr_info
                       rep:StackRep [False, False, False, False, True]),
                      (cKx,
                       label: block_cKx_info
                       rep:StackRep [False, False, False, False, False, False, False]),
                      (cKD,
                       label: block_cKD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False]),
                      (cKP,
                       label: block_cKP_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     False, True, False]),
                      (cKT,
                       label: block_cKT_info
                       rep:StackRep [False, True, True, True, True, True, False, False,
                                     False, False, False]),
                      (cKX,
                       label: block_cKX_info
                       rep:StackRep [False, True, True, True, True, True, False, False,
                                     False, True, False]),
                      (cLF,
                       label: block_cLF_info
                       rep:StackRep [False, True, True, True, True, True, False, False,
                                     False, False, False])]
           stack_info: arg_space: 24 updfr_space: Just 4
         }
     {offset
       cKp:
           if ((Sp + -48) < SpLim) goto cLg; else goto cLh;
       cLg:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
       cLh:
           I32[Sp - 4] = cKr;
           _sHI::P32 = P32[Sp + 16];
           R1 = _sHI::P32;
           Sp = Sp - 4;
           if (_sHI::P32 & 3 != 0) goto cKr; else goto cKs;
       cKs:
           call (I32[_sHI::P32])(R1) returns to cKr, args: 4, res: 4, upd: 4;
       cKr:
           _sHH::P32 = P32[Sp + 16];
           if (R1 & 3 >= 2) goto cLa; else goto cL9;
       cLa:
           I32[Sp - 8] = cKx;
           _sHJ::P32 = R1;
           _sHK::P32 = P32[R1 + 2];
           _sHL::P32 = P32[R1 + 6];
           _sHM::P32 = P32[R1 + 10];
           R1 = _sHH::P32;
           P32[Sp - 4] = _sHM::P32;
           P32[Sp] = _sHL::P32;
           P32[Sp + 16] = _sHK::P32;
           P32[Sp + 20] = _sHJ::P32;
           Sp = Sp - 8;
           if (_sHH::P32 & 3 != 0) goto cKx; else goto cKy;
       cKy:
           call (I32[_sHH::P32])(R1) returns to cKx, args: 4, res: 4, upd: 4;
       cKx:
           if (R1 & 3 >= 2) goto cLq; else goto cLo;
       cLq:
           I32[Sp - 16] = cKD;
           P32[Sp - 32] = P32[Sp + 12];
           I32[Sp - 28] = stg_ap_pp_info;
           _sHO::P32 = P32[R1 + 2];
           P32[Sp - 24] = _sHO::P32;
           P32[Sp - 20] = P32[Sp + 24];
           P32[Sp - 12] = _sHO::P32;
           P32[Sp - 8] = P32[R1 + 6];
           P32[Sp - 4] = P32[R1 + 10];
           P32[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
       cKD:
           _sHP::P32 = P32[Sp + 8];
           _cM5::P32 = R1 & 3;
           if (_cM5::P32 >= 2) goto cMa; else goto cLv;
       cMa:
           _sHL::P32 = P32[Sp + 24];
           _sHM::P32 = P32[Sp + 20];
           if (_cM5::P32 >= 3) goto cM1; else goto cLz;
       cM1:
           Hp = Hp + 28;
           if (Hp > HpLim) goto cM4; else goto cM3;
       cM3:
           I32[Hp - 24] = :_con_info;
           P32[Hp - 20] = P32[Sp + 16];
           P32[Hp - 16] = _sHM::P32;
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp + 40];
           P32[Hp - 4] = _sHL::P32;
           P32[Hp] = Hp - 22;
           R1 = Hp - 10;
           Sp = Sp + 48;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cLz:
           Hp = Hp + 20;
           if (Hp > HpLim) goto cLC; else goto cLB;
       cLC:
           HpAlloc = 20;
           goto cM2;
       cLB:
           I32[Hp - 16] = ds1_sHT_info;
           _sHG::P32 = P32[Sp + 36];
           P32[Hp - 8] = _sHG::P32;
           P32[Hp - 4] = _sHL::P32;
           P32[Hp] = _sHP::P32;
           I32[Sp] = cKP;
           P32[Sp - 16] = P32[Sp + 28];
           P32[Sp - 12] = P32[Sp + 32];
           P32[Sp - 8] = _sHG::P32;
           P32[Sp - 4] = _sHM::P32;
           P32[Sp + 44] = Hp - 16;
           Sp = Sp - 16;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
       cKP:
           I32[Sp] = cKT;
           P32[Sp - 16] = P32[Sp + 28];
           P32[Sp - 12] = P32[Sp + 32];
           P32[Sp - 8] = P32[Sp + 36];
           P32[Sp - 4] = P32[Sp + 12];
           P32[Sp + 40] = R1;
           Sp = Sp - 16;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
       cKT:
           I32[Sp] = cKX;
           P32[Sp - 20] = P32[Sp + 28];
           P32[Sp - 16] = P32[Sp + 32];
           P32[Sp - 12] = P32[Sp + 36];
           P32[Sp - 8] = R1;
           P32[Sp - 4] = P32[Sp + 40];
           Sp = Sp - 20;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
       cKX:
           Hp = Hp + 12;
           if (Hp > HpLim) goto cLI; else goto cLH;
       cLI:
           HpAlloc = 12;
           goto cLG;
       cLG:
           call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
       cLH:
           I32[Hp - 8] = sat_sHX_info;
           P32[Hp] = P32[Sp + 36];
           I32[Sp] = cLF;
           P32[Sp - 16] = P32[Sp + 32];
           I32[Sp - 12] = stg_ap_pp_info;
           P32[Sp - 8] = P32[Sp + 44];
           P32[Sp - 4] = Hp - 8;
           P32[Sp + 40] = R1;
           Sp = Sp - 16;
           call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
       cLF:
           _sHU::P32 = P32[Sp + 40];
           if (R1 & 3 >= 2) goto cLS; else goto cLO;
       cLS:
           R1 = _sHU::P32 & (-4);
           Sp = Sp + 48;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cLO:
           P32[Sp + 24] = P32[Sp + 28];
           P32[Sp + 28] = P32[Sp + 32];
           P32[Sp + 32] = P32[Sp + 36];
           P32[Sp + 36] = P32[Sp + 4];
           P32[Sp + 40] = P32[Sp + 44];
           P32[Sp + 44] = _sHU::P32;
           Sp = Sp + 24;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
       cLv:
           Hp = Hp + 28;
           if (Hp > HpLim) goto cM4; else goto cLx;
       cM4:
           HpAlloc = 28;
           goto cM2;
       cM2:
           call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
       cLx:
           I32[Hp - 24] = :_con_info;
           P32[Hp - 20] = P32[Sp + 44];
           P32[Hp - 16] = P32[Sp + 12];
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp + 4];
           P32[Hp - 4] = _sHP::P32;
           P32[Hp] = Hp - 22;
           R1 = Hp - 10;
           Sp = Sp + 48;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cLo:
           R1 = P32[Sp + 28] & (-4);
           Sp = Sp + 32;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cL9:
           R1 = _sHH::P32 & (-4);
           Sp = Sp + 24;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
     }
 },
 section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cinsert_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cinsert_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cinsert_entry() //  []
         { info_tbl: [(cMm,
                       label: T2902_B_PairingSum.$fSumPSumab_$cinsert_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 28 updfr_space: Just 4
         }
     {offset
       cMm:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cMo; else goto cMn;
       cMo:
           HpAlloc = 16;
           goto cMl;
       cMl:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
           call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
       cMn:
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp + 12];
           P32[Hp - 4] = P32[Sp + 16];
           P32[Hp] = GHC.Types.[]_closure+1;
           _sI1::P32 = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp];
           _sI2::P32 = P32[Sp + 8];
           P32[Sp + 8] = _sI1::P32;
           P32[Sp + 12] = _sI2::P32;
           P32[Sp + 16] = Hp - 10;
           Sp = Sp + 4;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cunions_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cunions_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cunions_entry() //  []
         { info_tbl: [(cJD,
                       label: T2902_B_PairingSum.$fSumPSumab_$cunions_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cJF,
                       label: block_cJF_info
                       rep:StackRep [False, False, False, True]),
                      (cJX,
                       label: block_cJX_info
                       rep:StackRep [False, False, False, False]),
                      (cK8,
                       label: block_cK8_info
                       rep:StackRep [False, False, False, False, False]),
                      (cKc,
                       label: block_cKc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cJD:
           if ((Sp + -24) < SpLim) goto cJQ; else goto cJR;
       cJQ:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cJR:
           I32[Sp - 4] = cJF;
           _sHv::P32 = P32[Sp + 12];
           R1 = _sHv::P32;
           Sp = Sp - 4;
           if (_sHv::P32 & 3 != 0) goto cJF; else goto cJG;
       cJG:
           call (I32[_sHv::P32])(R1) returns to cJF, args: 4, res: 4, upd: 4;
       cJF:
           if (R1 & 3 >= 2) goto cJK; else goto cJJ;
       cJK:
           I32[Sp] = cJX;
           _sHx::P32 = P32[R1 + 2];
           _sHy::P32 = P32[R1 + 6];
           R1 = _sHy::P32;
           P32[Sp + 16] = _sHx::P32;
           if (_sHy::P32 & 3 != 0) goto cJX; else goto cJZ;
       cJZ:
           call (I32[_sHy::P32])(R1) returns to cJX, args: 4, res: 4, upd: 4;
       cJX:
           if (R1 & 3 >= 2) goto cKe; else goto cK5;
       cKe:
           I32[Sp - 4] = cK8;
           P32[Sp - 20] = P32[Sp + 4];
           P32[Sp - 16] = P32[Sp + 8];
           P32[Sp - 12] = P32[Sp + 12];
           P32[Sp - 8] = P32[R1 + 6];
           P32[Sp] = P32[R1 + 2];
           Sp = Sp - 20;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cK8, args: 20, res: 4, upd: 4;
       cK8:
           _sHA::P32 = P32[Sp + 4];
           I32[Sp + 4] = cKc;
           P32[Sp - 16] = P32[Sp + 8];
           P32[Sp - 12] = P32[Sp + 12];
           P32[Sp - 8] = P32[Sp + 16];
           P32[Sp - 4] = P32[Sp + 20];
           P32[Sp] = _sHA::P32;
           P32[Sp + 20] = R1;
           Sp = Sp - 16;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKc, args: 24, res: 4, upd: 4;
       cKc:
           P32[Sp] = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp + 8];
           P32[Sp + 8] = P32[Sp + 12];
           P32[Sp + 12] = R1;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
       cK5:
           R1 = P32[Sp + 16] & (-4);
           Sp = Sp + 20;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cJJ:
           R1 = T2902_B_PairingSum.Empty_closure+1;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 },
 section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cunion_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cunion_info;
         const 0;
 },
 ds1_sHT_entry() //  [R1]
         { info_tbl: [(cKK,
                       label: ds1_sHT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cKK:
           if ((Sp + -24) < SpLim) goto cKN; else goto cKO;
       cKN:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cKO:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           P32[Sp - 24] = P32[R1 + 8];
           I32[Sp - 20] = stg_ap_pp_info;
           P32[Sp - 16] = P32[R1 + 16];
           P32[Sp - 12] = P32[R1 + 12];
           Sp = Sp - 24;
           call GHC.Num.+_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_sHX_entry() //  [R1]
         { info_tbl: [(cL3,
                       label: sat_sHX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cL3:
           if ((Sp + -20) < SpLim) goto cL6; else goto cL7;
       cL6:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cL7:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           P32[Sp - 20] = P32[R1 + 8];
           I32[Sp - 16] = stg_ap_p_info;
           P32[Sp - 12] = lvl_rHo_closure+1;
           Sp = Sp - 20;
           call GHC.Num.fromInteger_info() args: 24, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$cunion_entry() //  []
         { info_tbl: [(cKp,
                       label: T2902_B_PairingSum.$fSumPSumab_$cunion_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 23} }),
                      (cKr,
                       label: block_cKr_info
                       rep:StackRep [False, False, False, False, True]),
                      (cKx,
                       label: block_cKx_info
                       rep:StackRep [False, False, False, False, False, False, False]),
                      (cKD,
                       label: block_cKD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False]),
                      (cKP,
                       label: block_cKP_info
                       rep:StackRep [False, True, False, True, True, True, False, False,
                                     False, True, False]),
                      (cKT,
                       label: block_cKT_info
                       rep:StackRep [False, True, True, True, True, True, False, False,
                                     False, False, False]),
                      (cKX,
                       label: block_cKX_info
                       rep:StackRep [False, True, True, True, True, True, False, False,
                                     False, True, False]),
                      (cLF,
                       label: block_cLF_info
                       rep:StackRep [False, True, True, True, True, True, False, False,
                                     False, False, False])]
           stack_info: arg_space: 24 updfr_space: Just 4
         }
     {offset
       cKp:
           if ((Sp + -48) < SpLim) goto cLg; else goto cLh;
       cLg:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 4;
       cLh:
           I32[Sp - 4] = cKr;
           _sHI::P32 = P32[Sp + 16];
           R1 = _sHI::P32;
           Sp = Sp - 4;
           if (_sHI::P32 & 3 != 0) goto cKr; else goto cKs;
       cKs:
           call (I32[_sHI::P32])(R1) returns to cKr, args: 4, res: 4, upd: 4;
       cKr:
           _sHH::P32 = P32[Sp + 16];
           if (R1 & 3 >= 2) goto cLa; else goto cL9;
       cLa:
           I32[Sp - 8] = cKx;
           _sHJ::P32 = R1;
           _sHK::P32 = P32[R1 + 2];
           _sHL::P32 = P32[R1 + 6];
           _sHM::P32 = P32[R1 + 10];
           R1 = _sHH::P32;
           P32[Sp - 4] = _sHM::P32;
           P32[Sp] = _sHL::P32;
           P32[Sp + 16] = _sHK::P32;
           P32[Sp + 20] = _sHJ::P32;
           Sp = Sp - 8;
           if (_sHH::P32 & 3 != 0) goto cKx; else goto cKy;
       cKy:
           call (I32[_sHH::P32])(R1) returns to cKx, args: 4, res: 4, upd: 4;
       cKx:
           if (R1 & 3 >= 2) goto cLq; else goto cLo;
       cLq:
           I32[Sp - 16] = cKD;
           P32[Sp - 32] = P32[Sp + 12];
           I32[Sp - 28] = stg_ap_pp_info;
           _sHO::P32 = P32[R1 + 2];
           P32[Sp - 24] = _sHO::P32;
           P32[Sp - 20] = P32[Sp + 24];
           P32[Sp - 12] = _sHO::P32;
           P32[Sp - 8] = P32[R1 + 6];
           P32[Sp - 4] = P32[R1 + 10];
           P32[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_info() returns to cKD, args: 20, res: 4, upd: 4;
       cKD:
           _sHP::P32 = P32[Sp + 8];
           _cM5::P32 = R1 & 3;
           if (_cM5::P32 >= 2) goto cMa; else goto cLv;
       cMa:
           _sHL::P32 = P32[Sp + 24];
           _sHM::P32 = P32[Sp + 20];
           if (_cM5::P32 >= 3) goto cM1; else goto cLz;
       cM1:
           Hp = Hp + 28;
           if (Hp > HpLim) goto cM4; else goto cM3;
       cM3:
           I32[Hp - 24] = :_con_info;
           P32[Hp - 20] = P32[Sp + 16];
           P32[Hp - 16] = _sHM::P32;
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp + 40];
           P32[Hp - 4] = _sHL::P32;
           P32[Hp] = Hp - 22;
           R1 = Hp - 10;
           Sp = Sp + 48;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cLz:
           Hp = Hp + 20;
           if (Hp > HpLim) goto cLC; else goto cLB;
       cLC:
           HpAlloc = 20;
           goto cM2;
       cLB:
           I32[Hp - 16] = ds1_sHT_info;
           _sHG::P32 = P32[Sp + 36];
           P32[Hp - 8] = _sHG::P32;
           P32[Hp - 4] = _sHL::P32;
           P32[Hp] = _sHP::P32;
           I32[Sp] = cKP;
           P32[Sp - 16] = P32[Sp + 28];
           P32[Sp - 12] = P32[Sp + 32];
           P32[Sp - 8] = _sHG::P32;
           P32[Sp - 4] = _sHM::P32;
           P32[Sp + 44] = Hp - 16;
           Sp = Sp - 16;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKP, args: 20, res: 4, upd: 4;
       cKP:
           I32[Sp] = cKT;
           P32[Sp - 16] = P32[Sp + 28];
           P32[Sp - 12] = P32[Sp + 32];
           P32[Sp - 8] = P32[Sp + 36];
           P32[Sp - 4] = P32[Sp + 12];
           P32[Sp + 40] = R1;
           Sp = Sp - 16;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cKT, args: 20, res: 4, upd: 4;
       cKT:
           I32[Sp] = cKX;
           P32[Sp - 20] = P32[Sp + 28];
           P32[Sp - 16] = P32[Sp + 32];
           P32[Sp - 12] = P32[Sp + 36];
           P32[Sp - 8] = R1;
           P32[Sp - 4] = P32[Sp + 40];
           Sp = Sp - 20;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() returns to cKX, args: 24, res: 4, upd: 4;
       cKX:
           Hp = Hp + 12;
           if (Hp > HpLim) goto cLI; else goto cLH;
       cLI:
           HpAlloc = 12;
           goto cLG;
       cLG:
           call stg_gc_unpt_r1(R1) returns to cKX, args: 4, res: 4, upd: 4;
       cLH:
           I32[Hp - 8] = sat_sHX_info;
           P32[Hp] = P32[Sp + 36];
           I32[Sp] = cLF;
           P32[Sp - 16] = P32[Sp + 32];
           I32[Sp - 12] = stg_ap_pp_info;
           P32[Sp - 8] = P32[Sp + 44];
           P32[Sp - 4] = Hp - 8;
           P32[Sp + 40] = R1;
           Sp = Sp - 16;
           call GHC.Classes.==_info() returns to cLF, args: 20, res: 4, upd: 4;
       cLF:
           _sHU::P32 = P32[Sp + 40];
           if (R1 & 3 >= 2) goto cLS; else goto cLO;
       cLS:
           R1 = _sHU::P32 & (-4);
           Sp = Sp + 48;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cLO:
           P32[Sp + 24] = P32[Sp + 28];
           P32[Sp + 28] = P32[Sp + 32];
           P32[Sp + 32] = P32[Sp + 36];
           P32[Sp + 36] = P32[Sp + 4];
           P32[Sp + 40] = P32[Sp + 44];
           P32[Sp + 44] = _sHU::P32;
           Sp = Sp + 24;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
       cLv:
           Hp = Hp + 28;
           if (Hp > HpLim) goto cM4; else goto cLx;
       cM4:
           HpAlloc = 28;
           goto cM2;
       cM2:
           call stg_gc_unpt_r1(R1) returns to cKD, args: 4, res: 4, upd: 4;
       cLx:
           I32[Hp - 24] = :_con_info;
           P32[Hp - 20] = P32[Sp + 44];
           P32[Hp - 16] = P32[Sp + 12];
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp + 4];
           P32[Hp - 4] = _sHP::P32;
           P32[Hp] = Hp - 22;
           R1 = Hp - 10;
           Sp = Sp + 48;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cLo:
           R1 = P32[Sp + 28] & (-4);
           Sp = Sp + 32;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
       cL9:
           R1 = _sHH::P32 & (-4);
           Sp = Sp + 24;
           call (I32[R1])(R1) args: 4, res: 0, upd: 4;
     }
 },
 section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cinsert_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cinsert_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cinsert_entry() //  []
         { info_tbl: [(cMm,
                       label: T2902_B_PairingSum.$fSumPSumab_$cinsert_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 28 updfr_space: Just 4
         }
     {offset
       cMm:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cMo; else goto cMn;
       cMo:
           HpAlloc = 16;
           goto cMl;
       cMl:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
           call (stg_gc_fun)(R1) args: 28, res: 0, upd: 4;
       cMn:
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp + 12];
           P32[Hp - 4] = P32[Sp + 16];
           P32[Hp] = GHC.Types.[]_closure+1;
           _sI1::P32 = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp];
           _sI2::P32 = P32[Sp + 8];
           P32[Sp + 8] = _sI1::P32;
           P32[Sp + 12] = _sI2::P32;
           P32[Sp + 16] = Hp - 10;
           Sp = Sp + 4;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cextractMin_info;
         const 0;
 },
 sat_sIg_entry() //  [R1]
         { info_tbl: [(cO4,
                       label: sat_sIg_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cO4:
           _sIg::P32 = R1;
           goto cO2;
       cO2:
           if (Sp - <highSp> < SpLim) goto cO5; else goto cO6;
       cO5:
           R1 = _sIg::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cO6:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _sIg::P32;
           _sI7::P32 = P32[_sIg::P32 + 8];
           _sI8::P32 = P32[_sIg::P32 + 12];
           _sI9::P32 = P32[_sIg::P32 + 16];
           _sIe::P32 = P32[_sIg::P32 + 20];
           P32[(old + 28)] = _sI7::P32;
           P32[(old + 24)] = _sI8::P32;
           P32[(old + 20)] = _sI9::P32;
           P32[(old + 16)] = _sIe::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$cextractMin_entry() //  []
         { info_tbl: [(cOe,
                       label: T2902_B_PairingSum.$fSumPSumab_$cextractMin_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cOe:
           _sI7::P32 = P32[(old + 20)];
           _sI8::P32 = P32[(old + 16)];
           _sI9::P32 = P32[(old + 12)];
           _sIa::P32 = P32[(old + 8)];
           goto cNS;
       cNS:
           if (Sp - <highSp> < SpLim) goto cOf; else goto cOg;
       cOf:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
           P32[(old + 20)] = _sI7::P32;
           P32[(old + 16)] = _sI8::P32;
           P32[(old + 12)] = _sI9::P32;
           P32[(old + 8)] = _sIa::P32;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cOg:
           I32[(young<cNU> + 4)] = cNU;
           R1 = _sIa::P32;
           if (R1 & 3 != 0) goto cNU; else goto cNV;
       cNV:
           call (I32[R1])(R1) returns to cNU, args: 4, res: 4, upd: 4;
       cNU:
           _sIb::P32 = R1;
           _cOa::P32 = _sIb::P32 & 3;
           if (_cOa::P32 >= 2) goto cOc; else goto cOd;
       cOc:
           goto cO9;
       cO9:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cOn; else goto cOm;
       cOn:
           HpAlloc = 48;
           goto cOl;
       cOl:
           R1 = _sIb::P32;
           call stg_gc_unpt_r1(R1) returns to cNU, args: 4, res: 4, upd: 4;
       cOm:
           _sIc::P32 = P32[_sIb::P32 + 2];
           _sId::P32 = P32[_sIb::P32 + 6];
           _sIe::P32 = P32[_sIb::P32 + 10];
           I32[Hp - 44] = sat_sIg_info;
           P32[Hp - 36] = _sI7::P32;
           P32[Hp - 32] = _sI8::P32;
           P32[Hp - 28] = _sI9::P32;
           P32[Hp - 24] = _sIe::P32;
           _cO0::P32 = Hp - 44;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _sIc::P32;
           P32[Hp - 12] = _sId::P32;
           _cOj::P32 = Hp - 19;
           I32[Hp - 8] = (,)_con_info;
           P32[Hp - 4] = _cOj::P32;
           P32[Hp] = _cO0::P32;
           _cOk::P32 = Hp - 7;
           R1 = _cOk::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
       cOd:
           goto cO8;
       cO8:
           R1 = GHC.Err.undefined_closure;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cO4:
      _sIg::P32 = R1;
      goto cO2;
  cO2:
      if (Sp - <highSp> < SpLim) goto cO5; else goto cO6;
  cO5:
      R1 = _sIg::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cO6:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sIg::P32;
      _sI7::P32 = P32[_sIg::P32 + 8];
      _sI8::P32 = P32[_sIg::P32 + 12];
      _sI9::P32 = P32[_sIg::P32 + 16];
      _sIe::P32 = P32[_sIg::P32 + 20];
      P32[(old + 28)] = _sI7::P32;
      P32[(old + 24)] = _sI8::P32;
      P32[(old + 20)] = _sI9::P32;
      P32[(old + 16)] = _sIe::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  cO4:
      _sIg::P32 = R1;
      goto cO2;
  cO2:
      if (Sp - <highSp> < SpLim) goto cO5; else goto cO6;
  cO5:
      R1 = _sIg::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cO6:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sIg::P32;
      _sI7::P32 = P32[_sIg::P32 + 8];
      _sI8::P32 = P32[_sIg::P32 + 12];
      _sI9::P32 = P32[_sIg::P32 + 16];
      _sIe::P32 = P32[_sIg::P32 + 20];
      P32[(old + 28)] = _sI7::P32;
      P32[(old + 24)] = _sI8::P32;
      P32[(old + 20)] = _sI9::P32;
      P32[(old + 16)] = _sIe::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  cO4:
      _sIg::P32 = R1;
      goto cO2;
  cO2:
      if (Sp - <highSp> < SpLim) goto cO5; else goto cO6;
  cO5:
      R1 = _sIg::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cO6:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sIg::P32;
      _sI7::P32 = P32[_sIg::P32 + 8];
      _sI8::P32 = P32[_sIg::P32 + 12];
      _sI9::P32 = P32[_sIg::P32 + 16];
      _sIe::P32 = P32[_sIg::P32 + 20];
      P32[(old + 28)] = _sI7::P32;
      P32[(old + 24)] = _sI8::P32;
      P32[(old + 20)] = _sI9::P32;
      P32[(old + 16)] = _sIe::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  cO4:
      _sIg::P32 = R1;
      goto cO2;
  cO2:
      if (Sp - <highSp> < SpLim) goto cO5; else goto cO6;
  cO5:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cO6:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _sI7::P32 = P32[R1 + 8];
      _sI8::P32 = P32[R1 + 12];
      _sI9::P32 = P32[R1 + 16];
      _sIe::P32 = P32[R1 + 20];
      P32[(old + 28)] = _sI7::P32;
      P32[(old + 24)] = _sI8::P32;
      P32[(old + 20)] = _sI9::P32;
      P32[(old + 16)] = _sIe::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  cO4:
      _sIg::P32 = R1;
      goto cO2;
  cO2:
      if (Sp - 24 < SpLim) goto cO5; else goto cO6;
  cO5:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cO6:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _sI7::P32 = P32[R1 + 8];
      _sI8::P32 = P32[R1 + 12];
      _sI9::P32 = P32[R1 + 16];
      _sIe::P32 = P32[R1 + 20];
      P32[Sp - 24] = _sI7::P32;
      P32[Sp - 20] = _sI8::P32;
      P32[Sp - 16] = _sI9::P32;
      P32[Sp - 12] = _sIe::P32;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  cO4:
      goto cO2;
  cO2:
      if ((Sp + -24) < SpLim) goto cO5; else goto cO6;
  cO5:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cO6:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      P32[Sp - 24] = P32[R1 + 8];
      P32[Sp - 20] = P32[R1 + 12];
      P32[Sp - 16] = P32[R1 + 16];
      P32[Sp - 12] = P32[R1 + 20];
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(cO2, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cO4, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cO5, {}),
 (cO6, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure})]



==================== after setInfoTableStackMap ====================
sat_sIg_entry() //  [R1]
        { info_tbl: [(cO4,
                      label: sat_sIg_info
                      rep:HeapRep 4 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cO4:
          goto cO2;
      cO2:
          if ((Sp + -24) < SpLim) goto cO5; else goto cO6;
      cO5:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cO6:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          P32[Sp - 24] = P32[R1 + 8];
          P32[Sp - 20] = P32[R1 + 12];
          P32[Sp - 16] = P32[R1 + 16];
          P32[Sp - 12] = P32[R1 + 20];
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_sIg_entry() //  [R1]
        { info_tbl: [(cO2,
                      label: sat_sIg_info
                      rep:HeapRep 4 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cO2:
          if ((Sp + -24) < SpLim) goto cO5; else goto cO6;
      cO5:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cO6:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          P32[Sp - 24] = P32[R1 + 8];
          P32[Sp - 20] = P32[R1 + 12];
          P32[Sp - 16] = P32[R1 + 16];
          P32[Sp - 12] = P32[R1 + 20];
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cOe:
      _sI7::P32 = P32[(old + 20)];
      _sI8::P32 = P32[(old + 16)];
      _sI9::P32 = P32[(old + 12)];
      _sIa::P32 = P32[(old + 8)];
      goto cNS;
  cNS:
      if (Sp - <highSp> < SpLim) goto cOf; else goto cOg;
  cOf:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
      P32[(old + 20)] = _sI7::P32;
      P32[(old + 16)] = _sI8::P32;
      P32[(old + 12)] = _sI9::P32;
      P32[(old + 8)] = _sIa::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cOg:
      I32[(young<cNU> + 4)] = cNU;
      R1 = _sIa::P32;
      if (R1 & 3 != 0) goto cNU; else goto cNV;
  cNV:
      call (I32[R1])(R1) returns to cNU, args: 4, res: 4, upd: 4;
  cNU:
      _sIb::P32 = R1;
      _cOa::P32 = _sIb::P32 & 3;
      if (_cOa::P32 >= 2) goto cO9; else goto cO8;
  cO9:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cOn; else goto cOm;
  cOn:
      HpAlloc = 48;
      goto cOl;
  cOl:
      R1 = _sIb::P32;
      call stg_gc_unpt_r1(R1) returns to cNU, args: 4, res: 4, upd: 4;
  cOm:
      _sIc::P32 = P32[_sIb::P32 + 2];
      _sId::P32 = P32[_sIb::P32 + 6];
      _sIe::P32 = P32[_sIb::P32 + 10];
      I32[Hp - 44] = sat_sIg_info;
      P32[Hp - 36] = _sI7::P32;
      P32[Hp - 32] = _sI8::P32;
      P32[Hp - 28] = _sI9::P32;
      P32[Hp - 24] = _sIe::P32;
      _cO0::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIc::P32;
      P32[Hp - 12] = _sId::P32;
      _cOj::P32 = Hp - 19;
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _cOj::P32;
      P32[Hp] = _cO0::P32;
      _cOk::P32 = Hp - 7;
      R1 = _cOk::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cO8:
      R1 = GHC.Err.undefined_closure;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cOe:
      _sI7::P32 = P32[(old + 20)];
      _sI8::P32 = P32[(old + 16)];
      _sI9::P32 = P32[(old + 12)];
      _sIa::P32 = P32[(old + 8)];
      goto cNS;
  cNS:
      if (Sp - <highSp> < SpLim) goto cOf; else goto cOg;
  cOf:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
      P32[(old + 20)] = _sI7::P32;
      P32[(old + 16)] = _sI8::P32;
      P32[(old + 12)] = _sI9::P32;
      P32[(old + 8)] = _sIa::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cOg:
      I32[(young<cNU> + 4)] = cNU;
      R1 = _sIa::P32;
      if (R1 & 3 != 0) goto cNU; else goto cNV;
  cNV:
      call (I32[R1])(R1) returns to cNU, args: 4, res: 4, upd: 4;
  cNU:
      _sIb::P32 = R1;
      _cOa::P32 = _sIb::P32 & 3;
      if (_cOa::P32 >= 2) goto cO9; else goto cO8;
  cO9:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cOn; else goto cOm;
  cOn:
      HpAlloc = 48;
      goto cOl;
  cOl:
      R1 = _sIb::P32;
      call stg_gc_unpt_r1(R1) returns to cNU, args: 4, res: 4, upd: 4;
  cOm:
      _sIc::P32 = P32[_sIb::P32 + 2];
      _sId::P32 = P32[_sIb::P32 + 6];
      _sIe::P32 = P32[_sIb::P32 + 10];
      I32[Hp - 44] = sat_sIg_info;
      P32[Hp - 36] = _sI7::P32;
      P32[Hp - 32] = _sI8::P32;
      P32[Hp - 28] = _sI9::P32;
      P32[Hp - 24] = _sIe::P32;
      _cO0::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIc::P32;
      P32[Hp - 12] = _sId::P32;
      _cOj::P32 = Hp - 19;
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _cOj::P32;
      P32[Hp] = _cO0::P32;
      _cOk::P32 = Hp - 7;
      R1 = _cOk::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cO8:
      R1 = GHC.Err.undefined_closure;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cOe:
      _sI7::P32 = P32[(old + 20)];
      _sI8::P32 = P32[(old + 16)];
      _sI9::P32 = P32[(old + 12)];
      _sIa::P32 = P32[(old + 8)];
      goto cNS;
  cNS:
      if (Sp - <highSp> < SpLim) goto cOf; else goto cOg;
  cOf:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
      P32[(old + 20)] = _sI7::P32;
      P32[(old + 16)] = _sI8::P32;
      P32[(old + 12)] = _sI9::P32;
      P32[(old + 8)] = _sIa::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cOg:
      I32[(young<cNU> + 4)] = cNU;
      R1 = _sIa::P32;
      if (R1 & 3 != 0) goto cNU; else goto cNV;
  cNV:
      call (I32[R1])(R1) returns to cNU, args: 4, res: 4, upd: 4;
  cNU:
      _sIb::P32 = R1;
      _cOa::P32 = _sIb::P32 & 3;
      if (_cOa::P32 >= 2) goto cO9; else goto cO8;
  cO9:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cOn; else goto cOm;
  cOn:
      HpAlloc = 48;
      goto cOl;
  cOl:
      R1 = _sIb::P32;
      call stg_gc_unpt_r1(R1) returns to cNU, args: 4, res: 4, upd: 4;
  cOm:
      _sIc::P32 = P32[_sIb::P32 + 2];
      _sId::P32 = P32[_sIb::P32 + 6];
      _sIe::P32 = P32[_sIb::P32 + 10];
      I32[Hp - 44] = sat_sIg_info;
      P32[Hp - 36] = _sI7::P32;
      P32[Hp - 32] = _sI8::P32;
      P32[Hp - 28] = _sI9::P32;
      P32[Hp - 24] = _sIe::P32;
      _cO0::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIc::P32;
      P32[Hp - 12] = _sId::P32;
      _cOj::P32 = Hp - 19;
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _cOj::P32;
      P32[Hp] = _cO0::P32;
      _cOk::P32 = Hp - 7;
      R1 = _cOk::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cO8:
      R1 = GHC.Err.undefined_closure;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cOe:
      _sI7::P32 = P32[(old + 20)];
      _sI8::P32 = P32[(old + 16)];
      _sI9::P32 = P32[(old + 12)];
      _sIa::P32 = P32[(old + 8)];
      goto cNS;
  cNS:
      if (Sp - <highSp> < SpLim) goto cOf; else goto cOg;
  cOf:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
      P32[(old + 20)] = _sI7::P32;
      P32[(old + 16)] = _sI8::P32;
      P32[(old + 12)] = _sI9::P32;
      P32[(old + 8)] = _sIa::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cOg:
      I32[(young<cNU> + 4)] = cNU;
      R1 = _sIa::P32;
      if (_sIa::P32 & 3 != 0) goto cNU; else goto cNV;
  cNV:
      call (I32[_sIa::P32])(R1) returns to cNU, args: 4, res: 4, upd: 4;
  cNU:
      _sIb::P32 = R1;
      _cOa::P32 = R1 & 3;
      if (_cOa::P32 >= 2) goto cO9; else goto cO8;
  cO9:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cOn; else goto cOm;
  cOn:
      HpAlloc = 48;
      goto cOl;
  cOl:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cNU, args: 4, res: 4, upd: 4;
  cOm:
      _sIc::P32 = P32[R1 + 2];
      _sId::P32 = P32[R1 + 6];
      _sIe::P32 = P32[R1 + 10];
      I32[Hp - 44] = sat_sIg_info;
      P32[Hp - 36] = _sI7::P32;
      P32[Hp - 32] = _sI8::P32;
      P32[Hp - 28] = _sI9::P32;
      P32[Hp - 24] = _sIe::P32;
      _cO0::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIc::P32;
      P32[Hp - 12] = _sId::P32;
      _cOj::P32 = Hp - 19;
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _cOj::P32;
      P32[Hp] = _cO0::P32;
      _cOk::P32 = Hp - 7;
      R1 = _cOk::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cO8:
      R1 = GHC.Err.undefined_closure;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cOe:
      _sI7::P32 = P32[Sp];
      _sI8::P32 = P32[Sp + 4];
      _sI9::P32 = P32[Sp + 8];
      _sIa::P32 = P32[Sp + 12];
      goto cNS;
  cNS:
      if (Sp - 4 < SpLim) goto cOf; else goto cOg;
  cOf:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cOg:
      I32[Sp - 4] = cNU;
      R1 = _sIa::P32;
      Sp = Sp - 4;
      if (_sIa::P32 & 3 != 0) goto cNU; else goto cNV;
  cNV:
      call (I32[_sIa::P32])(R1) returns to cNU, args: 4, res: 4, upd: 4;
  cNU:
      _sI7::P32 = P32[Sp + 4];
      _sI8::P32 = P32[Sp + 8];
      _sI9::P32 = P32[Sp + 12];
      _sIb::P32 = R1;
      _cOa::P32 = R1 & 3;
      if (_cOa::P32 >= 2) goto cO9; else goto cO8;
  cO9:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cOn; else goto cOm;
  cOn:
      HpAlloc = 48;
      goto cOl;
  cOl:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cNU, args: 4, res: 4, upd: 4;
  cOm:
      _sIc::P32 = P32[R1 + 2];
      _sId::P32 = P32[R1 + 6];
      _sIe::P32 = P32[R1 + 10];
      I32[Hp - 44] = sat_sIg_info;
      P32[Hp - 36] = _sI7::P32;
      P32[Hp - 32] = _sI8::P32;
      P32[Hp - 28] = _sI9::P32;
      P32[Hp - 24] = _sIe::P32;
      _cO0::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIc::P32;
      P32[Hp - 12] = _sId::P32;
      _cOj::P32 = Hp - 19;
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _cOj::P32;
      P32[Hp] = _cO0::P32;
      _cOk::P32 = Hp - 7;
      R1 = _cOk::P32;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cO8:
      R1 = GHC.Err.undefined_closure;
      Sp = Sp + 20;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cOe:
      goto cNS;
  cNS:
      if ((Sp + -4) < SpLim) goto cOf; else goto cOg;
  cOf:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cOg:
      I32[Sp - 4] = cNU;
      _sIa::P32 = P32[Sp + 12];
      R1 = _sIa::P32;
      Sp = Sp - 4;
      if (_sIa::P32 & 3 != 0) goto cNU; else goto cNV;
  cNV:
      call (I32[_sIa::P32])(R1) returns to cNU, args: 4, res: 4, upd: 4;
  cNU:
      if (R1 & 3 >= 2) goto cO9; else goto cO8;
  cO9:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cOn; else goto cOm;
  cOn:
      HpAlloc = 48;
      goto cOl;
  cOl:
      call stg_gc_unpt_r1(R1) returns to cNU, args: 4, res: 4, upd: 4;
  cOm:
      _sIc::P32 = P32[R1 + 2];
      _sId::P32 = P32[R1 + 6];
      _sIe::P32 = P32[R1 + 10];
      I32[Hp - 44] = sat_sIg_info;
      P32[Hp - 36] = P32[Sp + 4];
      P32[Hp - 32] = P32[Sp + 8];
      P32[Hp - 28] = P32[Sp + 12];
      P32[Hp - 24] = _sIe::P32;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIc::P32;
      P32[Hp - 12] = _sId::P32;
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = Hp - 19;
      P32[Hp] = Hp - 44;
      R1 = Hp - 7;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cO8:
      R1 = GHC.Err.undefined_closure;
      Sp = Sp + 20;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cNS,
  {GHC.Err.undefined_closure,
   T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure,
   sat_sIg_closure}),
 (cNU, {GHC.Err.undefined_closure, sat_sIg_closure}),
 (cNV, {GHC.Err.undefined_closure, sat_sIg_closure}),
 (cO8, {GHC.Err.undefined_closure}),
 (cO9, {GHC.Err.undefined_closure, sat_sIg_closure}),
 (cOe,
  {GHC.Err.undefined_closure,
   T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure,
   sat_sIg_closure}),
 (cOf, {T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure}),
 (cOg, {GHC.Err.undefined_closure, sat_sIg_closure}),
 (cOl, {GHC.Err.undefined_closure, sat_sIg_closure}),
 (cOm, {sat_sIg_closure}),
 (cOn, {GHC.Err.undefined_closure, sat_sIg_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_$cextractMin_entry() //  []
        { info_tbl: [(cNU,
                      label: block_cNU_info
                      rep:StackRep [False, False, False, True]),
                     (cOe,
                      label: T2902_B_PairingSum.$fSumPSumab_$cextractMin_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cOe:
          goto cNS;
      cNS:
          if ((Sp + -4) < SpLim) goto cOf; else goto cOg;
      cOf:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cOg:
          I32[Sp - 4] = cNU;
          _sIa::P32 = P32[Sp + 12];
          R1 = _sIa::P32;
          Sp = Sp - 4;
          if (_sIa::P32 & 3 != 0) goto cNU; else goto cNV;
      cNV:
          call (I32[_sIa::P32])(R1) returns to cNU, args: 4, res: 4, upd: 4;
      cNU:
          if (R1 & 3 >= 2) goto cO9; else goto cO8;
      cO9:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cOn; else goto cOm;
      cOn:
          HpAlloc = 48;
          goto cOl;
      cOl:
          call stg_gc_unpt_r1(R1) returns to cNU, args: 4, res: 4, upd: 4;
      cOm:
          _sIc::P32 = P32[R1 + 2];
          _sId::P32 = P32[R1 + 6];
          _sIe::P32 = P32[R1 + 10];
          I32[Hp - 44] = sat_sIg_info;
          P32[Hp - 36] = P32[Sp + 4];
          P32[Hp - 32] = P32[Sp + 8];
          P32[Hp - 28] = P32[Sp + 12];
          P32[Hp - 24] = _sIe::P32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = _sIc::P32;
          P32[Hp - 12] = _sId::P32;
          I32[Hp - 8] = (,)_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 44;
          R1 = Hp - 7;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cO8:
          R1 = GHC.Err.undefined_closure;
          Sp = Sp + 20;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_$cextractMin_entry() //  []
        { info_tbl: [(cNS,
                      label: T2902_B_PairingSum.$fSumPSumab_$cextractMin_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                     (cNU,
                      label: block_cNU_info
                      rep:StackRep [False, False, False, True])]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cNS:
          if ((Sp + -4) < SpLim) goto cOf; else goto cOg;
      cOf:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cOg:
          I32[Sp - 4] = cNU;
          _sIa::P32 = P32[Sp + 12];
          R1 = _sIa::P32;
          Sp = Sp - 4;
          if (_sIa::P32 & 3 != 0) goto cNU; else goto cNV;
      cNV:
          call (I32[_sIa::P32])(R1) returns to cNU, args: 4, res: 4, upd: 4;
      cNU:
          if (R1 & 3 >= 2) goto cO9; else goto cO8;
      cO9:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cOn; else goto cOm;
      cOn:
          HpAlloc = 48;
          goto cOl;
      cOl:
          call stg_gc_unpt_r1(R1) returns to cNU, args: 4, res: 4, upd: 4;
      cOm:
          _sIc::P32 = P32[R1 + 2];
          _sId::P32 = P32[R1 + 6];
          _sIe::P32 = P32[R1 + 10];
          I32[Hp - 44] = sat_sIg_info;
          P32[Hp - 36] = P32[Sp + 4];
          P32[Hp - 32] = P32[Sp + 8];
          P32[Hp - 28] = P32[Sp + 12];
          P32[Hp - 24] = _sIe::P32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = _sIc::P32;
          P32[Hp - 12] = _sId::P32;
          I32[Hp - 8] = (,)_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 44;
          R1 = Hp - 7;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cO8:
          R1 = GHC.Err.undefined_closure;
          Sp = Sp + 20;
          call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cextractMin_info;
         const 0;
 },
 sat_sIg_entry() //  [R1]
         { info_tbl: [(cO2,
                       label: sat_sIg_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cO2:
           if ((Sp + -24) < SpLim) goto cO5; else goto cO6;
       cO5:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cO6:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           P32[Sp - 24] = P32[R1 + 8];
           P32[Sp - 20] = P32[R1 + 12];
           P32[Sp - 16] = P32[R1 + 16];
           P32[Sp - 12] = P32[R1 + 20];
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$cextractMin_entry() //  []
         { info_tbl: [(cNS,
                       label: T2902_B_PairingSum.$fSumPSumab_$cextractMin_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cNU,
                       label: block_cNU_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cNS:
           if ((Sp + -4) < SpLim) goto cOf; else goto cOg;
       cOf:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cOg:
           I32[Sp - 4] = cNU;
           _sIa::P32 = P32[Sp + 12];
           R1 = _sIa::P32;
           Sp = Sp - 4;
           if (_sIa::P32 & 3 != 0) goto cNU; else goto cNV;
       cNV:
           call (I32[_sIa::P32])(R1) returns to cNU, args: 4, res: 4, upd: 4;
       cNU:
           if (R1 & 3 >= 2) goto cO9; else goto cO8;
       cO9:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cOn; else goto cOm;
       cOn:
           HpAlloc = 48;
           goto cOl;
       cOl:
           call stg_gc_unpt_r1(R1) returns to cNU, args: 4, res: 4, upd: 4;
       cOm:
           _sIc::P32 = P32[R1 + 2];
           _sId::P32 = P32[R1 + 6];
           _sIe::P32 = P32[R1 + 10];
           I32[Hp - 44] = sat_sIg_info;
           P32[Hp - 36] = P32[Sp + 4];
           P32[Hp - 32] = P32[Sp + 8];
           P32[Hp - 28] = P32[Sp + 12];
           P32[Hp - 24] = _sIe::P32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _sIc::P32;
           P32[Hp - 12] = _sId::P32;
           I32[Hp - 8] = (,)_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 44;
           R1 = Hp - 7;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cO8:
           R1 = GHC.Err.undefined_closure;
           Sp = Sp + 20;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cextractMin_info;
         const 0;
 },
 sat_sIg_entry() //  [R1]
         { info_tbl: [(cO2,
                       label: sat_sIg_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cO2:
           if ((Sp + -24) < SpLim) goto cO5; else goto cO6;
       cO5:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cO6:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           P32[Sp - 24] = P32[R1 + 8];
           P32[Sp - 20] = P32[R1 + 12];
           P32[Sp - 16] = P32[R1 + 16];
           P32[Sp - 12] = P32[R1 + 20];
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$cextractMin_entry() //  []
         { info_tbl: [(cNS,
                       label: T2902_B_PairingSum.$fSumPSumab_$cextractMin_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cNU,
                       label: block_cNU_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cNS:
           if ((Sp + -4) < SpLim) goto cOf; else goto cOg;
       cOf:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cOg:
           I32[Sp - 4] = cNU;
           _sIa::P32 = P32[Sp + 12];
           R1 = _sIa::P32;
           Sp = Sp - 4;
           if (_sIa::P32 & 3 != 0) goto cNU; else goto cNV;
       cNV:
           call (I32[_sIa::P32])(R1) returns to cNU, args: 4, res: 4, upd: 4;
       cNU:
           if (R1 & 3 >= 2) goto cO9; else goto cO8;
       cO9:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cOn; else goto cOm;
       cOn:
           HpAlloc = 48;
           goto cOl;
       cOl:
           call stg_gc_unpt_r1(R1) returns to cNU, args: 4, res: 4, upd: 4;
       cOm:
           _sIc::P32 = P32[R1 + 2];
           _sId::P32 = P32[R1 + 6];
           _sIe::P32 = P32[R1 + 10];
           I32[Hp - 44] = sat_sIg_info;
           P32[Hp - 36] = P32[Sp + 4];
           P32[Hp - 32] = P32[Sp + 8];
           P32[Hp - 28] = P32[Sp + 12];
           P32[Hp - 24] = _sIe::P32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _sIc::P32;
           P32[Hp - 12] = _sId::P32;
           I32[Hp - 8] = (,)_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 44;
           R1 = Hp - 7;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cO8:
           R1 = GHC.Err.undefined_closure;
           Sp = Sp + 20;
           call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$ctoList_closure:
         const T2902_B_PairingSum.$fSumPSumab_$ctoList_info;
         const 0;
 },
 sat_sIr_entry() //  [R1]
         { info_tbl: [(cP7,
                       label: sat_sIr_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cP7:
           _sIr::P32 = R1;
           goto cP3;
       cP3:
           if (Sp - <highSp> < SpLim) goto cP8; else goto cP9;
       cP8:
           R1 = _sIr::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cP9:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _sIr::P32;
           _sIh::P32 = P32[_sIr::P32 + 8];
           _sIi::P32 = P32[_sIr::P32 + 12];
           _sIj::P32 = P32[_sIr::P32 + 16];
           _sIo::P32 = P32[_sIr::P32 + 20];
           I32[(young<cP5> + 4)] = cP5;
           P32[(young<cP5> + 20)] = _sIh::P32;
           P32[(young<cP5> + 16)] = _sIi::P32;
           P32[(young<cP5> + 12)] = _sIj::P32;
           P32[(young<cP5> + 8)] = _sIo::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP5, args: 20, res: 4, upd: 12;
       cP5:
           _sIq::P32 = R1;
           P32[(old + 28)] = _sIh::P32;
           P32[(old + 24)] = _sIi::P32;
           P32[(old + 20)] = _sIj::P32;
           P32[(old + 16)] = _sIq::P32;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$ctoList_entry() //  []
         { info_tbl: [(cPk,
                       label: T2902_B_PairingSum.$fSumPSumab_$ctoList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cPk:
           _sIh::P32 = P32[(old + 20)];
           _sIi::P32 = P32[(old + 16)];
           _sIj::P32 = P32[(old + 12)];
           _sIk::P32 = P32[(old + 8)];
           goto cOT;
       cOT:
           if (Sp - <highSp> < SpLim) goto cPl; else goto cPm;
       cPl:
           R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
           P32[(old + 20)] = _sIh::P32;
           P32[(old + 16)] = _sIi::P32;
           P32[(old + 12)] = _sIj::P32;
           P32[(old + 8)] = _sIk::P32;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cPm:
           I32[(young<cOV> + 4)] = cOV;
           R1 = _sIk::P32;
           if (R1 & 3 != 0) goto cOV; else goto cOW;
       cOW:
           call (I32[R1])(R1) returns to cOV, args: 4, res: 4, upd: 4;
       cOV:
           _sIl::P32 = R1;
           _cPg::P32 = _sIl::P32 & 3;
           if (_cPg::P32 >= 2) goto cPi; else goto cPj;
       cPi:
           goto cPf;
       cPf:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cPt; else goto cPs;
       cPt:
           HpAlloc = 48;
           goto cPr;
       cPr:
           R1 = _sIl::P32;
           call stg_gc_unpt_r1(R1) returns to cOV, args: 4, res: 4, upd: 4;
       cPs:
           _sIm::P32 = P32[_sIl::P32 + 2];
           _sIn::P32 = P32[_sIl::P32 + 6];
           _sIo::P32 = P32[_sIl::P32 + 10];
           I32[Hp - 44] = sat_sIr_info;
           P32[Hp - 36] = _sIh::P32;
           P32[Hp - 32] = _sIi::P32;
           P32[Hp - 28] = _sIj::P32;
           P32[Hp - 24] = _sIo::P32;
           _cP1::P32 = Hp - 44;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _sIm::P32;
           P32[Hp - 12] = _sIn::P32;
           _cPp::P32 = Hp - 19;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = _cPp::P32;
           P32[Hp] = _cP1::P32;
           _cPq::P32 = Hp - 6;
           R1 = _cPq::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
       cPj:
           goto cPe;
       cPe:
           R1 = []_closure+1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cP7:
      _sIr::P32 = R1;
      goto cP3;
  cP3:
      if (Sp - <highSp> < SpLim) goto cP8; else goto cP9;
  cP8:
      R1 = _sIr::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cP9:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sIr::P32;
      _sIh::P32 = P32[_sIr::P32 + 8];
      _sIi::P32 = P32[_sIr::P32 + 12];
      _sIj::P32 = P32[_sIr::P32 + 16];
      _sIo::P32 = P32[_sIr::P32 + 20];
      I32[(young<cP5> + 4)] = cP5;
      P32[(young<cP5> + 20)] = _sIh::P32;
      P32[(young<cP5> + 16)] = _sIi::P32;
      P32[(young<cP5> + 12)] = _sIj::P32;
      P32[(young<cP5> + 8)] = _sIo::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP5, args: 20, res: 4, upd: 12;
  cP5:
      _sIq::P32 = R1;
      P32[(old + 28)] = _sIh::P32;
      P32[(old + 24)] = _sIi::P32;
      P32[(old + 20)] = _sIj::P32;
      P32[(old + 16)] = _sIq::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  cP7:
      _sIr::P32 = R1;
      goto cP3;
  cP3:
      if (Sp - <highSp> < SpLim) goto cP8; else goto cP9;
  cP8:
      R1 = _sIr::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cP9:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sIr::P32;
      _sIh::P32 = P32[_sIr::P32 + 8];
      _sIi::P32 = P32[_sIr::P32 + 12];
      _sIj::P32 = P32[_sIr::P32 + 16];
      _sIo::P32 = P32[_sIr::P32 + 20];
      I32[(young<cP5> + 4)] = cP5;
      P32[(young<cP5> + 20)] = _sIh::P32;
      P32[(young<cP5> + 16)] = _sIi::P32;
      P32[(young<cP5> + 12)] = _sIj::P32;
      P32[(young<cP5> + 8)] = _sIo::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP5, args: 20, res: 4, upd: 12;
  cP5:
      _sIq::P32 = R1;
      P32[(old + 28)] = _sIh::P32;
      P32[(old + 24)] = _sIi::P32;
      P32[(old + 20)] = _sIj::P32;
      P32[(old + 16)] = _sIq::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  cP7:
      _sIr::P32 = R1;
      goto cP3;
  cP3:
      if (Sp - <highSp> < SpLim) goto cP8; else goto cP9;
  cP8:
      R1 = _sIr::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cP9:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _sIr::P32;
      _sIh::P32 = P32[_sIr::P32 + 8];
      _sIi::P32 = P32[_sIr::P32 + 12];
      _sIj::P32 = P32[_sIr::P32 + 16];
      _sIo::P32 = P32[_sIr::P32 + 20];
      I32[(young<cP5> + 4)] = cP5;
      P32[(young<cP5> + 20)] = _sIh::P32;
      P32[(young<cP5> + 16)] = _sIi::P32;
      P32[(young<cP5> + 12)] = _sIj::P32;
      P32[(young<cP5> + 8)] = _sIo::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP5, args: 20, res: 4, upd: 12;
  cP5:
      _sIq::P32 = R1;
      P32[(old + 28)] = _sIh::P32;
      P32[(old + 24)] = _sIi::P32;
      P32[(old + 20)] = _sIj::P32;
      P32[(old + 16)] = _sIq::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  cP7:
      _sIr::P32 = R1;
      goto cP3;
  cP3:
      if (Sp - <highSp> < SpLim) goto cP8; else goto cP9;
  cP8:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cP9:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _sIh::P32 = P32[R1 + 8];
      _sIi::P32 = P32[R1 + 12];
      _sIj::P32 = P32[R1 + 16];
      _sIo::P32 = P32[R1 + 20];
      I32[(young<cP5> + 4)] = cP5;
      P32[(young<cP5> + 20)] = _sIh::P32;
      P32[(young<cP5> + 16)] = _sIi::P32;
      P32[(young<cP5> + 12)] = _sIj::P32;
      P32[(young<cP5> + 8)] = _sIo::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP5, args: 20, res: 4, upd: 12;
  cP5:
      _sIq::P32 = R1;
      P32[(old + 28)] = _sIh::P32;
      P32[(old + 24)] = _sIi::P32;
      P32[(old + 20)] = _sIj::P32;
      P32[(old + 16)] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  cP7:
      _sIr::P32 = R1;
      goto cP3;
  cP3:
      if (Sp - 40 < SpLim) goto cP8; else goto cP9;
  cP8:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cP9:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _sIh::P32 = P32[R1 + 8];
      _sIi::P32 = P32[R1 + 12];
      _sIj::P32 = P32[R1 + 16];
      _sIo::P32 = P32[R1 + 20];
      I32[Sp - 24] = cP5;
      P32[Sp - 40] = _sIh::P32;
      P32[Sp - 36] = _sIi::P32;
      P32[Sp - 32] = _sIj::P32;
      P32[Sp - 28] = _sIo::P32;
      P32[Sp - 20] = _sIh::P32;
      P32[Sp - 16] = _sIi::P32;
      P32[Sp - 12] = _sIj::P32;
      Sp = Sp - 40;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP5, args: 20, res: 4, upd: 12;
  cP5:
      _sIh::P32 = P32[Sp + 4];
      _sIi::P32 = P32[Sp + 8];
      _sIj::P32 = P32[Sp + 12];
      _sIq::P32 = R1;
      P32[Sp] = _sIh::P32;
      P32[Sp + 4] = _sIi::P32;
      P32[Sp + 8] = _sIj::P32;
      P32[Sp + 12] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  cP7:
      goto cP3;
  cP3:
      if ((Sp + -40) < SpLim) goto cP8; else goto cP9;
  cP8:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  cP9:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      I32[Sp - 24] = cP5;
      _sIh::P32 = P32[R1 + 8];
      P32[Sp - 40] = _sIh::P32;
      _sIi::P32 = P32[R1 + 12];
      P32[Sp - 36] = _sIi::P32;
      _sIj::P32 = P32[R1 + 16];
      P32[Sp - 32] = _sIj::P32;
      P32[Sp - 28] = P32[R1 + 20];
      P32[Sp - 20] = _sIh::P32;
      P32[Sp - 16] = _sIi::P32;
      P32[Sp - 12] = _sIj::P32;
      Sp = Sp - 40;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP5, args: 20, res: 4, upd: 12;
  cP5:
      P32[Sp] = P32[Sp + 4];
      P32[Sp + 4] = P32[Sp + 8];
      P32[Sp + 8] = P32[Sp + 12];
      P32[Sp + 12] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(cP3,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cP5, {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure}),
 (cP7,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cP8, {}),
 (cP9,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cunions_closure})]



==================== after setInfoTableStackMap ====================
sat_sIr_entry() //  [R1]
        { info_tbl: [(cP5,
                      label: block_cP5_info
                      rep:StackRep [False, False, False]),
                     (cP7,
                      label: sat_sIr_info
                      rep:HeapRep 4 ptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cP7:
          goto cP3;
      cP3:
          if ((Sp + -40) < SpLim) goto cP8; else goto cP9;
      cP8:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cP9:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          I32[Sp - 24] = cP5;
          _sIh::P32 = P32[R1 + 8];
          P32[Sp - 40] = _sIh::P32;
          _sIi::P32 = P32[R1 + 12];
          P32[Sp - 36] = _sIi::P32;
          _sIj::P32 = P32[R1 + 16];
          P32[Sp - 32] = _sIj::P32;
          P32[Sp - 28] = P32[R1 + 20];
          P32[Sp - 20] = _sIh::P32;
          P32[Sp - 16] = _sIi::P32;
          P32[Sp - 12] = _sIj::P32;
          Sp = Sp - 40;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP5, args: 20, res: 4, upd: 12;
      cP5:
          P32[Sp] = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp + 8];
          P32[Sp + 8] = P32[Sp + 12];
          P32[Sp + 12] = R1;
          call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_sIr_entry() //  [R1]
        { info_tbl: [(cP3,
                      label: sat_sIr_info
                      rep:HeapRep 4 ptrs { Thunk }),
                     (cP5,
                      label: block_cP5_info
                      rep:StackRep [False, False, False])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cP3:
          if ((Sp + -40) < SpLim) goto cP8; else goto cP9;
      cP8:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      cP9:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          I32[Sp - 24] = cP5;
          _sIh::P32 = P32[R1 + 8];
          P32[Sp - 40] = _sIh::P32;
          _sIi::P32 = P32[R1 + 12];
          P32[Sp - 36] = _sIi::P32;
          _sIj::P32 = P32[R1 + 16];
          P32[Sp - 32] = _sIj::P32;
          P32[Sp - 28] = P32[R1 + 20];
          P32[Sp - 20] = _sIh::P32;
          P32[Sp - 16] = _sIi::P32;
          P32[Sp - 12] = _sIj::P32;
          Sp = Sp - 40;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP5, args: 20, res: 4, upd: 12;
      cP5:
          P32[Sp] = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp + 8];
          P32[Sp + 8] = P32[Sp + 12];
          P32[Sp + 12] = R1;
          call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cPk:
      _sIh::P32 = P32[(old + 20)];
      _sIi::P32 = P32[(old + 16)];
      _sIj::P32 = P32[(old + 12)];
      _sIk::P32 = P32[(old + 8)];
      goto cOT;
  cOT:
      if (Sp - <highSp> < SpLim) goto cPl; else goto cPm;
  cPl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
      P32[(old + 20)] = _sIh::P32;
      P32[(old + 16)] = _sIi::P32;
      P32[(old + 12)] = _sIj::P32;
      P32[(old + 8)] = _sIk::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cPm:
      I32[(young<cOV> + 4)] = cOV;
      R1 = _sIk::P32;
      if (R1 & 3 != 0) goto cOV; else goto cOW;
  cOW:
      call (I32[R1])(R1) returns to cOV, args: 4, res: 4, upd: 4;
  cOV:
      _sIl::P32 = R1;
      _cPg::P32 = _sIl::P32 & 3;
      if (_cPg::P32 >= 2) goto cPf; else goto cPe;
  cPf:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cPt; else goto cPs;
  cPt:
      HpAlloc = 48;
      goto cPr;
  cPr:
      R1 = _sIl::P32;
      call stg_gc_unpt_r1(R1) returns to cOV, args: 4, res: 4, upd: 4;
  cPs:
      _sIm::P32 = P32[_sIl::P32 + 2];
      _sIn::P32 = P32[_sIl::P32 + 6];
      _sIo::P32 = P32[_sIl::P32 + 10];
      I32[Hp - 44] = sat_sIr_info;
      P32[Hp - 36] = _sIh::P32;
      P32[Hp - 32] = _sIi::P32;
      P32[Hp - 28] = _sIj::P32;
      P32[Hp - 24] = _sIo::P32;
      _cP1::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIm::P32;
      P32[Hp - 12] = _sIn::P32;
      _cPp::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _cPp::P32;
      P32[Hp] = _cP1::P32;
      _cPq::P32 = Hp - 6;
      R1 = _cPq::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cPe:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cPk:
      _sIh::P32 = P32[(old + 20)];
      _sIi::P32 = P32[(old + 16)];
      _sIj::P32 = P32[(old + 12)];
      _sIk::P32 = P32[(old + 8)];
      goto cOT;
  cOT:
      if (Sp - <highSp> < SpLim) goto cPl; else goto cPm;
  cPl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
      P32[(old + 20)] = _sIh::P32;
      P32[(old + 16)] = _sIi::P32;
      P32[(old + 12)] = _sIj::P32;
      P32[(old + 8)] = _sIk::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cPm:
      I32[(young<cOV> + 4)] = cOV;
      R1 = _sIk::P32;
      if (R1 & 3 != 0) goto cOV; else goto cOW;
  cOW:
      call (I32[R1])(R1) returns to cOV, args: 4, res: 4, upd: 4;
  cOV:
      _sIl::P32 = R1;
      _cPg::P32 = _sIl::P32 & 3;
      if (_cPg::P32 >= 2) goto cPf; else goto cPe;
  cPf:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cPt; else goto cPs;
  cPt:
      HpAlloc = 48;
      goto cPr;
  cPr:
      R1 = _sIl::P32;
      call stg_gc_unpt_r1(R1) returns to cOV, args: 4, res: 4, upd: 4;
  cPs:
      _sIm::P32 = P32[_sIl::P32 + 2];
      _sIn::P32 = P32[_sIl::P32 + 6];
      _sIo::P32 = P32[_sIl::P32 + 10];
      I32[Hp - 44] = sat_sIr_info;
      P32[Hp - 36] = _sIh::P32;
      P32[Hp - 32] = _sIi::P32;
      P32[Hp - 28] = _sIj::P32;
      P32[Hp - 24] = _sIo::P32;
      _cP1::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIm::P32;
      P32[Hp - 12] = _sIn::P32;
      _cPp::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _cPp::P32;
      P32[Hp] = _cP1::P32;
      _cPq::P32 = Hp - 6;
      R1 = _cPq::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cPe:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cPk:
      _sIh::P32 = P32[(old + 20)];
      _sIi::P32 = P32[(old + 16)];
      _sIj::P32 = P32[(old + 12)];
      _sIk::P32 = P32[(old + 8)];
      goto cOT;
  cOT:
      if (Sp - <highSp> < SpLim) goto cPl; else goto cPm;
  cPl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
      P32[(old + 20)] = _sIh::P32;
      P32[(old + 16)] = _sIi::P32;
      P32[(old + 12)] = _sIj::P32;
      P32[(old + 8)] = _sIk::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cPm:
      I32[(young<cOV> + 4)] = cOV;
      R1 = _sIk::P32;
      if (R1 & 3 != 0) goto cOV; else goto cOW;
  cOW:
      call (I32[R1])(R1) returns to cOV, args: 4, res: 4, upd: 4;
  cOV:
      _sIl::P32 = R1;
      _cPg::P32 = _sIl::P32 & 3;
      if (_cPg::P32 >= 2) goto cPf; else goto cPe;
  cPf:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cPt; else goto cPs;
  cPt:
      HpAlloc = 48;
      goto cPr;
  cPr:
      R1 = _sIl::P32;
      call stg_gc_unpt_r1(R1) returns to cOV, args: 4, res: 4, upd: 4;
  cPs:
      _sIm::P32 = P32[_sIl::P32 + 2];
      _sIn::P32 = P32[_sIl::P32 + 6];
      _sIo::P32 = P32[_sIl::P32 + 10];
      I32[Hp - 44] = sat_sIr_info;
      P32[Hp - 36] = _sIh::P32;
      P32[Hp - 32] = _sIi::P32;
      P32[Hp - 28] = _sIj::P32;
      P32[Hp - 24] = _sIo::P32;
      _cP1::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIm::P32;
      P32[Hp - 12] = _sIn::P32;
      _cPp::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _cPp::P32;
      P32[Hp] = _cP1::P32;
      _cPq::P32 = Hp - 6;
      R1 = _cPq::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cPe:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cPk:
      _sIh::P32 = P32[(old + 20)];
      _sIi::P32 = P32[(old + 16)];
      _sIj::P32 = P32[(old + 12)];
      _sIk::P32 = P32[(old + 8)];
      goto cOT;
  cOT:
      if (Sp - <highSp> < SpLim) goto cPl; else goto cPm;
  cPl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
      P32[(old + 20)] = _sIh::P32;
      P32[(old + 16)] = _sIi::P32;
      P32[(old + 12)] = _sIj::P32;
      P32[(old + 8)] = _sIk::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cPm:
      I32[(young<cOV> + 4)] = cOV;
      R1 = _sIk::P32;
      if (_sIk::P32 & 3 != 0) goto cOV; else goto cOW;
  cOW:
      call (I32[_sIk::P32])(R1) returns to cOV, args: 4, res: 4, upd: 4;
  cOV:
      _sIl::P32 = R1;
      _cPg::P32 = R1 & 3;
      if (_cPg::P32 >= 2) goto cPf; else goto cPe;
  cPf:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cPt; else goto cPs;
  cPt:
      HpAlloc = 48;
      goto cPr;
  cPr:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cOV, args: 4, res: 4, upd: 4;
  cPs:
      _sIm::P32 = P32[R1 + 2];
      _sIn::P32 = P32[R1 + 6];
      _sIo::P32 = P32[R1 + 10];
      I32[Hp - 44] = sat_sIr_info;
      P32[Hp - 36] = _sIh::P32;
      P32[Hp - 32] = _sIi::P32;
      P32[Hp - 28] = _sIj::P32;
      P32[Hp - 24] = _sIo::P32;
      _cP1::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIm::P32;
      P32[Hp - 12] = _sIn::P32;
      _cPp::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _cPp::P32;
      P32[Hp] = _cP1::P32;
      _cPq::P32 = Hp - 6;
      R1 = _cPq::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  cPe:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cPk:
      _sIh::P32 = P32[Sp];
      _sIi::P32 = P32[Sp + 4];
      _sIj::P32 = P32[Sp + 8];
      _sIk::P32 = P32[Sp + 12];
      goto cOT;
  cOT:
      if (Sp - 4 < SpLim) goto cPl; else goto cPm;
  cPl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cPm:
      I32[Sp - 4] = cOV;
      R1 = _sIk::P32;
      Sp = Sp - 4;
      if (_sIk::P32 & 3 != 0) goto cOV; else goto cOW;
  cOW:
      call (I32[_sIk::P32])(R1) returns to cOV, args: 4, res: 4, upd: 4;
  cOV:
      _sIh::P32 = P32[Sp + 4];
      _sIi::P32 = P32[Sp + 8];
      _sIj::P32 = P32[Sp + 12];
      _sIl::P32 = R1;
      _cPg::P32 = R1 & 3;
      if (_cPg::P32 >= 2) goto cPf; else goto cPe;
  cPf:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cPt; else goto cPs;
  cPt:
      HpAlloc = 48;
      goto cPr;
  cPr:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cOV, args: 4, res: 4, upd: 4;
  cPs:
      _sIm::P32 = P32[R1 + 2];
      _sIn::P32 = P32[R1 + 6];
      _sIo::P32 = P32[R1 + 10];
      I32[Hp - 44] = sat_sIr_info;
      P32[Hp - 36] = _sIh::P32;
      P32[Hp - 32] = _sIi::P32;
      P32[Hp - 28] = _sIj::P32;
      P32[Hp - 24] = _sIo::P32;
      _cP1::P32 = Hp - 44;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIm::P32;
      P32[Hp - 12] = _sIn::P32;
      _cPp::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _cPp::P32;
      P32[Hp] = _cP1::P32;
      _cPq::P32 = Hp - 6;
      R1 = _cPq::P32;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cPe:
      R1 = []_closure+1;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cPk:
      goto cOT;
  cOT:
      if ((Sp + -4) < SpLim) goto cPl; else goto cPm;
  cPl:
      R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cPm:
      I32[Sp - 4] = cOV;
      _sIk::P32 = P32[Sp + 12];
      R1 = _sIk::P32;
      Sp = Sp - 4;
      if (_sIk::P32 & 3 != 0) goto cOV; else goto cOW;
  cOW:
      call (I32[_sIk::P32])(R1) returns to cOV, args: 4, res: 4, upd: 4;
  cOV:
      if (R1 & 3 >= 2) goto cPf; else goto cPe;
  cPf:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cPt; else goto cPs;
  cPt:
      HpAlloc = 48;
      goto cPr;
  cPr:
      call stg_gc_unpt_r1(R1) returns to cOV, args: 4, res: 4, upd: 4;
  cPs:
      _sIm::P32 = P32[R1 + 2];
      _sIn::P32 = P32[R1 + 6];
      _sIo::P32 = P32[R1 + 10];
      I32[Hp - 44] = sat_sIr_info;
      P32[Hp - 36] = P32[Sp + 4];
      P32[Hp - 32] = P32[Sp + 8];
      P32[Hp - 28] = P32[Sp + 12];
      P32[Hp - 24] = _sIo::P32;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _sIm::P32;
      P32[Hp - 12] = _sIn::P32;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = Hp - 19;
      P32[Hp] = Hp - 44;
      R1 = Hp - 6;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  cPe:
      R1 = []_closure+1;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cOT,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   sat_sIr_closure}),
 (cOV, {sat_sIr_closure}), (cOW, {sat_sIr_closure}), (cPe, {}),
 (cPf, {sat_sIr_closure}),
 (cPk,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   sat_sIr_closure}),
 (cPl, {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure}),
 (cPm, {sat_sIr_closure}), (cPr, {sat_sIr_closure}),
 (cPs, {sat_sIr_closure}), (cPt, {sat_sIr_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_$ctoList_entry() //  []
        { info_tbl: [(cOV,
                      label: block_cOV_info
                      rep:StackRep [False, False, False, True]),
                     (cPk,
                      label: T2902_B_PairingSum.$fSumPSumab_$ctoList_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cPk:
          goto cOT;
      cOT:
          if ((Sp + -4) < SpLim) goto cPl; else goto cPm;
      cPl:
          R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cPm:
          I32[Sp - 4] = cOV;
          _sIk::P32 = P32[Sp + 12];
          R1 = _sIk::P32;
          Sp = Sp - 4;
          if (_sIk::P32 & 3 != 0) goto cOV; else goto cOW;
      cOW:
          call (I32[_sIk::P32])(R1) returns to cOV, args: 4, res: 4, upd: 4;
      cOV:
          if (R1 & 3 >= 2) goto cPf; else goto cPe;
      cPf:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cPt; else goto cPs;
      cPt:
          HpAlloc = 48;
          goto cPr;
      cPr:
          call stg_gc_unpt_r1(R1) returns to cOV, args: 4, res: 4, upd: 4;
      cPs:
          _sIm::P32 = P32[R1 + 2];
          _sIn::P32 = P32[R1 + 6];
          _sIo::P32 = P32[R1 + 10];
          I32[Hp - 44] = sat_sIr_info;
          P32[Hp - 36] = P32[Sp + 4];
          P32[Hp - 32] = P32[Sp + 8];
          P32[Hp - 28] = P32[Sp + 12];
          P32[Hp - 24] = _sIo::P32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = _sIm::P32;
          P32[Hp - 12] = _sIn::P32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 44;
          R1 = Hp - 6;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cPe:
          R1 = []_closure+1;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_$ctoList_entry() //  []
        { info_tbl: [(cOT,
                      label: T2902_B_PairingSum.$fSumPSumab_$ctoList_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                     (cOV,
                      label: block_cOV_info
                      rep:StackRep [False, False, False, True])]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cOT:
          if ((Sp + -4) < SpLim) goto cPl; else goto cPm;
      cPl:
          R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cPm:
          I32[Sp - 4] = cOV;
          _sIk::P32 = P32[Sp + 12];
          R1 = _sIk::P32;
          Sp = Sp - 4;
          if (_sIk::P32 & 3 != 0) goto cOV; else goto cOW;
      cOW:
          call (I32[_sIk::P32])(R1) returns to cOV, args: 4, res: 4, upd: 4;
      cOV:
          if (R1 & 3 >= 2) goto cPf; else goto cPe;
      cPf:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cPt; else goto cPs;
      cPt:
          HpAlloc = 48;
          goto cPr;
      cPr:
          call stg_gc_unpt_r1(R1) returns to cOV, args: 4, res: 4, upd: 4;
      cPs:
          _sIm::P32 = P32[R1 + 2];
          _sIn::P32 = P32[R1 + 6];
          _sIo::P32 = P32[R1 + 10];
          I32[Hp - 44] = sat_sIr_info;
          P32[Hp - 36] = P32[Sp + 4];
          P32[Hp - 32] = P32[Sp + 8];
          P32[Hp - 28] = P32[Sp + 12];
          P32[Hp - 24] = _sIo::P32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = _sIm::P32;
          P32[Hp - 12] = _sIn::P32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 44;
          R1 = Hp - 6;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      cPe:
          R1 = []_closure+1;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$ctoList_closure:
         const T2902_B_PairingSum.$fSumPSumab_$ctoList_info;
         const 0;
 },
 sat_sIr_entry() //  [R1]
         { info_tbl: [(cP3,
                       label: sat_sIr_info
                       rep:HeapRep 4 ptrs { Thunk }),
                      (cP5,
                       label: block_cP5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cP3:
           if ((Sp + -40) < SpLim) goto cP8; else goto cP9;
       cP8:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cP9:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           I32[Sp - 24] = cP5;
           _sIh::P32 = P32[R1 + 8];
           P32[Sp - 40] = _sIh::P32;
           _sIi::P32 = P32[R1 + 12];
           P32[Sp - 36] = _sIi::P32;
           _sIj::P32 = P32[R1 + 16];
           P32[Sp - 32] = _sIj::P32;
           P32[Sp - 28] = P32[R1 + 20];
           P32[Sp - 20] = _sIh::P32;
           P32[Sp - 16] = _sIi::P32;
           P32[Sp - 12] = _sIj::P32;
           Sp = Sp - 40;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP5, args: 20, res: 4, upd: 12;
       cP5:
           P32[Sp] = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp + 8];
           P32[Sp + 8] = P32[Sp + 12];
           P32[Sp + 12] = R1;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$ctoList_entry() //  []
         { info_tbl: [(cOT,
                       label: T2902_B_PairingSum.$fSumPSumab_$ctoList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cOV,
                       label: block_cOV_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cOT:
           if ((Sp + -4) < SpLim) goto cPl; else goto cPm;
       cPl:
           R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cPm:
           I32[Sp - 4] = cOV;
           _sIk::P32 = P32[Sp + 12];
           R1 = _sIk::P32;
           Sp = Sp - 4;
           if (_sIk::P32 & 3 != 0) goto cOV; else goto cOW;
       cOW:
           call (I32[_sIk::P32])(R1) returns to cOV, args: 4, res: 4, upd: 4;
       cOV:
           if (R1 & 3 >= 2) goto cPf; else goto cPe;
       cPf:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cPt; else goto cPs;
       cPt:
           HpAlloc = 48;
           goto cPr;
       cPr:
           call stg_gc_unpt_r1(R1) returns to cOV, args: 4, res: 4, upd: 4;
       cPs:
           _sIm::P32 = P32[R1 + 2];
           _sIn::P32 = P32[R1 + 6];
           _sIo::P32 = P32[R1 + 10];
           I32[Hp - 44] = sat_sIr_info;
           P32[Hp - 36] = P32[Sp + 4];
           P32[Hp - 32] = P32[Sp + 8];
           P32[Hp - 28] = P32[Sp + 12];
           P32[Hp - 24] = _sIo::P32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _sIm::P32;
           P32[Hp - 12] = _sIn::P32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 44;
           R1 = Hp - 6;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cPe:
           R1 = []_closure+1;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$ctoList_closure:
         const T2902_B_PairingSum.$fSumPSumab_$ctoList_info;
         const 0;
 },
 sat_sIr_entry() //  [R1]
         { info_tbl: [(cP3,
                       label: sat_sIr_info
                       rep:HeapRep 4 ptrs { Thunk }),
                      (cP5,
                       label: block_cP5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cP3:
           if ((Sp + -40) < SpLim) goto cP8; else goto cP9;
       cP8:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       cP9:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           I32[Sp - 24] = cP5;
           _sIh::P32 = P32[R1 + 8];
           P32[Sp - 40] = _sIh::P32;
           _sIi::P32 = P32[R1 + 12];
           P32[Sp - 36] = _sIi::P32;
           _sIj::P32 = P32[R1 + 16];
           P32[Sp - 32] = _sIj::P32;
           P32[Sp - 28] = P32[R1 + 20];
           P32[Sp - 20] = _sIh::P32;
           P32[Sp - 16] = _sIi::P32;
           P32[Sp - 12] = _sIj::P32;
           Sp = Sp - 40;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() returns to cP5, args: 20, res: 4, upd: 12;
       cP5:
           P32[Sp] = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp + 8];
           P32[Sp + 8] = P32[Sp + 12];
           P32[Sp + 12] = R1;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_$ctoList_entry() //  []
         { info_tbl: [(cOT,
                       label: T2902_B_PairingSum.$fSumPSumab_$ctoList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cOV,
                       label: block_cOV_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cOT:
           if ((Sp + -4) < SpLim) goto cPl; else goto cPm;
       cPl:
           R1 = T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cPm:
           I32[Sp - 4] = cOV;
           _sIk::P32 = P32[Sp + 12];
           R1 = _sIk::P32;
           Sp = Sp - 4;
           if (_sIk::P32 & 3 != 0) goto cOV; else goto cOW;
       cOW:
           call (I32[_sIk::P32])(R1) returns to cOV, args: 4, res: 4, upd: 4;
       cOV:
           if (R1 & 3 >= 2) goto cPf; else goto cPe;
       cPf:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cPt; else goto cPs;
       cPt:
           HpAlloc = 48;
           goto cPr;
       cPr:
           call stg_gc_unpt_r1(R1) returns to cOV, args: 4, res: 4, upd: 4;
       cPs:
           _sIm::P32 = P32[R1 + 2];
           _sIn::P32 = P32[R1 + 6];
           _sIo::P32 = P32[R1 + 10];
           I32[Hp - 44] = sat_sIr_info;
           P32[Hp - 36] = P32[Sp + 4];
           P32[Hp - 32] = P32[Sp + 8];
           P32[Hp - 28] = P32[Sp + 12];
           P32[Hp - 24] = _sIo::P32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _sIm::P32;
           P32[Hp - 12] = _sIn::P32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 44;
           R1 = Hp - 6;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       cPe:
           R1 = []_closure+1;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cfromList_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cfromList_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cfromList_entry() //  []
         { info_tbl: [(cQd,
                       label: T2902_B_PairingSum.$fSumPSumab_$cfromList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cQd:
           _sIs::P32 = P32[(old + 20)];
           _sIt::P32 = P32[(old + 16)];
           _sIu::P32 = P32[(old + 12)];
           _sIv::P32 = P32[(old + 8)];
           goto cQ1;
       cQ1:
           if (Sp - <highSp> < SpLim) goto cQe; else goto cQf;
       cQe:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
           P32[(old + 20)] = _sIs::P32;
           P32[(old + 16)] = _sIt::P32;
           P32[(old + 12)] = _sIu::P32;
           P32[(old + 8)] = _sIv::P32;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cQf:
           I32[(young<cQ3> + 4)] = cQ3;
           R1 = _sIv::P32;
           if (R1 & 3 != 0) goto cQ3; else goto cQ4;
       cQ4:
           call (I32[R1])(R1) returns to cQ3, args: 4, res: 4, upd: 4;
       cQ3:
           _sIw::P32 = R1;
           _cQ9::P32 = _sIw::P32 & 3;
           if (_cQ9::P32 >= 2) goto cQb; else goto cQc;
       cQb:
           goto cQ8;
       cQ8:
           _sIx::P32 = P32[_sIw::P32 + 2];
           _sIy::P32 = P32[_sIw::P32 + 6];
           I32[(young<cQl> + 4)] = cQl;
           R1 = _sIx::P32;
           if (R1 & 3 != 0) goto cQl; else goto cQm;
       cQm:
           call (I32[R1])(R1) returns to cQl, args: 4, res: 4, upd: 4;
       cQl:
           _sIz::P32 = R1;
           _sIA::P32 = P32[_sIz::P32 + 3];
           _sIB::P32 = P32[_sIz::P32 + 7];
           I32[(young<cQq> + 4)] = cQq;
           P32[(young<cQq> + 20)] = _sIs::P32;
           P32[(young<cQq> + 16)] = _sIt::P32;
           P32[(young<cQq> + 12)] = _sIu::P32;
           P32[(young<cQq> + 8)] = _sIy::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQq, args: 20, res: 4, upd: 4;
       cQq:
           _sIC::P32 = R1;
           P32[(old + 28)] = _sIs::P32;
           P32[(old + 24)] = _sIt::P32;
           P32[(old + 20)] = _sIu::P32;
           P32[(old + 16)] = _sIA::P32;
           P32[(old + 12)] = _sIB::P32;
           P32[(old + 8)] = _sIC::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
       cQc:
           goto cQ7;
       cQ7:
           R1 = T2902_B_PairingSum.Empty_closure+1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cQd:
      _sIs::P32 = P32[(old + 20)];
      _sIt::P32 = P32[(old + 16)];
      _sIu::P32 = P32[(old + 12)];
      _sIv::P32 = P32[(old + 8)];
      goto cQ1;
  cQ1:
      if (Sp - <highSp> < SpLim) goto cQe; else goto cQf;
  cQe:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
      P32[(old + 20)] = _sIs::P32;
      P32[(old + 16)] = _sIt::P32;
      P32[(old + 12)] = _sIu::P32;
      P32[(old + 8)] = _sIv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cQf:
      I32[(young<cQ3> + 4)] = cQ3;
      R1 = _sIv::P32;
      if (R1 & 3 != 0) goto cQ3; else goto cQ4;
  cQ4:
      call (I32[R1])(R1) returns to cQ3, args: 4, res: 4, upd: 4;
  cQ3:
      _sIw::P32 = R1;
      _cQ9::P32 = _sIw::P32 & 3;
      if (_cQ9::P32 >= 2) goto cQ8; else goto cQ7;
  cQ8:
      _sIx::P32 = P32[_sIw::P32 + 2];
      _sIy::P32 = P32[_sIw::P32 + 6];
      I32[(young<cQl> + 4)] = cQl;
      R1 = _sIx::P32;
      if (R1 & 3 != 0) goto cQl; else goto cQm;
  cQm:
      call (I32[R1])(R1) returns to cQl, args: 4, res: 4, upd: 4;
  cQl:
      _sIz::P32 = R1;
      _sIA::P32 = P32[_sIz::P32 + 3];
      _sIB::P32 = P32[_sIz::P32 + 7];
      I32[(young<cQq> + 4)] = cQq;
      P32[(young<cQq> + 20)] = _sIs::P32;
      P32[(young<cQq> + 16)] = _sIt::P32;
      P32[(young<cQq> + 12)] = _sIu::P32;
      P32[(young<cQq> + 8)] = _sIy::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQq, args: 20, res: 4, upd: 4;
  cQq:
      _sIC::P32 = R1;
      P32[(old + 28)] = _sIs::P32;
      P32[(old + 24)] = _sIt::P32;
      P32[(old + 20)] = _sIu::P32;
      P32[(old + 16)] = _sIA::P32;
      P32[(old + 12)] = _sIB::P32;
      P32[(old + 8)] = _sIC::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cQ7:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cQd:
      _sIs::P32 = P32[(old + 20)];
      _sIt::P32 = P32[(old + 16)];
      _sIu::P32 = P32[(old + 12)];
      _sIv::P32 = P32[(old + 8)];
      goto cQ1;
  cQ1:
      if (Sp - <highSp> < SpLim) goto cQe; else goto cQf;
  cQe:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
      P32[(old + 20)] = _sIs::P32;
      P32[(old + 16)] = _sIt::P32;
      P32[(old + 12)] = _sIu::P32;
      P32[(old + 8)] = _sIv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cQf:
      I32[(young<cQ3> + 4)] = cQ3;
      R1 = _sIv::P32;
      if (R1 & 3 != 0) goto cQ3; else goto cQ4;
  cQ4:
      call (I32[R1])(R1) returns to cQ3, args: 4, res: 4, upd: 4;
  cQ3:
      _sIw::P32 = R1;
      _cQ9::P32 = _sIw::P32 & 3;
      if (_cQ9::P32 >= 2) goto cQ8; else goto cQ7;
  cQ8:
      _sIx::P32 = P32[_sIw::P32 + 2];
      _sIy::P32 = P32[_sIw::P32 + 6];
      I32[(young<cQl> + 4)] = cQl;
      R1 = _sIx::P32;
      if (R1 & 3 != 0) goto cQl; else goto cQm;
  cQm:
      call (I32[R1])(R1) returns to cQl, args: 4, res: 4, upd: 4;
  cQl:
      _sIz::P32 = R1;
      _sIA::P32 = P32[_sIz::P32 + 3];
      _sIB::P32 = P32[_sIz::P32 + 7];
      I32[(young<cQq> + 4)] = cQq;
      P32[(young<cQq> + 20)] = _sIs::P32;
      P32[(young<cQq> + 16)] = _sIt::P32;
      P32[(young<cQq> + 12)] = _sIu::P32;
      P32[(young<cQq> + 8)] = _sIy::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQq, args: 20, res: 4, upd: 4;
  cQq:
      _sIC::P32 = R1;
      P32[(old + 28)] = _sIs::P32;
      P32[(old + 24)] = _sIt::P32;
      P32[(old + 20)] = _sIu::P32;
      P32[(old + 16)] = _sIA::P32;
      P32[(old + 12)] = _sIB::P32;
      P32[(old + 8)] = _sIC::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cQ7:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cQd:
      _sIs::P32 = P32[(old + 20)];
      _sIt::P32 = P32[(old + 16)];
      _sIu::P32 = P32[(old + 12)];
      _sIv::P32 = P32[(old + 8)];
      goto cQ1;
  cQ1:
      if (Sp - <highSp> < SpLim) goto cQe; else goto cQf;
  cQe:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
      P32[(old + 20)] = _sIs::P32;
      P32[(old + 16)] = _sIt::P32;
      P32[(old + 12)] = _sIu::P32;
      P32[(old + 8)] = _sIv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cQf:
      I32[(young<cQ3> + 4)] = cQ3;
      R1 = _sIv::P32;
      if (R1 & 3 != 0) goto cQ3; else goto cQ4;
  cQ4:
      call (I32[R1])(R1) returns to cQ3, args: 4, res: 4, upd: 4;
  cQ3:
      _sIw::P32 = R1;
      _cQ9::P32 = _sIw::P32 & 3;
      if (_cQ9::P32 >= 2) goto cQ8; else goto cQ7;
  cQ8:
      _sIx::P32 = P32[_sIw::P32 + 2];
      _sIy::P32 = P32[_sIw::P32 + 6];
      I32[(young<cQl> + 4)] = cQl;
      R1 = _sIx::P32;
      if (R1 & 3 != 0) goto cQl; else goto cQm;
  cQm:
      call (I32[R1])(R1) returns to cQl, args: 4, res: 4, upd: 4;
  cQl:
      _sIz::P32 = R1;
      _sIA::P32 = P32[_sIz::P32 + 3];
      _sIB::P32 = P32[_sIz::P32 + 7];
      I32[(young<cQq> + 4)] = cQq;
      P32[(young<cQq> + 20)] = _sIs::P32;
      P32[(young<cQq> + 16)] = _sIt::P32;
      P32[(young<cQq> + 12)] = _sIu::P32;
      P32[(young<cQq> + 8)] = _sIy::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQq, args: 20, res: 4, upd: 4;
  cQq:
      _sIC::P32 = R1;
      P32[(old + 28)] = _sIs::P32;
      P32[(old + 24)] = _sIt::P32;
      P32[(old + 20)] = _sIu::P32;
      P32[(old + 16)] = _sIA::P32;
      P32[(old + 12)] = _sIB::P32;
      P32[(old + 8)] = _sIC::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cQ7:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cQd:
      _sIs::P32 = P32[(old + 20)];
      _sIt::P32 = P32[(old + 16)];
      _sIu::P32 = P32[(old + 12)];
      _sIv::P32 = P32[(old + 8)];
      goto cQ1;
  cQ1:
      if (Sp - <highSp> < SpLim) goto cQe; else goto cQf;
  cQe:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
      P32[(old + 20)] = _sIs::P32;
      P32[(old + 16)] = _sIt::P32;
      P32[(old + 12)] = _sIu::P32;
      P32[(old + 8)] = _sIv::P32;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cQf:
      I32[(young<cQ3> + 4)] = cQ3;
      R1 = _sIv::P32;
      if (_sIv::P32 & 3 != 0) goto cQ3; else goto cQ4;
  cQ4:
      call (I32[_sIv::P32])(R1) returns to cQ3, args: 4, res: 4, upd: 4;
  cQ3:
      _sIw::P32 = R1;
      _cQ9::P32 = R1 & 3;
      if (_cQ9::P32 >= 2) goto cQ8; else goto cQ7;
  cQ8:
      _sIx::P32 = P32[R1 + 2];
      _sIy::P32 = P32[R1 + 6];
      I32[(young<cQl> + 4)] = cQl;
      R1 = _sIx::P32;
      if (_sIx::P32 & 3 != 0) goto cQl; else goto cQm;
  cQm:
      call (I32[_sIx::P32])(R1) returns to cQl, args: 4, res: 4, upd: 4;
  cQl:
      _sIz::P32 = R1;
      _sIA::P32 = P32[R1 + 3];
      _sIB::P32 = P32[R1 + 7];
      I32[(young<cQq> + 4)] = cQq;
      P32[(young<cQq> + 20)] = _sIs::P32;
      P32[(young<cQq> + 16)] = _sIt::P32;
      P32[(young<cQq> + 12)] = _sIu::P32;
      P32[(young<cQq> + 8)] = _sIy::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQq, args: 20, res: 4, upd: 4;
  cQq:
      _sIC::P32 = R1;
      P32[(old + 28)] = _sIs::P32;
      P32[(old + 24)] = _sIt::P32;
      P32[(old + 20)] = _sIu::P32;
      P32[(old + 16)] = _sIA::P32;
      P32[(old + 12)] = _sIB::P32;
      P32[(old + 8)] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cQ7:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cQd:
      _sIs::P32 = P32[Sp];
      _sIt::P32 = P32[Sp + 4];
      _sIu::P32 = P32[Sp + 8];
      _sIv::P32 = P32[Sp + 12];
      goto cQ1;
  cQ1:
      if (Sp - 24 < SpLim) goto cQe; else goto cQf;
  cQe:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cQf:
      I32[Sp - 4] = cQ3;
      R1 = _sIv::P32;
      Sp = Sp - 4;
      if (_sIv::P32 & 3 != 0) goto cQ3; else goto cQ4;
  cQ4:
      call (I32[_sIv::P32])(R1) returns to cQ3, args: 4, res: 4, upd: 4;
  cQ3:
      _sIs::P32 = P32[Sp + 4];
      _sIt::P32 = P32[Sp + 8];
      _sIu::P32 = P32[Sp + 12];
      _sIw::P32 = R1;
      _cQ9::P32 = R1 & 3;
      if (_cQ9::P32 >= 2) goto cQ8; else goto cQ7;
  cQ8:
      _sIx::P32 = P32[R1 + 2];
      _sIy::P32 = P32[R1 + 6];
      I32[Sp] = cQl;
      R1 = _sIx::P32;
      P32[Sp + 16] = _sIy::P32;
      if (_sIx::P32 & 3 != 0) goto cQl; else goto cQm;
  cQm:
      call (I32[_sIx::P32])(R1) returns to cQl, args: 4, res: 4, upd: 4;
  cQl:
      _sIs::P32 = P32[Sp + 4];
      _sIt::P32 = P32[Sp + 8];
      _sIu::P32 = P32[Sp + 12];
      _sIy::P32 = P32[Sp + 16];
      _sIz::P32 = R1;
      _sIA::P32 = P32[R1 + 3];
      _sIB::P32 = P32[R1 + 7];
      I32[Sp - 4] = cQq;
      P32[Sp - 20] = _sIs::P32;
      P32[Sp - 16] = _sIt::P32;
      P32[Sp - 12] = _sIu::P32;
      P32[Sp - 8] = _sIy::P32;
      P32[Sp] = _sIB::P32;
      P32[Sp + 16] = _sIA::P32;
      Sp = Sp - 20;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQq, args: 20, res: 4, upd: 4;
  cQq:
      _sIs::P32 = P32[Sp + 8];
      _sIt::P32 = P32[Sp + 12];
      _sIu::P32 = P32[Sp + 16];
      _sIA::P32 = P32[Sp + 20];
      _sIB::P32 = P32[Sp + 4];
      _sIC::P32 = R1;
      P32[Sp] = _sIs::P32;
      P32[Sp + 4] = _sIt::P32;
      P32[Sp + 8] = _sIu::P32;
      P32[Sp + 12] = _sIA::P32;
      P32[Sp + 16] = _sIB::P32;
      P32[Sp + 20] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cQ7:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cQd:
      goto cQ1;
  cQ1:
      if ((Sp + -24) < SpLim) goto cQe; else goto cQf;
  cQe:
      R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
      call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
  cQf:
      I32[Sp - 4] = cQ3;
      _sIv::P32 = P32[Sp + 12];
      R1 = _sIv::P32;
      Sp = Sp - 4;
      if (_sIv::P32 & 3 != 0) goto cQ3; else goto cQ4;
  cQ4:
      call (I32[_sIv::P32])(R1) returns to cQ3, args: 4, res: 4, upd: 4;
  cQ3:
      if (R1 & 3 >= 2) goto cQ8; else goto cQ7;
  cQ8:
      I32[Sp] = cQl;
      _sIx::P32 = P32[R1 + 2];
      _sIy::P32 = P32[R1 + 6];
      R1 = _sIx::P32;
      P32[Sp + 16] = _sIy::P32;
      if (_sIx::P32 & 3 != 0) goto cQl; else goto cQm;
  cQm:
      call (I32[_sIx::P32])(R1) returns to cQl, args: 4, res: 4, upd: 4;
  cQl:
      I32[Sp - 4] = cQq;
      P32[Sp - 20] = P32[Sp + 4];
      P32[Sp - 16] = P32[Sp + 8];
      P32[Sp - 12] = P32[Sp + 12];
      P32[Sp - 8] = P32[Sp + 16];
      P32[Sp] = P32[R1 + 7];
      P32[Sp + 16] = P32[R1 + 3];
      Sp = Sp - 20;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQq, args: 20, res: 4, upd: 4;
  cQq:
      P32[Sp] = P32[Sp + 8];
      _sIB::P32 = P32[Sp + 4];
      P32[Sp + 4] = P32[Sp + 12];
      P32[Sp + 8] = P32[Sp + 16];
      P32[Sp + 12] = P32[Sp + 20];
      P32[Sp + 16] = _sIB::P32;
      P32[Sp + 20] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
  cQ7:
      R1 = T2902_B_PairingSum.Empty_closure+1;
      Sp = Sp + 20;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cQ1,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQ3,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQ4,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQ7, {}),
 (cQ8,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQd,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQe, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (cQf,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQl,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQm,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cQq, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_$cfromList_entry() //  []
        { info_tbl: [(cQ3,
                      label: block_cQ3_info
                      rep:StackRep [False, False, False, True]),
                     (cQd,
                      label: T2902_B_PairingSum.$fSumPSumab_$cfromList_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                     (cQl,
                      label: block_cQl_info
                      rep:StackRep [False, False, False, False]),
                     (cQq,
                      label: block_cQq_info
                      rep:StackRep [False, False, False, False, False])]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cQd:
          goto cQ1;
      cQ1:
          if ((Sp + -24) < SpLim) goto cQe; else goto cQf;
      cQe:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cQf:
          I32[Sp - 4] = cQ3;
          _sIv::P32 = P32[Sp + 12];
          R1 = _sIv::P32;
          Sp = Sp - 4;
          if (_sIv::P32 & 3 != 0) goto cQ3; else goto cQ4;
      cQ4:
          call (I32[_sIv::P32])(R1) returns to cQ3, args: 4, res: 4, upd: 4;
      cQ3:
          if (R1 & 3 >= 2) goto cQ8; else goto cQ7;
      cQ8:
          I32[Sp] = cQl;
          _sIx::P32 = P32[R1 + 2];
          _sIy::P32 = P32[R1 + 6];
          R1 = _sIx::P32;
          P32[Sp + 16] = _sIy::P32;
          if (_sIx::P32 & 3 != 0) goto cQl; else goto cQm;
      cQm:
          call (I32[_sIx::P32])(R1) returns to cQl, args: 4, res: 4, upd: 4;
      cQl:
          I32[Sp - 4] = cQq;
          P32[Sp - 20] = P32[Sp + 4];
          P32[Sp - 16] = P32[Sp + 8];
          P32[Sp - 12] = P32[Sp + 12];
          P32[Sp - 8] = P32[Sp + 16];
          P32[Sp] = P32[R1 + 7];
          P32[Sp + 16] = P32[R1 + 3];
          Sp = Sp - 20;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQq, args: 20, res: 4, upd: 4;
      cQq:
          P32[Sp] = P32[Sp + 8];
          _sIB::P32 = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp + 12];
          P32[Sp + 8] = P32[Sp + 16];
          P32[Sp + 12] = P32[Sp + 20];
          P32[Sp + 16] = _sIB::P32;
          P32[Sp + 20] = R1;
          call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
      cQ7:
          R1 = T2902_B_PairingSum.Empty_closure+1;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_$cfromList_entry() //  []
        { info_tbl: [(cQ1,
                      label: T2902_B_PairingSum.$fSumPSumab_$cfromList_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                     (cQ3,
                      label: block_cQ3_info
                      rep:StackRep [False, False, False, True]),
                     (cQl,
                      label: block_cQl_info
                      rep:StackRep [False, False, False, False]),
                     (cQq,
                      label: block_cQq_info
                      rep:StackRep [False, False, False, False, False])]
          stack_info: arg_space: 20 updfr_space: Just 4
        }
    {offset
      cQ1:
          if ((Sp + -24) < SpLim) goto cQe; else goto cQf;
      cQe:
          R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
          call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
      cQf:
          I32[Sp - 4] = cQ3;
          _sIv::P32 = P32[Sp + 12];
          R1 = _sIv::P32;
          Sp = Sp - 4;
          if (_sIv::P32 & 3 != 0) goto cQ3; else goto cQ4;
      cQ4:
          call (I32[_sIv::P32])(R1) returns to cQ3, args: 4, res: 4, upd: 4;
      cQ3:
          if (R1 & 3 >= 2) goto cQ8; else goto cQ7;
      cQ8:
          I32[Sp] = cQl;
          _sIx::P32 = P32[R1 + 2];
          _sIy::P32 = P32[R1 + 6];
          R1 = _sIx::P32;
          P32[Sp + 16] = _sIy::P32;
          if (_sIx::P32 & 3 != 0) goto cQl; else goto cQm;
      cQm:
          call (I32[_sIx::P32])(R1) returns to cQl, args: 4, res: 4, upd: 4;
      cQl:
          I32[Sp - 4] = cQq;
          P32[Sp - 20] = P32[Sp + 4];
          P32[Sp - 16] = P32[Sp + 8];
          P32[Sp - 12] = P32[Sp + 12];
          P32[Sp - 8] = P32[Sp + 16];
          P32[Sp] = P32[R1 + 7];
          P32[Sp + 16] = P32[R1 + 3];
          Sp = Sp - 20;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQq, args: 20, res: 4, upd: 4;
      cQq:
          P32[Sp] = P32[Sp + 8];
          _sIB::P32 = P32[Sp + 4];
          P32[Sp + 4] = P32[Sp + 12];
          P32[Sp + 8] = P32[Sp + 16];
          P32[Sp + 12] = P32[Sp + 20];
          P32[Sp + 16] = _sIB::P32;
          P32[Sp + 20] = R1;
          call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
      cQ7:
          R1 = T2902_B_PairingSum.Empty_closure+1;
          Sp = Sp + 20;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cfromList_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cfromList_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cfromList_entry() //  []
         { info_tbl: [(cQ1,
                       label: T2902_B_PairingSum.$fSumPSumab_$cfromList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cQ3,
                       label: block_cQ3_info
                       rep:StackRep [False, False, False, True]),
                      (cQl,
                       label: block_cQl_info
                       rep:StackRep [False, False, False, False]),
                      (cQq,
                       label: block_cQq_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cQ1:
           if ((Sp + -24) < SpLim) goto cQe; else goto cQf;
       cQe:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cQf:
           I32[Sp - 4] = cQ3;
           _sIv::P32 = P32[Sp + 12];
           R1 = _sIv::P32;
           Sp = Sp - 4;
           if (_sIv::P32 & 3 != 0) goto cQ3; else goto cQ4;
       cQ4:
           call (I32[_sIv::P32])(R1) returns to cQ3, args: 4, res: 4, upd: 4;
       cQ3:
           if (R1 & 3 >= 2) goto cQ8; else goto cQ7;
       cQ8:
           I32[Sp] = cQl;
           _sIx::P32 = P32[R1 + 2];
           _sIy::P32 = P32[R1 + 6];
           R1 = _sIx::P32;
           P32[Sp + 16] = _sIy::P32;
           if (_sIx::P32 & 3 != 0) goto cQl; else goto cQm;
       cQm:
           call (I32[_sIx::P32])(R1) returns to cQl, args: 4, res: 4, upd: 4;
       cQl:
           I32[Sp - 4] = cQq;
           P32[Sp - 20] = P32[Sp + 4];
           P32[Sp - 16] = P32[Sp + 8];
           P32[Sp - 12] = P32[Sp + 12];
           P32[Sp - 8] = P32[Sp + 16];
           P32[Sp] = P32[R1 + 7];
           P32[Sp + 16] = P32[R1 + 3];
           Sp = Sp - 20;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQq, args: 20, res: 4, upd: 4;
       cQq:
           P32[Sp] = P32[Sp + 8];
           _sIB::P32 = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp + 12];
           P32[Sp + 8] = P32[Sp + 16];
           P32[Sp + 12] = P32[Sp + 20];
           P32[Sp + 16] = _sIB::P32;
           P32[Sp + 20] = R1;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
       cQ7:
           R1 = T2902_B_PairingSum.Empty_closure+1;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_$cfromList_closure:
         const T2902_B_PairingSum.$fSumPSumab_$cfromList_info;
         const 0;
 },
 T2902_B_PairingSum.$fSumPSumab_$cfromList_entry() //  []
         { info_tbl: [(cQ1,
                       label: T2902_B_PairingSum.$fSumPSumab_$cfromList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} }),
                      (cQ3,
                       label: block_cQ3_info
                       rep:StackRep [False, False, False, True]),
                      (cQl,
                       label: block_cQl_info
                       rep:StackRep [False, False, False, False]),
                      (cQq,
                       label: block_cQq_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 20 updfr_space: Just 4
         }
     {offset
       cQ1:
           if ((Sp + -24) < SpLim) goto cQe; else goto cQf;
       cQe:
           R1 = T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
           call (stg_gc_fun)(R1) args: 20, res: 0, upd: 4;
       cQf:
           I32[Sp - 4] = cQ3;
           _sIv::P32 = P32[Sp + 12];
           R1 = _sIv::P32;
           Sp = Sp - 4;
           if (_sIv::P32 & 3 != 0) goto cQ3; else goto cQ4;
       cQ4:
           call (I32[_sIv::P32])(R1) returns to cQ3, args: 4, res: 4, upd: 4;
       cQ3:
           if (R1 & 3 >= 2) goto cQ8; else goto cQ7;
       cQ8:
           I32[Sp] = cQl;
           _sIx::P32 = P32[R1 + 2];
           _sIy::P32 = P32[R1 + 6];
           R1 = _sIx::P32;
           P32[Sp + 16] = _sIy::P32;
           if (_sIx::P32 & 3 != 0) goto cQl; else goto cQm;
       cQm:
           call (I32[_sIx::P32])(R1) returns to cQl, args: 4, res: 4, upd: 4;
       cQl:
           I32[Sp - 4] = cQq;
           P32[Sp - 20] = P32[Sp + 4];
           P32[Sp - 16] = P32[Sp + 8];
           P32[Sp - 12] = P32[Sp + 12];
           P32[Sp - 8] = P32[Sp + 16];
           P32[Sp] = P32[R1 + 7];
           P32[Sp + 16] = P32[R1 + 3];
           Sp = Sp - 20;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() returns to cQq, args: 20, res: 4, upd: 4;
       cQq:
           P32[Sp] = P32[Sp + 8];
           _sIB::P32 = P32[Sp + 4];
           P32[Sp + 4] = P32[Sp + 12];
           P32[Sp + 8] = P32[Sp + 16];
           P32[Sp + 12] = P32[Sp + 20];
           P32[Sp + 16] = _sIB::P32;
           P32[Sp + 20] = R1;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
       cQ7:
           R1 = T2902_B_PairingSum.Empty_closure+1;
           Sp = Sp + 20;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_closure:
         const T2902_B_PairingSum.$fSumPSumab_info;
         const 0;
 },
 sat_sIL_entry() //  [R1]
         { info_tbl: [(cQW,
                       label: sat_sIL_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cQW:
           _sIL::P32 = R1;
           _B1::P32 = P32[(old + 8)];
           goto cQU;
       cQU:
           if (Sp - <highSp> < SpLim) goto cQX; else goto cQY;
       cQX:
           R1 = _sIL::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cQY:
           _sID::P32 = P32[_sIL::P32 + 3];
           _sIE::P32 = P32[_sIL::P32 + 7];
           _sIF::P32 = P32[_sIL::P32 + 11];
           P32[(old + 20)] = _sID::P32;
           P32[(old + 16)] = _sIE::P32;
           P32[(old + 12)] = _sIF::P32;
           P32[(old + 8)] = _B1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIK_entry() //  [R1]
         { info_tbl: [(cR3,
                       label: sat_sIK_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cR3:
           _sIK::P32 = R1;
           _B1::P32 = P32[(old + 8)];
           goto cR1;
       cR1:
           if (Sp - <highSp> < SpLim) goto cR4; else goto cR5;
       cR4:
           R1 = _sIK::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cR5:
           _sID::P32 = P32[_sIK::P32 + 3];
           _sIE::P32 = P32[_sIK::P32 + 7];
           _sIF::P32 = P32[_sIK::P32 + 11];
           P32[(old + 20)] = _sID::P32;
           P32[(old + 16)] = _sIE::P32;
           P32[(old + 12)] = _sIF::P32;
           P32[(old + 8)] = _B1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIJ_entry() //  [R1]
         { info_tbl: [(cRa,
                       label: sat_sIJ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cRa:
           _sIJ::P32 = R1;
           _B1::P32 = P32[(old + 8)];
           goto cR8;
       cR8:
           if (Sp - <highSp> < SpLim) goto cRb; else goto cRc;
       cRb:
           R1 = _sIJ::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRc:
           _sID::P32 = P32[_sIJ::P32 + 3];
           _sIE::P32 = P32[_sIJ::P32 + 7];
           _sIF::P32 = P32[_sIJ::P32 + 11];
           P32[(old + 20)] = _sID::P32;
           P32[(old + 16)] = _sIE::P32;
           P32[(old + 12)] = _sIF::P32;
           P32[(old + 8)] = _B1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sII_entry() //  [R1]
         { info_tbl: [(cRh,
                       label: sat_sII_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cRh:
           _sII::P32 = R1;
           _B1::P32 = P32[(old + 8)];
           goto cRf;
       cRf:
           if (Sp - <highSp> < SpLim) goto cRi; else goto cRj;
       cRi:
           R1 = _sII::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRj:
           _sID::P32 = P32[_sII::P32 + 3];
           _sIE::P32 = P32[_sII::P32 + 7];
           _sIF::P32 = P32[_sII::P32 + 11];
           P32[(old + 20)] = _sID::P32;
           P32[(old + 16)] = _sIE::P32;
           P32[(old + 12)] = _sIF::P32;
           P32[(old + 8)] = _B1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIH_entry() //  [R1]
         { info_tbl: [(cRo,
                       label: sat_sIH_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 12 updfr_space: Just 4
         }
     {offset
       cRo:
           _sIH::P32 = R1;
           _B2::P32 = P32[(old + 12)];
           _B1::P32 = P32[(old + 8)];
           goto cRm;
       cRm:
           if (Sp - <highSp> < SpLim) goto cRp; else goto cRq;
       cRp:
           R1 = _sIH::P32;
           P32[(old + 12)] = _B2::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
       cRq:
           _sID::P32 = P32[_sIH::P32 + 2];
           _sIE::P32 = P32[_sIH::P32 + 6];
           _sIF::P32 = P32[_sIH::P32 + 10];
           P32[(old + 24)] = _sID::P32;
           P32[(old + 20)] = _sIE::P32;
           P32[(old + 16)] = _sIF::P32;
           P32[(old + 12)] = _B2::P32;
           P32[(old + 8)] = _B1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
     }
 },
 sat_sIG_entry() //  [R1]
         { info_tbl: [(cRv,
                       label: sat_sIG_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cRv:
           _sIG::P32 = R1;
           _B3::P32 = P32[(old + 16)];
           _B2::P32 = P32[(old + 12)];
           _B1::P32 = P32[(old + 8)];
           goto cRt;
       cRt:
           if (Sp - <highSp> < SpLim) goto cRw; else goto cRx;
       cRw:
           R1 = _sIG::P32;
           P32[(old + 16)] = _B3::P32;
           P32[(old + 12)] = _B2::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cRx:
           _sID::P32 = P32[_sIG::P32 + 1];
           _sIE::P32 = P32[_sIG::P32 + 5];
           _sIF::P32 = P32[_sIG::P32 + 9];
           P32[(old + 28)] = _sID::P32;
           P32[(old + 24)] = _sIE::P32;
           P32[(old + 20)] = _sIF::P32;
           P32[(old + 16)] = _B3::P32;
           P32[(old + 12)] = _B2::P32;
           P32[(old + 8)] = _B1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_entry() //  []
         { info_tbl: [(cRz,
                       label: T2902_B_PairingSum.$fSumPSumab_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cRz:
           _sID::P32 = P32[(old + 16)];
           _sIE::P32 = P32[(old + 12)];
           _sIF::P32 = P32[(old + 8)];
           goto cQQ;
       cQQ:
           if (Sp - <highSp> < SpLim) goto cRA; else goto cRB;
       cRB:
           Hp = Hp + 124;
           if (Hp > HpLim) goto cRD; else goto cRC;
       cRD:
           HpAlloc = 124;
           goto cRA;
       cRA:
           R1 = T2902_B_PairingSum.$fSumPSumab_closure;
           P32[(old + 16)] = _sID::P32;
           P32[(old + 12)] = _sIE::P32;
           P32[(old + 8)] = _sIF::P32;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cRC:
           I32[Hp - 120] = sat_sIL_info;
           P32[Hp - 116] = _sID::P32;
           P32[Hp - 112] = _sIE::P32;
           P32[Hp - 108] = _sIF::P32;
           _cQS::P32 = Hp - 119;
           I32[Hp - 104] = sat_sIK_info;
           P32[Hp - 100] = _sID::P32;
           P32[Hp - 96] = _sIE::P32;
           P32[Hp - 92] = _sIF::P32;
           _cQZ::P32 = Hp - 103;
           I32[Hp - 88] = sat_sIJ_info;
           P32[Hp - 84] = _sID::P32;
           P32[Hp - 80] = _sIE::P32;
           P32[Hp - 76] = _sIF::P32;
           _cR6::P32 = Hp - 87;
           I32[Hp - 72] = sat_sII_info;
           P32[Hp - 68] = _sID::P32;
           P32[Hp - 64] = _sIE::P32;
           P32[Hp - 60] = _sIF::P32;
           _cRd::P32 = Hp - 71;
           I32[Hp - 56] = sat_sIH_info;
           P32[Hp - 52] = _sID::P32;
           P32[Hp - 48] = _sIE::P32;
           P32[Hp - 44] = _sIF::P32;
           _cRk::P32 = Hp - 54;
           I32[Hp - 40] = sat_sIG_info;
           P32[Hp - 36] = _sID::P32;
           P32[Hp - 32] = _sIE::P32;
           P32[Hp - 28] = _sIF::P32;
           _cRr::P32 = Hp - 37;
           I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
           P32[Hp - 20] = _cRr::P32;
           P32[Hp - 16] = _cRk::P32;
           P32[Hp - 12] = _cRd::P32;
           P32[Hp - 8] = _cR6::P32;
           P32[Hp - 4] = _cQZ::P32;
           P32[Hp] = _cQS::P32;
           _cRy::P32 = Hp - 23;
           R1 = _cRy::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cQW:
      _sIL::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cQU;
  cQU:
      if (Sp - <highSp> < SpLim) goto cQX; else goto cQY;
  cQX:
      R1 = _sIL::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cQY:
      _sID::P32 = P32[_sIL::P32 + 3];
      _sIE::P32 = P32[_sIL::P32 + 7];
      _sIF::P32 = P32[_sIL::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cQW:
      _sIL::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cQU;
  cQU:
      if (Sp - <highSp> < SpLim) goto cQX; else goto cQY;
  cQX:
      R1 = _sIL::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cQY:
      _sID::P32 = P32[_sIL::P32 + 3];
      _sIE::P32 = P32[_sIL::P32 + 7];
      _sIF::P32 = P32[_sIL::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cQW:
      _sIL::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cQU;
  cQU:
      if (Sp - <highSp> < SpLim) goto cQX; else goto cQY;
  cQX:
      R1 = _sIL::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cQY:
      _sID::P32 = P32[_sIL::P32 + 3];
      _sIE::P32 = P32[_sIL::P32 + 7];
      _sIF::P32 = P32[_sIL::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cQW:
      _sIL::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cQU;
  cQU:
      if (Sp - <highSp> < SpLim) goto cQX; else goto cQY;
  cQX:
      R1 = R1;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cQY:
      _sID::P32 = P32[R1 + 3];
      _sIE::P32 = P32[R1 + 7];
      _sIF::P32 = P32[R1 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cQW:
      _sIL::P32 = R1;
      _B1::P32 = P32[Sp];
      goto cQU;
  cQU:
      if (Sp - 12 < SpLim) goto cQX; else goto cQY;
  cQX:
      R1 = R1;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cQY:
      _sID::P32 = P32[R1 + 3];
      _sIE::P32 = P32[R1 + 7];
      _sIF::P32 = P32[R1 + 11];
      P32[Sp - 12] = _sID::P32;
      P32[Sp - 8] = _sIE::P32;
      P32[Sp - 4] = _sIF::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cQW:
      goto cQU;
  cQU:
      if ((Sp + -12) < SpLim) goto cQX; else goto cQY;
  cQX:
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cQY:
      P32[Sp - 12] = P32[R1 + 3];
      P32[Sp - 8] = P32[R1 + 7];
      P32[Sp - 4] = P32[R1 + 11];
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cQU, {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure}),
 (cQW, {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure}),
 (cQX, {}),
 (cQY, {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure})]



==================== after setInfoTableStackMap ====================
sat_sIL_entry() //  [R1]
        { info_tbl: [(cQW,
                      label: sat_sIL_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cQW:
          goto cQU;
      cQU:
          if ((Sp + -12) < SpLim) goto cQX; else goto cQY;
      cQX:
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cQY:
          P32[Sp - 12] = P32[R1 + 3];
          P32[Sp - 8] = P32[R1 + 7];
          P32[Sp - 4] = P32[R1 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
sat_sIL_entry() //  [R1]
        { info_tbl: [(cQU,
                      label: sat_sIL_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cQU:
          if ((Sp + -12) < SpLim) goto cQX; else goto cQY;
      cQX:
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cQY:
          P32[Sp - 12] = P32[R1 + 3];
          P32[Sp - 8] = P32[R1 + 7];
          P32[Sp - 4] = P32[R1 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cR3:
      _sIK::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cR1;
  cR1:
      if (Sp - <highSp> < SpLim) goto cR4; else goto cR5;
  cR4:
      R1 = _sIK::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cR5:
      _sID::P32 = P32[_sIK::P32 + 3];
      _sIE::P32 = P32[_sIK::P32 + 7];
      _sIF::P32 = P32[_sIK::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cR3:
      _sIK::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cR1;
  cR1:
      if (Sp - <highSp> < SpLim) goto cR4; else goto cR5;
  cR4:
      R1 = _sIK::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cR5:
      _sID::P32 = P32[_sIK::P32 + 3];
      _sIE::P32 = P32[_sIK::P32 + 7];
      _sIF::P32 = P32[_sIK::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cR3:
      _sIK::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cR1;
  cR1:
      if (Sp - <highSp> < SpLim) goto cR4; else goto cR5;
  cR4:
      R1 = _sIK::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cR5:
      _sID::P32 = P32[_sIK::P32 + 3];
      _sIE::P32 = P32[_sIK::P32 + 7];
      _sIF::P32 = P32[_sIK::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cR3:
      _sIK::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cR1;
  cR1:
      if (Sp - <highSp> < SpLim) goto cR4; else goto cR5;
  cR4:
      R1 = R1;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cR5:
      _sID::P32 = P32[R1 + 3];
      _sIE::P32 = P32[R1 + 7];
      _sIF::P32 = P32[R1 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cR3:
      _sIK::P32 = R1;
      _B1::P32 = P32[Sp];
      goto cR1;
  cR1:
      if (Sp - 12 < SpLim) goto cR4; else goto cR5;
  cR4:
      R1 = R1;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cR5:
      _sID::P32 = P32[R1 + 3];
      _sIE::P32 = P32[R1 + 7];
      _sIF::P32 = P32[R1 + 11];
      P32[Sp - 12] = _sID::P32;
      P32[Sp - 8] = _sIE::P32;
      P32[Sp - 4] = _sIF::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cR3:
      goto cR1;
  cR1:
      if ((Sp + -12) < SpLim) goto cR4; else goto cR5;
  cR4:
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cR5:
      P32[Sp - 12] = P32[R1 + 3];
      P32[Sp - 8] = P32[R1 + 7];
      P32[Sp - 4] = P32[R1 + 11];
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cR1, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (cR3, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (cR4, {}),
 (cR5, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure})]



==================== after setInfoTableStackMap ====================
sat_sIK_entry() //  [R1]
        { info_tbl: [(cR3,
                      label: sat_sIK_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cR3:
          goto cR1;
      cR1:
          if ((Sp + -12) < SpLim) goto cR4; else goto cR5;
      cR4:
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cR5:
          P32[Sp - 12] = P32[R1 + 3];
          P32[Sp - 8] = P32[R1 + 7];
          P32[Sp - 4] = P32[R1 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
sat_sIK_entry() //  [R1]
        { info_tbl: [(cR1,
                      label: sat_sIK_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cR1:
          if ((Sp + -12) < SpLim) goto cR4; else goto cR5;
      cR4:
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cR5:
          P32[Sp - 12] = P32[R1 + 3];
          P32[Sp - 8] = P32[R1 + 7];
          P32[Sp - 4] = P32[R1 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cRa:
      _sIJ::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cR8;
  cR8:
      if (Sp - <highSp> < SpLim) goto cRb; else goto cRc;
  cRb:
      R1 = _sIJ::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRc:
      _sID::P32 = P32[_sIJ::P32 + 3];
      _sIE::P32 = P32[_sIJ::P32 + 7];
      _sIF::P32 = P32[_sIJ::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cRa:
      _sIJ::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cR8;
  cR8:
      if (Sp - <highSp> < SpLim) goto cRb; else goto cRc;
  cRb:
      R1 = _sIJ::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRc:
      _sID::P32 = P32[_sIJ::P32 + 3];
      _sIE::P32 = P32[_sIJ::P32 + 7];
      _sIF::P32 = P32[_sIJ::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cRa:
      _sIJ::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cR8;
  cR8:
      if (Sp - <highSp> < SpLim) goto cRb; else goto cRc;
  cRb:
      R1 = _sIJ::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRc:
      _sID::P32 = P32[_sIJ::P32 + 3];
      _sIE::P32 = P32[_sIJ::P32 + 7];
      _sIF::P32 = P32[_sIJ::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cRa:
      _sIJ::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cR8;
  cR8:
      if (Sp - <highSp> < SpLim) goto cRb; else goto cRc;
  cRb:
      R1 = R1;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRc:
      _sID::P32 = P32[R1 + 3];
      _sIE::P32 = P32[R1 + 7];
      _sIF::P32 = P32[R1 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cRa:
      _sIJ::P32 = R1;
      _B1::P32 = P32[Sp];
      goto cR8;
  cR8:
      if (Sp - 12 < SpLim) goto cRb; else goto cRc;
  cRb:
      R1 = R1;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRc:
      _sID::P32 = P32[R1 + 3];
      _sIE::P32 = P32[R1 + 7];
      _sIF::P32 = P32[R1 + 11];
      P32[Sp - 12] = _sID::P32;
      P32[Sp - 8] = _sIE::P32;
      P32[Sp - 4] = _sIF::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cRa:
      goto cR8;
  cR8:
      if ((Sp + -12) < SpLim) goto cRb; else goto cRc;
  cRb:
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRc:
      P32[Sp - 12] = P32[R1 + 3];
      P32[Sp - 8] = P32[R1 + 7];
      P32[Sp - 4] = P32[R1 + 11];
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cR8, {T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure}),
 (cRa, {T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure}),
 (cRb, {}),
 (cRc, {T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure})]



==================== after setInfoTableStackMap ====================
sat_sIJ_entry() //  [R1]
        { info_tbl: [(cRa,
                      label: sat_sIJ_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cRa:
          goto cR8;
      cR8:
          if ((Sp + -12) < SpLim) goto cRb; else goto cRc;
      cRb:
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cRc:
          P32[Sp - 12] = P32[R1 + 3];
          P32[Sp - 8] = P32[R1 + 7];
          P32[Sp - 4] = P32[R1 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
sat_sIJ_entry() //  [R1]
        { info_tbl: [(cR8,
                      label: sat_sIJ_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cR8:
          if ((Sp + -12) < SpLim) goto cRb; else goto cRc;
      cRb:
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cRc:
          P32[Sp - 12] = P32[R1 + 3];
          P32[Sp - 8] = P32[R1 + 7];
          P32[Sp - 4] = P32[R1 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cRh:
      _sII::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cRf;
  cRf:
      if (Sp - <highSp> < SpLim) goto cRi; else goto cRj;
  cRi:
      R1 = _sII::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRj:
      _sID::P32 = P32[_sII::P32 + 3];
      _sIE::P32 = P32[_sII::P32 + 7];
      _sIF::P32 = P32[_sII::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cRh:
      _sII::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cRf;
  cRf:
      if (Sp - <highSp> < SpLim) goto cRi; else goto cRj;
  cRi:
      R1 = _sII::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRj:
      _sID::P32 = P32[_sII::P32 + 3];
      _sIE::P32 = P32[_sII::P32 + 7];
      _sIF::P32 = P32[_sII::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cRh:
      _sII::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cRf;
  cRf:
      if (Sp - <highSp> < SpLim) goto cRi; else goto cRj;
  cRi:
      R1 = _sII::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRj:
      _sID::P32 = P32[_sII::P32 + 3];
      _sIE::P32 = P32[_sII::P32 + 7];
      _sIF::P32 = P32[_sII::P32 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cRh:
      _sII::P32 = R1;
      _B1::P32 = P32[(old + 8)];
      goto cRf;
  cRf:
      if (Sp - <highSp> < SpLim) goto cRi; else goto cRj;
  cRi:
      R1 = R1;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRj:
      _sID::P32 = P32[R1 + 3];
      _sIE::P32 = P32[R1 + 7];
      _sIF::P32 = P32[R1 + 11];
      P32[(old + 20)] = _sID::P32;
      P32[(old + 16)] = _sIE::P32;
      P32[(old + 12)] = _sIF::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cRh:
      _sII::P32 = R1;
      _B1::P32 = P32[Sp];
      goto cRf;
  cRf:
      if (Sp - 12 < SpLim) goto cRi; else goto cRj;
  cRi:
      R1 = R1;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRj:
      _sID::P32 = P32[R1 + 3];
      _sIE::P32 = P32[R1 + 7];
      _sIF::P32 = P32[R1 + 11];
      P32[Sp - 12] = _sID::P32;
      P32[Sp - 8] = _sIE::P32;
      P32[Sp - 4] = _sIF::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cRh:
      goto cRf;
  cRf:
      if ((Sp + -12) < SpLim) goto cRi; else goto cRj;
  cRi:
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  cRj:
      P32[Sp - 12] = P32[R1 + 3];
      P32[Sp - 8] = P32[R1 + 7];
      P32[Sp - 4] = P32[R1 + 11];
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cRf, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cRh, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure}),
 (cRi, {}),
 (cRj, {T2902_B_PairingSum.$fSumPSumab_$cunions_closure})]



==================== after setInfoTableStackMap ====================
sat_sII_entry() //  [R1]
        { info_tbl: [(cRh,
                      label: sat_sII_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cRh:
          goto cRf;
      cRf:
          if ((Sp + -12) < SpLim) goto cRi; else goto cRj;
      cRi:
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cRj:
          P32[Sp - 12] = P32[R1 + 3];
          P32[Sp - 8] = P32[R1 + 7];
          P32[Sp - 4] = P32[R1 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
sat_sII_entry() //  [R1]
        { info_tbl: [(cRf,
                      label: sat_sII_info
                      rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      cRf:
          if ((Sp + -12) < SpLim) goto cRi; else goto cRj;
      cRi:
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      cRj:
          P32[Sp - 12] = P32[R1 + 3];
          P32[Sp - 8] = P32[R1 + 7];
          P32[Sp - 4] = P32[R1 + 11];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cRo:
      _sIH::P32 = R1;
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRm;
  cRm:
      if (Sp - <highSp> < SpLim) goto cRp; else goto cRq;
  cRp:
      R1 = _sIH::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  cRq:
      _sID::P32 = P32[_sIH::P32 + 2];
      _sIE::P32 = P32[_sIH::P32 + 6];
      _sIF::P32 = P32[_sIH::P32 + 10];
      P32[(old + 24)] = _sID::P32;
      P32[(old + 20)] = _sIE::P32;
      P32[(old + 16)] = _sIF::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cRo:
      _sIH::P32 = R1;
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRm;
  cRm:
      if (Sp - <highSp> < SpLim) goto cRp; else goto cRq;
  cRp:
      R1 = _sIH::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  cRq:
      _sID::P32 = P32[_sIH::P32 + 2];
      _sIE::P32 = P32[_sIH::P32 + 6];
      _sIF::P32 = P32[_sIH::P32 + 10];
      P32[(old + 24)] = _sID::P32;
      P32[(old + 20)] = _sIE::P32;
      P32[(old + 16)] = _sIF::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cRo:
      _sIH::P32 = R1;
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRm;
  cRm:
      if (Sp - <highSp> < SpLim) goto cRp; else goto cRq;
  cRp:
      R1 = _sIH::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  cRq:
      _sID::P32 = P32[_sIH::P32 + 2];
      _sIE::P32 = P32[_sIH::P32 + 6];
      _sIF::P32 = P32[_sIH::P32 + 10];
      P32[(old + 24)] = _sID::P32;
      P32[(old + 20)] = _sIE::P32;
      P32[(old + 16)] = _sIF::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cRo:
      _sIH::P32 = R1;
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRm;
  cRm:
      if (Sp - <highSp> < SpLim) goto cRp; else goto cRq;
  cRp:
      R1 = R1;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  cRq:
      _sID::P32 = P32[R1 + 2];
      _sIE::P32 = P32[R1 + 6];
      _sIF::P32 = P32[R1 + 10];
      P32[(old + 24)] = _sID::P32;
      P32[(old + 20)] = _sIE::P32;
      P32[(old + 16)] = _sIF::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cRo:
      _sIH::P32 = R1;
      _B2::P32 = P32[Sp];
      _B1::P32 = P32[Sp + 4];
      goto cRm;
  cRm:
      if (Sp - 12 < SpLim) goto cRp; else goto cRq;
  cRp:
      R1 = R1;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  cRq:
      _sID::P32 = P32[R1 + 2];
      _sIE::P32 = P32[R1 + 6];
      _sIF::P32 = P32[R1 + 10];
      P32[Sp - 12] = _sID::P32;
      P32[Sp - 8] = _sIE::P32;
      P32[Sp - 4] = _sIF::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cRo:
      goto cRm;
  cRm:
      if ((Sp + -12) < SpLim) goto cRp; else goto cRq;
  cRp:
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  cRq:
      P32[Sp - 12] = P32[R1 + 2];
      P32[Sp - 8] = P32[R1 + 6];
      P32[Sp - 4] = P32[R1 + 10];
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cRm, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure}),
 (cRo, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure}), (cRp, {}),
 (cRq, {T2902_B_PairingSum.$fSumPSumab_$cunion_closure})]



==================== after setInfoTableStackMap ====================
sat_sIH_entry() //  [R1]
        { info_tbl: [(cRo,
                      label: sat_sIH_info
                      rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
          stack_info: arg_space: 12 updfr_space: Just 4
        }
    {offset
      cRo:
          goto cRm;
      cRm:
          if ((Sp + -12) < SpLim) goto cRp; else goto cRq;
      cRp:
          call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
      cRq:
          P32[Sp - 12] = P32[R1 + 2];
          P32[Sp - 8] = P32[R1 + 6];
          P32[Sp - 4] = P32[R1 + 10];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
sat_sIH_entry() //  [R1]
        { info_tbl: [(cRm,
                      label: sat_sIH_info
                      rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
          stack_info: arg_space: 12 updfr_space: Just 4
        }
    {offset
      cRm:
          if ((Sp + -12) < SpLim) goto cRp; else goto cRq;
      cRp:
          call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
      cRq:
          P32[Sp - 12] = P32[R1 + 2];
          P32[Sp - 8] = P32[R1 + 6];
          P32[Sp - 4] = P32[R1 + 10];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cRv:
      _sIG::P32 = R1;
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRt;
  cRt:
      if (Sp - <highSp> < SpLim) goto cRw; else goto cRx;
  cRw:
      R1 = _sIG::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRx:
      _sID::P32 = P32[_sIG::P32 + 1];
      _sIE::P32 = P32[_sIG::P32 + 5];
      _sIF::P32 = P32[_sIG::P32 + 9];
      P32[(old + 28)] = _sID::P32;
      P32[(old + 24)] = _sIE::P32;
      P32[(old + 20)] = _sIF::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cRv:
      _sIG::P32 = R1;
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRt;
  cRt:
      if (Sp - <highSp> < SpLim) goto cRw; else goto cRx;
  cRw:
      R1 = _sIG::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRx:
      _sID::P32 = P32[_sIG::P32 + 1];
      _sIE::P32 = P32[_sIG::P32 + 5];
      _sIF::P32 = P32[_sIG::P32 + 9];
      P32[(old + 28)] = _sID::P32;
      P32[(old + 24)] = _sIE::P32;
      P32[(old + 20)] = _sIF::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cRv:
      _sIG::P32 = R1;
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRt;
  cRt:
      if (Sp - <highSp> < SpLim) goto cRw; else goto cRx;
  cRw:
      R1 = _sIG::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRx:
      _sID::P32 = P32[_sIG::P32 + 1];
      _sIE::P32 = P32[_sIG::P32 + 5];
      _sIF::P32 = P32[_sIG::P32 + 9];
      P32[(old + 28)] = _sID::P32;
      P32[(old + 24)] = _sIE::P32;
      P32[(old + 20)] = _sIF::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cRv:
      _sIG::P32 = R1;
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cRt;
  cRt:
      if (Sp - <highSp> < SpLim) goto cRw; else goto cRx;
  cRw:
      R1 = R1;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRx:
      _sID::P32 = P32[R1 + 1];
      _sIE::P32 = P32[R1 + 5];
      _sIF::P32 = P32[R1 + 9];
      P32[(old + 28)] = _sID::P32;
      P32[(old + 24)] = _sIE::P32;
      P32[(old + 20)] = _sIF::P32;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cRv:
      _sIG::P32 = R1;
      _B3::P32 = P32[Sp];
      _B2::P32 = P32[Sp + 4];
      _B1::P32 = P32[Sp + 8];
      goto cRt;
  cRt:
      if (Sp - 12 < SpLim) goto cRw; else goto cRx;
  cRw:
      R1 = R1;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRx:
      _sID::P32 = P32[R1 + 1];
      _sIE::P32 = P32[R1 + 5];
      _sIF::P32 = P32[R1 + 9];
      P32[Sp - 12] = _sID::P32;
      P32[Sp - 8] = _sIE::P32;
      P32[Sp - 4] = _sIF::P32;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cRv:
      goto cRt;
  cRt:
      if ((Sp + -12) < SpLim) goto cRw; else goto cRx;
  cRw:
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRx:
      P32[Sp - 12] = P32[R1 + 1];
      P32[Sp - 8] = P32[R1 + 5];
      P32[Sp - 4] = P32[R1 + 9];
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cRt, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cRv, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure}),
 (cRw, {}),
 (cRx, {T2902_B_PairingSum.$fSumPSumab_$cinsert_closure})]



==================== after setInfoTableStackMap ====================
sat_sIG_entry() //  [R1]
        { info_tbl: [(cRv,
                      label: sat_sIG_info
                      rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      cRv:
          goto cRt;
      cRt:
          if ((Sp + -12) < SpLim) goto cRw; else goto cRx;
      cRw:
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      cRx:
          P32[Sp - 12] = P32[R1 + 1];
          P32[Sp - 8] = P32[R1 + 5];
          P32[Sp - 4] = P32[R1 + 9];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
sat_sIG_entry() //  [R1]
        { info_tbl: [(cRt,
                      label: sat_sIG_info
                      rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      cRt:
          if ((Sp + -12) < SpLim) goto cRw; else goto cRx;
      cRw:
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      cRx:
          P32[Sp - 12] = P32[R1 + 1];
          P32[Sp - 8] = P32[R1 + 5];
          P32[Sp - 4] = P32[R1 + 9];
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cRz:
      _sID::P32 = P32[(old + 16)];
      _sIE::P32 = P32[(old + 12)];
      _sIF::P32 = P32[(old + 8)];
      goto cQQ;
  cQQ:
      if (Sp - <highSp> < SpLim) goto cRA; else goto cRB;
  cRB:
      Hp = Hp + 124;
      if (Hp > HpLim) goto cRD; else goto cRC;
  cRD:
      HpAlloc = 124;
      goto cRA;
  cRA:
      R1 = T2902_B_PairingSum.$fSumPSumab_closure;
      P32[(old + 16)] = _sID::P32;
      P32[(old + 12)] = _sIE::P32;
      P32[(old + 8)] = _sIF::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRC:
      I32[Hp - 120] = sat_sIL_info;
      P32[Hp - 116] = _sID::P32;
      P32[Hp - 112] = _sIE::P32;
      P32[Hp - 108] = _sIF::P32;
      _cQS::P32 = Hp - 119;
      I32[Hp - 104] = sat_sIK_info;
      P32[Hp - 100] = _sID::P32;
      P32[Hp - 96] = _sIE::P32;
      P32[Hp - 92] = _sIF::P32;
      _cQZ::P32 = Hp - 103;
      I32[Hp - 88] = sat_sIJ_info;
      P32[Hp - 84] = _sID::P32;
      P32[Hp - 80] = _sIE::P32;
      P32[Hp - 76] = _sIF::P32;
      _cR6::P32 = Hp - 87;
      I32[Hp - 72] = sat_sII_info;
      P32[Hp - 68] = _sID::P32;
      P32[Hp - 64] = _sIE::P32;
      P32[Hp - 60] = _sIF::P32;
      _cRd::P32 = Hp - 71;
      I32[Hp - 56] = sat_sIH_info;
      P32[Hp - 52] = _sID::P32;
      P32[Hp - 48] = _sIE::P32;
      P32[Hp - 44] = _sIF::P32;
      _cRk::P32 = Hp - 54;
      I32[Hp - 40] = sat_sIG_info;
      P32[Hp - 36] = _sID::P32;
      P32[Hp - 32] = _sIE::P32;
      P32[Hp - 28] = _sIF::P32;
      _cRr::P32 = Hp - 37;
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _cRr::P32;
      P32[Hp - 16] = _cRk::P32;
      P32[Hp - 12] = _cRd::P32;
      P32[Hp - 8] = _cR6::P32;
      P32[Hp - 4] = _cQZ::P32;
      P32[Hp] = _cQS::P32;
      _cRy::P32 = Hp - 23;
      R1 = _cRy::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cRz:
      _sID::P32 = P32[(old + 16)];
      _sIE::P32 = P32[(old + 12)];
      _sIF::P32 = P32[(old + 8)];
      goto cQQ;
  cQQ:
      if (Sp - <highSp> < SpLim) goto cRA; else goto cRB;
  cRB:
      Hp = Hp + 124;
      if (Hp > HpLim) goto cRD; else goto cRC;
  cRD:
      HpAlloc = 124;
      goto cRA;
  cRA:
      R1 = T2902_B_PairingSum.$fSumPSumab_closure;
      P32[(old + 16)] = _sID::P32;
      P32[(old + 12)] = _sIE::P32;
      P32[(old + 8)] = _sIF::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRC:
      I32[Hp - 120] = sat_sIL_info;
      P32[Hp - 116] = _sID::P32;
      P32[Hp - 112] = _sIE::P32;
      P32[Hp - 108] = _sIF::P32;
      _cQS::P32 = Hp - 119;
      I32[Hp - 104] = sat_sIK_info;
      P32[Hp - 100] = _sID::P32;
      P32[Hp - 96] = _sIE::P32;
      P32[Hp - 92] = _sIF::P32;
      _cQZ::P32 = Hp - 103;
      I32[Hp - 88] = sat_sIJ_info;
      P32[Hp - 84] = _sID::P32;
      P32[Hp - 80] = _sIE::P32;
      P32[Hp - 76] = _sIF::P32;
      _cR6::P32 = Hp - 87;
      I32[Hp - 72] = sat_sII_info;
      P32[Hp - 68] = _sID::P32;
      P32[Hp - 64] = _sIE::P32;
      P32[Hp - 60] = _sIF::P32;
      _cRd::P32 = Hp - 71;
      I32[Hp - 56] = sat_sIH_info;
      P32[Hp - 52] = _sID::P32;
      P32[Hp - 48] = _sIE::P32;
      P32[Hp - 44] = _sIF::P32;
      _cRk::P32 = Hp - 54;
      I32[Hp - 40] = sat_sIG_info;
      P32[Hp - 36] = _sID::P32;
      P32[Hp - 32] = _sIE::P32;
      P32[Hp - 28] = _sIF::P32;
      _cRr::P32 = Hp - 37;
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _cRr::P32;
      P32[Hp - 16] = _cRk::P32;
      P32[Hp - 12] = _cRd::P32;
      P32[Hp - 8] = _cR6::P32;
      P32[Hp - 4] = _cQZ::P32;
      P32[Hp] = _cQS::P32;
      _cRy::P32 = Hp - 23;
      R1 = _cRy::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cRz:
      _sID::P32 = P32[(old + 16)];
      _sIE::P32 = P32[(old + 12)];
      _sIF::P32 = P32[(old + 8)];
      goto cQQ;
  cQQ:
      if (Sp - <highSp> < SpLim) goto cRA; else goto cRB;
  cRB:
      Hp = Hp + 124;
      if (Hp > HpLim) goto cRD; else goto cRC;
  cRD:
      HpAlloc = 124;
      goto cRA;
  cRA:
      R1 = T2902_B_PairingSum.$fSumPSumab_closure;
      P32[(old + 16)] = _sID::P32;
      P32[(old + 12)] = _sIE::P32;
      P32[(old + 8)] = _sIF::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRC:
      I32[Hp - 120] = sat_sIL_info;
      P32[Hp - 116] = _sID::P32;
      P32[Hp - 112] = _sIE::P32;
      P32[Hp - 108] = _sIF::P32;
      _cQS::P32 = Hp - 119;
      I32[Hp - 104] = sat_sIK_info;
      P32[Hp - 100] = _sID::P32;
      P32[Hp - 96] = _sIE::P32;
      P32[Hp - 92] = _sIF::P32;
      _cQZ::P32 = Hp - 103;
      I32[Hp - 88] = sat_sIJ_info;
      P32[Hp - 84] = _sID::P32;
      P32[Hp - 80] = _sIE::P32;
      P32[Hp - 76] = _sIF::P32;
      _cR6::P32 = Hp - 87;
      I32[Hp - 72] = sat_sII_info;
      P32[Hp - 68] = _sID::P32;
      P32[Hp - 64] = _sIE::P32;
      P32[Hp - 60] = _sIF::P32;
      _cRd::P32 = Hp - 71;
      I32[Hp - 56] = sat_sIH_info;
      P32[Hp - 52] = _sID::P32;
      P32[Hp - 48] = _sIE::P32;
      P32[Hp - 44] = _sIF::P32;
      _cRk::P32 = Hp - 54;
      I32[Hp - 40] = sat_sIG_info;
      P32[Hp - 36] = _sID::P32;
      P32[Hp - 32] = _sIE::P32;
      P32[Hp - 28] = _sIF::P32;
      _cRr::P32 = Hp - 37;
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _cRr::P32;
      P32[Hp - 16] = _cRk::P32;
      P32[Hp - 12] = _cRd::P32;
      P32[Hp - 8] = _cR6::P32;
      P32[Hp - 4] = _cQZ::P32;
      P32[Hp] = _cQS::P32;
      _cRy::P32 = Hp - 23;
      R1 = _cRy::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cRz:
      _sID::P32 = P32[(old + 16)];
      _sIE::P32 = P32[(old + 12)];
      _sIF::P32 = P32[(old + 8)];
      goto cQQ;
  cQQ:
      if (Sp - <highSp> < SpLim) goto cRA; else goto cRB;
  cRB:
      Hp = Hp + 124;
      if (Hp > HpLim) goto cRD; else goto cRC;
  cRD:
      HpAlloc = 124;
      goto cRA;
  cRA:
      R1 = T2902_B_PairingSum.$fSumPSumab_closure;
      P32[(old + 16)] = _sID::P32;
      P32[(old + 12)] = _sIE::P32;
      P32[(old + 8)] = _sIF::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRC:
      I32[Hp - 120] = sat_sIL_info;
      P32[Hp - 116] = _sID::P32;
      P32[Hp - 112] = _sIE::P32;
      P32[Hp - 108] = _sIF::P32;
      _cQS::P32 = Hp - 119;
      I32[Hp - 104] = sat_sIK_info;
      P32[Hp - 100] = _sID::P32;
      P32[Hp - 96] = _sIE::P32;
      P32[Hp - 92] = _sIF::P32;
      _cQZ::P32 = Hp - 103;
      I32[Hp - 88] = sat_sIJ_info;
      P32[Hp - 84] = _sID::P32;
      P32[Hp - 80] = _sIE::P32;
      P32[Hp - 76] = _sIF::P32;
      _cR6::P32 = Hp - 87;
      I32[Hp - 72] = sat_sII_info;
      P32[Hp - 68] = _sID::P32;
      P32[Hp - 64] = _sIE::P32;
      P32[Hp - 60] = _sIF::P32;
      _cRd::P32 = Hp - 71;
      I32[Hp - 56] = sat_sIH_info;
      P32[Hp - 52] = _sID::P32;
      P32[Hp - 48] = _sIE::P32;
      P32[Hp - 44] = _sIF::P32;
      _cRk::P32 = Hp - 54;
      I32[Hp - 40] = sat_sIG_info;
      P32[Hp - 36] = _sID::P32;
      P32[Hp - 32] = _sIE::P32;
      P32[Hp - 28] = _sIF::P32;
      _cRr::P32 = Hp - 37;
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _cRr::P32;
      P32[Hp - 16] = _cRk::P32;
      P32[Hp - 12] = _cRd::P32;
      P32[Hp - 8] = _cR6::P32;
      P32[Hp - 4] = _cQZ::P32;
      P32[Hp] = _cQS::P32;
      _cRy::P32 = Hp - 23;
      R1 = _cRy::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cRz:
      _sID::P32 = P32[Sp];
      _sIE::P32 = P32[Sp + 4];
      _sIF::P32 = P32[Sp + 8];
      goto cQQ;
  cQQ:
      goto cRB;
  cRB:
      Hp = Hp + 124;
      if (Hp > HpLim) goto cRD; else goto cRC;
  cRD:
      HpAlloc = 124;
      goto cRA;
  cRA:
      R1 = T2902_B_PairingSum.$fSumPSumab_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRC:
      I32[Hp - 120] = sat_sIL_info;
      P32[Hp - 116] = _sID::P32;
      P32[Hp - 112] = _sIE::P32;
      P32[Hp - 108] = _sIF::P32;
      _cQS::P32 = Hp - 119;
      I32[Hp - 104] = sat_sIK_info;
      P32[Hp - 100] = _sID::P32;
      P32[Hp - 96] = _sIE::P32;
      P32[Hp - 92] = _sIF::P32;
      _cQZ::P32 = Hp - 103;
      I32[Hp - 88] = sat_sIJ_info;
      P32[Hp - 84] = _sID::P32;
      P32[Hp - 80] = _sIE::P32;
      P32[Hp - 76] = _sIF::P32;
      _cR6::P32 = Hp - 87;
      I32[Hp - 72] = sat_sII_info;
      P32[Hp - 68] = _sID::P32;
      P32[Hp - 64] = _sIE::P32;
      P32[Hp - 60] = _sIF::P32;
      _cRd::P32 = Hp - 71;
      I32[Hp - 56] = sat_sIH_info;
      P32[Hp - 52] = _sID::P32;
      P32[Hp - 48] = _sIE::P32;
      P32[Hp - 44] = _sIF::P32;
      _cRk::P32 = Hp - 54;
      I32[Hp - 40] = sat_sIG_info;
      P32[Hp - 36] = _sID::P32;
      P32[Hp - 32] = _sIE::P32;
      P32[Hp - 28] = _sIF::P32;
      _cRr::P32 = Hp - 37;
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = _cRr::P32;
      P32[Hp - 16] = _cRk::P32;
      P32[Hp - 12] = _cRd::P32;
      P32[Hp - 8] = _cR6::P32;
      P32[Hp - 4] = _cQZ::P32;
      P32[Hp] = _cQS::P32;
      _cRy::P32 = Hp - 23;
      R1 = _cRy::P32;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cRz:
      goto cQQ;
  cQQ:
      goto cRB;
  cRB:
      Hp = Hp + 124;
      if (Hp > HpLim) goto cRD; else goto cRC;
  cRD:
      HpAlloc = 124;
      goto cRA;
  cRA:
      R1 = T2902_B_PairingSum.$fSumPSumab_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cRC:
      I32[Hp - 120] = sat_sIL_info;
      _sID::P32 = P32[Sp];
      P32[Hp - 116] = _sID::P32;
      _sIE::P32 = P32[Sp + 4];
      P32[Hp - 112] = _sIE::P32;
      _sIF::P32 = P32[Sp + 8];
      P32[Hp - 108] = _sIF::P32;
      I32[Hp - 104] = sat_sIK_info;
      P32[Hp - 100] = _sID::P32;
      P32[Hp - 96] = _sIE::P32;
      P32[Hp - 92] = _sIF::P32;
      I32[Hp - 88] = sat_sIJ_info;
      P32[Hp - 84] = _sID::P32;
      P32[Hp - 80] = _sIE::P32;
      P32[Hp - 76] = _sIF::P32;
      I32[Hp - 72] = sat_sII_info;
      P32[Hp - 68] = _sID::P32;
      P32[Hp - 64] = _sIE::P32;
      P32[Hp - 60] = _sIF::P32;
      I32[Hp - 56] = sat_sIH_info;
      P32[Hp - 52] = _sID::P32;
      P32[Hp - 48] = _sIE::P32;
      P32[Hp - 44] = _sIF::P32;
      I32[Hp - 40] = sat_sIG_info;
      P32[Hp - 36] = _sID::P32;
      P32[Hp - 32] = _sIE::P32;
      P32[Hp - 28] = _sIF::P32;
      I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
      P32[Hp - 20] = Hp - 37;
      P32[Hp - 16] = Hp - 54;
      P32[Hp - 12] = Hp - 71;
      P32[Hp - 8] = Hp - 87;
      P32[Hp - 4] = Hp - 103;
      P32[Hp] = Hp - 119;
      R1 = Hp - 23;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cQQ,
  {T2902_B_PairingSum.$fSumPSumab_closure, sat_sIG_closure,
   sat_sIH_closure, sat_sII_closure, sat_sIJ_closure, sat_sIK_closure,
   sat_sIL_closure}),
 (cRz,
  {T2902_B_PairingSum.$fSumPSumab_closure, sat_sIG_closure,
   sat_sIH_closure, sat_sII_closure, sat_sIJ_closure, sat_sIK_closure,
   sat_sIL_closure}),
 (cRA, {T2902_B_PairingSum.$fSumPSumab_closure}),
 (cRB,
  {T2902_B_PairingSum.$fSumPSumab_closure, sat_sIG_closure,
   sat_sIH_closure, sat_sII_closure, sat_sIJ_closure, sat_sIK_closure,
   sat_sIL_closure}),
 (cRC,
  {sat_sIG_closure, sat_sIH_closure, sat_sII_closure,
   sat_sIJ_closure, sat_sIK_closure, sat_sIL_closure}),
 (cRD, {T2902_B_PairingSum.$fSumPSumab_closure})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.$fSumPSumab_entry() //  []
        { info_tbl: [(cRz,
                      label: T2902_B_PairingSum.$fSumPSumab_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      cRz:
          goto cQQ;
      cQQ:
          goto cRB;
      cRB:
          Hp = Hp + 124;
          if (Hp > HpLim) goto cRD; else goto cRC;
      cRD:
          HpAlloc = 124;
          goto cRA;
      cRA:
          R1 = T2902_B_PairingSum.$fSumPSumab_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      cRC:
          I32[Hp - 120] = sat_sIL_info;
          _sID::P32 = P32[Sp];
          P32[Hp - 116] = _sID::P32;
          _sIE::P32 = P32[Sp + 4];
          P32[Hp - 112] = _sIE::P32;
          _sIF::P32 = P32[Sp + 8];
          P32[Hp - 108] = _sIF::P32;
          I32[Hp - 104] = sat_sIK_info;
          P32[Hp - 100] = _sID::P32;
          P32[Hp - 96] = _sIE::P32;
          P32[Hp - 92] = _sIF::P32;
          I32[Hp - 88] = sat_sIJ_info;
          P32[Hp - 84] = _sID::P32;
          P32[Hp - 80] = _sIE::P32;
          P32[Hp - 76] = _sIF::P32;
          I32[Hp - 72] = sat_sII_info;
          P32[Hp - 68] = _sID::P32;
          P32[Hp - 64] = _sIE::P32;
          P32[Hp - 60] = _sIF::P32;
          I32[Hp - 56] = sat_sIH_info;
          P32[Hp - 52] = _sID::P32;
          P32[Hp - 48] = _sIE::P32;
          P32[Hp - 44] = _sIF::P32;
          I32[Hp - 40] = sat_sIG_info;
          P32[Hp - 36] = _sID::P32;
          P32[Hp - 32] = _sIE::P32;
          P32[Hp - 28] = _sIF::P32;
          I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
          P32[Hp - 20] = Hp - 37;
          P32[Hp - 16] = Hp - 54;
          P32[Hp - 12] = Hp - 71;
          P32[Hp - 8] = Hp - 87;
          P32[Hp - 4] = Hp - 103;
          P32[Hp] = Hp - 119;
          R1 = Hp - 23;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.$fSumPSumab_entry() //  []
        { info_tbl: [(cRB,
                      label: T2902_B_PairingSum.$fSumPSumab_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      cRB:
          Hp = Hp + 124;
          if (Hp > HpLim) goto cRD; else goto cRC;
      cRD:
          HpAlloc = 124;
          goto cRA;
      cRA:
          R1 = T2902_B_PairingSum.$fSumPSumab_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      cRC:
          I32[Hp - 120] = sat_sIL_info;
          _sID::P32 = P32[Sp];
          P32[Hp - 116] = _sID::P32;
          _sIE::P32 = P32[Sp + 4];
          P32[Hp - 112] = _sIE::P32;
          _sIF::P32 = P32[Sp + 8];
          P32[Hp - 108] = _sIF::P32;
          I32[Hp - 104] = sat_sIK_info;
          P32[Hp - 100] = _sID::P32;
          P32[Hp - 96] = _sIE::P32;
          P32[Hp - 92] = _sIF::P32;
          I32[Hp - 88] = sat_sIJ_info;
          P32[Hp - 84] = _sID::P32;
          P32[Hp - 80] = _sIE::P32;
          P32[Hp - 76] = _sIF::P32;
          I32[Hp - 72] = sat_sII_info;
          P32[Hp - 68] = _sID::P32;
          P32[Hp - 64] = _sIE::P32;
          P32[Hp - 60] = _sIF::P32;
          I32[Hp - 56] = sat_sIH_info;
          P32[Hp - 52] = _sID::P32;
          P32[Hp - 48] = _sIE::P32;
          P32[Hp - 44] = _sIF::P32;
          I32[Hp - 40] = sat_sIG_info;
          P32[Hp - 36] = _sID::P32;
          P32[Hp - 32] = _sIE::P32;
          P32[Hp - 28] = _sIF::P32;
          I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
          P32[Hp - 20] = Hp - 37;
          P32[Hp - 16] = Hp - 54;
          P32[Hp - 12] = Hp - 71;
          P32[Hp - 8] = Hp - 87;
          P32[Hp - 4] = Hp - 103;
          P32[Hp] = Hp - 119;
          R1 = Hp - 23;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_closure:
         const T2902_B_PairingSum.$fSumPSumab_info;
         const 0;
 },
 sat_sIL_entry() //  [R1]
         { info_tbl: [(cQU,
                       label: sat_sIL_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cQU:
           if ((Sp + -12) < SpLim) goto cQX; else goto cQY;
       cQX:
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cQY:
           P32[Sp - 12] = P32[R1 + 3];
           P32[Sp - 8] = P32[R1 + 7];
           P32[Sp - 4] = P32[R1 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIK_entry() //  [R1]
         { info_tbl: [(cR1,
                       label: sat_sIK_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cR1:
           if ((Sp + -12) < SpLim) goto cR4; else goto cR5;
       cR4:
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cR5:
           P32[Sp - 12] = P32[R1 + 3];
           P32[Sp - 8] = P32[R1 + 7];
           P32[Sp - 4] = P32[R1 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIJ_entry() //  [R1]
         { info_tbl: [(cR8,
                       label: sat_sIJ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cR8:
           if ((Sp + -12) < SpLim) goto cRb; else goto cRc;
       cRb:
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRc:
           P32[Sp - 12] = P32[R1 + 3];
           P32[Sp - 8] = P32[R1 + 7];
           P32[Sp - 4] = P32[R1 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sII_entry() //  [R1]
         { info_tbl: [(cRf,
                       label: sat_sII_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cRf:
           if ((Sp + -12) < SpLim) goto cRi; else goto cRj;
       cRi:
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRj:
           P32[Sp - 12] = P32[R1 + 3];
           P32[Sp - 8] = P32[R1 + 7];
           P32[Sp - 4] = P32[R1 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIH_entry() //  [R1]
         { info_tbl: [(cRm,
                       label: sat_sIH_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 12 updfr_space: Just 4
         }
     {offset
       cRm:
           if ((Sp + -12) < SpLim) goto cRp; else goto cRq;
       cRp:
           call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
       cRq:
           P32[Sp - 12] = P32[R1 + 2];
           P32[Sp - 8] = P32[R1 + 6];
           P32[Sp - 4] = P32[R1 + 10];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
     }
 },
 sat_sIG_entry() //  [R1]
         { info_tbl: [(cRt,
                       label: sat_sIG_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cRt:
           if ((Sp + -12) < SpLim) goto cRw; else goto cRx;
       cRw:
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cRx:
           P32[Sp - 12] = P32[R1 + 1];
           P32[Sp - 8] = P32[R1 + 5];
           P32[Sp - 4] = P32[R1 + 9];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_entry() //  []
         { info_tbl: [(cRB,
                       label: T2902_B_PairingSum.$fSumPSumab_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cRB:
           Hp = Hp + 124;
           if (Hp > HpLim) goto cRD; else goto cRC;
       cRD:
           HpAlloc = 124;
           goto cRA;
       cRA:
           R1 = T2902_B_PairingSum.$fSumPSumab_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cRC:
           I32[Hp - 120] = sat_sIL_info;
           _sID::P32 = P32[Sp];
           P32[Hp - 116] = _sID::P32;
           _sIE::P32 = P32[Sp + 4];
           P32[Hp - 112] = _sIE::P32;
           _sIF::P32 = P32[Sp + 8];
           P32[Hp - 108] = _sIF::P32;
           I32[Hp - 104] = sat_sIK_info;
           P32[Hp - 100] = _sID::P32;
           P32[Hp - 96] = _sIE::P32;
           P32[Hp - 92] = _sIF::P32;
           I32[Hp - 88] = sat_sIJ_info;
           P32[Hp - 84] = _sID::P32;
           P32[Hp - 80] = _sIE::P32;
           P32[Hp - 76] = _sIF::P32;
           I32[Hp - 72] = sat_sII_info;
           P32[Hp - 68] = _sID::P32;
           P32[Hp - 64] = _sIE::P32;
           P32[Hp - 60] = _sIF::P32;
           I32[Hp - 56] = sat_sIH_info;
           P32[Hp - 52] = _sID::P32;
           P32[Hp - 48] = _sIE::P32;
           P32[Hp - 44] = _sIF::P32;
           I32[Hp - 40] = sat_sIG_info;
           P32[Hp - 36] = _sID::P32;
           P32[Hp - 32] = _sIE::P32;
           P32[Hp - 28] = _sIF::P32;
           I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
           P32[Hp - 20] = Hp - 37;
           P32[Hp - 16] = Hp - 54;
           P32[Hp - 12] = Hp - 71;
           P32[Hp - 8] = Hp - 87;
           P32[Hp - 4] = Hp - 103;
           P32[Hp] = Hp - 119;
           R1 = Hp - 23;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.$fSumPSumab_closure:
         const T2902_B_PairingSum.$fSumPSumab_info;
         const 0;
 },
 sat_sIL_entry() //  [R1]
         { info_tbl: [(cQU,
                       label: sat_sIL_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cQU:
           if ((Sp + -12) < SpLim) goto cQX; else goto cQY;
       cQX:
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cQY:
           P32[Sp - 12] = P32[R1 + 3];
           P32[Sp - 8] = P32[R1 + 7];
           P32[Sp - 4] = P32[R1 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIK_entry() //  [R1]
         { info_tbl: [(cR1,
                       label: sat_sIK_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cR1:
           if ((Sp + -12) < SpLim) goto cR4; else goto cR5;
       cR4:
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cR5:
           P32[Sp - 12] = P32[R1 + 3];
           P32[Sp - 8] = P32[R1 + 7];
           P32[Sp - 4] = P32[R1 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIJ_entry() //  [R1]
         { info_tbl: [(cR8,
                       label: sat_sIJ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cR8:
           if ((Sp + -12) < SpLim) goto cRb; else goto cRc;
       cRb:
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRc:
           P32[Sp - 12] = P32[R1 + 3];
           P32[Sp - 8] = P32[R1 + 7];
           P32[Sp - 4] = P32[R1 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cextractMin_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sII_entry() //  [R1]
         { info_tbl: [(cRf,
                       label: sat_sII_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       cRf:
           if ((Sp + -12) < SpLim) goto cRi; else goto cRj;
       cRi:
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       cRj:
           P32[Sp - 12] = P32[R1 + 3];
           P32[Sp - 8] = P32[R1 + 7];
           P32[Sp - 4] = P32[R1 + 11];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 20, res: 0, upd: 4;
     }
 },
 sat_sIH_entry() //  [R1]
         { info_tbl: [(cRm,
                       label: sat_sIH_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 12 updfr_space: Just 4
         }
     {offset
       cRm:
           if ((Sp + -12) < SpLim) goto cRp; else goto cRq;
       cRp:
           call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
       cRq:
           P32[Sp - 12] = P32[R1 + 2];
           P32[Sp - 8] = P32[R1 + 6];
           P32[Sp - 4] = P32[R1 + 10];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cunion_info() args: 24, res: 0, upd: 4;
     }
 },
 sat_sIG_entry() //  [R1]
         { info_tbl: [(cRt,
                       label: sat_sIG_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cRt:
           if ((Sp + -12) < SpLim) goto cRw; else goto cRx;
       cRw:
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cRx:
           P32[Sp - 12] = P32[R1 + 1];
           P32[Sp - 8] = P32[R1 + 5];
           P32[Sp - 4] = P32[R1 + 9];
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cinsert_info() args: 28, res: 0, upd: 4;
     }
 },
 T2902_B_PairingSum.$fSumPSumab_entry() //  []
         { info_tbl: [(cRB,
                       label: T2902_B_PairingSum.$fSumPSumab_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cRB:
           Hp = Hp + 124;
           if (Hp > HpLim) goto cRD; else goto cRC;
       cRD:
           HpAlloc = 124;
           goto cRA;
       cRA:
           R1 = T2902_B_PairingSum.$fSumPSumab_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cRC:
           I32[Hp - 120] = sat_sIL_info;
           _sID::P32 = P32[Sp];
           P32[Hp - 116] = _sID::P32;
           _sIE::P32 = P32[Sp + 4];
           P32[Hp - 112] = _sIE::P32;
           _sIF::P32 = P32[Sp + 8];
           P32[Hp - 108] = _sIF::P32;
           I32[Hp - 104] = sat_sIK_info;
           P32[Hp - 100] = _sID::P32;
           P32[Hp - 96] = _sIE::P32;
           P32[Hp - 92] = _sIF::P32;
           I32[Hp - 88] = sat_sIJ_info;
           P32[Hp - 84] = _sID::P32;
           P32[Hp - 80] = _sIE::P32;
           P32[Hp - 76] = _sIF::P32;
           I32[Hp - 72] = sat_sII_info;
           P32[Hp - 68] = _sID::P32;
           P32[Hp - 64] = _sIE::P32;
           P32[Hp - 60] = _sIF::P32;
           I32[Hp - 56] = sat_sIH_info;
           P32[Hp - 52] = _sID::P32;
           P32[Hp - 48] = _sIE::P32;
           P32[Hp - 44] = _sIF::P32;
           I32[Hp - 40] = sat_sIG_info;
           P32[Hp - 36] = _sID::P32;
           P32[Hp - 32] = _sIE::P32;
           P32[Hp - 28] = _sIF::P32;
           I32[Hp - 24] = T2902_Sum.D:Sum_con_info;
           P32[Hp - 20] = Hp - 37;
           P32[Hp - 16] = Hp - 54;
           P32[Hp - 12] = Hp - 71;
           P32[Hp - 8] = Hp - 87;
           P32[Hp - 4] = Hp - 103;
           P32[Hp] = Hp - 119;
           R1 = Hp - 23;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.Empty_closure:
         const T2902_B_PairingSum.Empty_static_info;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.Empty_closure:
         const T2902_B_PairingSum.Empty_static_info;
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.Empty_closure:
         const T2902_B_PairingSum.Empty_static_info;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     T2902_B_PairingSum.Tree_closure:
         const T2902_B_PairingSum.Tree_info;
 },
 T2902_B_PairingSum.Tree_entry() //  []
         { info_tbl: [(cSw,
                       label: T2902_B_PairingSum.Tree_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cSw:
           _B3::P32 = P32[(old + 16)];
           _B2::P32 = P32[(old + 12)];
           _B1::P32 = P32[(old + 8)];
           goto cSt;
       cSt:
           if (Sp - <highSp> < SpLim) goto cSx; else goto cSy;
       cSy:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cSA; else goto cSz;
       cSA:
           HpAlloc = 16;
           goto cSx;
       cSx:
           R1 = T2902_B_PairingSum.Tree_closure;
           P32[(old + 16)] = _B3::P32;
           P32[(old + 12)] = _B2::P32;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cSz:
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = _B3::P32;
           P32[Hp - 4] = _B2::P32;
           P32[Hp] = _B1::P32;
           _cSv::P32 = Hp - 10;
           R1 = _cSv::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cSw:
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cSt;
  cSt:
      if (Sp - <highSp> < SpLim) goto cSx; else goto cSy;
  cSy:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cSA; else goto cSz;
  cSA:
      HpAlloc = 16;
      goto cSx;
  cSx:
      R1 = T2902_B_PairingSum.Tree_closure;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cSz:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _cSv::P32 = Hp - 10;
      R1 = _cSv::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cSw:
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cSt;
  cSt:
      if (Sp - <highSp> < SpLim) goto cSx; else goto cSy;
  cSy:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cSA; else goto cSz;
  cSA:
      HpAlloc = 16;
      goto cSx;
  cSx:
      R1 = T2902_B_PairingSum.Tree_closure;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cSz:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _cSv::P32 = Hp - 10;
      R1 = _cSv::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cSw:
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cSt;
  cSt:
      if (Sp - <highSp> < SpLim) goto cSx; else goto cSy;
  cSy:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cSA; else goto cSz;
  cSA:
      HpAlloc = 16;
      goto cSx;
  cSx:
      R1 = T2902_B_PairingSum.Tree_closure;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cSz:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _cSv::P32 = Hp - 10;
      R1 = _cSv::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cSw:
      _B3::P32 = P32[(old + 16)];
      _B2::P32 = P32[(old + 12)];
      _B1::P32 = P32[(old + 8)];
      goto cSt;
  cSt:
      if (Sp - <highSp> < SpLim) goto cSx; else goto cSy;
  cSy:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cSA; else goto cSz;
  cSA:
      HpAlloc = 16;
      goto cSx;
  cSx:
      R1 = T2902_B_PairingSum.Tree_closure;
      P32[(old + 16)] = _B3::P32;
      P32[(old + 12)] = _B2::P32;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cSz:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _cSv::P32 = Hp - 10;
      R1 = _cSv::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cSw:
      _B3::P32 = P32[Sp];
      _B2::P32 = P32[Sp + 4];
      _B1::P32 = P32[Sp + 8];
      goto cSt;
  cSt:
      goto cSy;
  cSy:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cSA; else goto cSz;
  cSA:
      HpAlloc = 16;
      goto cSx;
  cSx:
      R1 = T2902_B_PairingSum.Tree_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cSz:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = _B3::P32;
      P32[Hp - 4] = _B2::P32;
      P32[Hp] = _B1::P32;
      _cSv::P32 = Hp - 10;
      R1 = _cSv::P32;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cSw:
      goto cSt;
  cSt:
      goto cSy;
  cSy:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cSA; else goto cSz;
  cSA:
      HpAlloc = 16;
      goto cSx;
  cSx:
      R1 = T2902_B_PairingSum.Tree_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  cSz:
      I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
      P32[Hp - 8] = P32[Sp];
      P32[Hp - 4] = P32[Sp + 4];
      P32[Hp] = P32[Sp + 8];
      R1 = Hp - 10;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cSt, {}), (cSw, {}), (cSx, {}), (cSy, {}), (cSz, {}), (cSA, {})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.Tree_entry() //  []
        { info_tbl: [(cSw,
                      label: T2902_B_PairingSum.Tree_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      cSw:
          goto cSt;
      cSt:
          goto cSy;
      cSy:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cSA; else goto cSz;
      cSA:
          HpAlloc = 16;
          goto cSx;
      cSx:
          R1 = T2902_B_PairingSum.Tree_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      cSz:
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp];
          P32[Hp - 4] = P32[Sp + 4];
          P32[Hp] = P32[Sp + 8];
          R1 = Hp - 10;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.Tree_entry() //  []
        { info_tbl: [(cSy,
                      label: T2902_B_PairingSum.Tree_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      cSy:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cSA; else goto cSz;
      cSA:
          HpAlloc = 16;
          goto cSx;
      cSx:
          R1 = T2902_B_PairingSum.Tree_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      cSz:
          I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
          P32[Hp - 8] = P32[Sp];
          P32[Hp - 4] = P32[Sp + 4];
          P32[Hp] = P32[Sp + 8];
          R1 = Hp - 10;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     T2902_B_PairingSum.Tree_closure:
         const T2902_B_PairingSum.Tree_info;
 },
 T2902_B_PairingSum.Tree_entry() //  []
         { info_tbl: [(cSy,
                       label: T2902_B_PairingSum.Tree_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cSy:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cSA; else goto cSz;
       cSA:
           HpAlloc = 16;
           goto cSx;
       cSx:
           R1 = T2902_B_PairingSum.Tree_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cSz:
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp];
           P32[Hp - 4] = P32[Sp + 4];
           P32[Hp] = P32[Sp + 8];
           R1 = Hp - 10;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     T2902_B_PairingSum.Tree_closure:
         const T2902_B_PairingSum.Tree_info;
 },
 T2902_B_PairingSum.Tree_entry() //  []
         { info_tbl: [(cSy,
                       label: T2902_B_PairingSum.Tree_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       cSy:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cSA; else goto cSz;
       cSA:
           HpAlloc = 16;
           goto cSx;
       cSx:
           R1 = T2902_B_PairingSum.Tree_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       cSz:
           I32[Hp - 12] = T2902_B_PairingSum.Tree_con_info;
           P32[Hp - 8] = P32[Sp];
           P32[Hp - 4] = P32[Sp + 4];
           P32[Hp] = P32[Sp + 8];
           R1 = Hp - 10;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[T2902_B_PairingSum.Empty_static_entry() //  []
         { info_tbl: [(cSI,
                       label: T2902_B_PairingSum.Empty_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,69,109,112,116,121]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSI:
           R1 = R1 + 1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cSI:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cSI:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cSI:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cSI:
      R1 = R1 + 1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cSI:
      R1 = R1 + 1;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cSI:
      R1 = R1 + 1;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cSI, {})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.Empty_static_entry() //  []
        { info_tbl: [(cSI,
                      label: T2902_B_PairingSum.Empty_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,69,109,112,116,121]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cSI:
          R1 = R1 + 1;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.Empty_static_entry() //  []
        { info_tbl: [(cSI,
                      label: T2902_B_PairingSum.Empty_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,69,109,112,116,121]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cSI:
          R1 = R1 + 1;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[T2902_B_PairingSum.Empty_static_entry() //  []
         { info_tbl: [(cSI,
                       label: T2902_B_PairingSum.Empty_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,69,109,112,116,121]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSI:
           R1 = R1 + 1;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[T2902_B_PairingSum.Empty_static_entry() //  []
         { info_tbl: [(cSI,
                       label: T2902_B_PairingSum.Empty_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,69,109,112,116,121]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSI:
           R1 = R1 + 1;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[T2902_B_PairingSum.Tree_con_entry() //  []
         { info_tbl: [(cSN,
                       label: T2902_B_PairingSum.Tree_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSN:
           R1 = R1 + 2;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 },
 T2902_B_PairingSum.Tree_static_entry() //  []
         { info_tbl: [(cSO,
                       label: T2902_B_PairingSum.Tree_static_info
                       rep:HeapRep static {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSO:
           R1 = R1 + 2;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cSN:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cSN:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cSN:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cSN:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cSN:
      R1 = R1 + 2;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cSN:
      R1 = R1 + 2;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cSN, {})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.Tree_con_entry() //  []
        { info_tbl: [(cSN,
                      label: T2902_B_PairingSum.Tree_con_info
                      rep:HeapRep 3 ptrs {
                            Con {tag: 1
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cSN:
          R1 = R1 + 2;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.Tree_con_entry() //  []
        { info_tbl: [(cSN,
                      label: T2902_B_PairingSum.Tree_con_info
                      rep:HeapRep 3 ptrs {
                            Con {tag: 1
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cSN:
          R1 = R1 + 2;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
{offset
  cSO:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  cSO:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  cSO:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  cSO:
      R1 = R1 + 2;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  cSO:
      R1 = R1 + 2;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  cSO:
      R1 = R1 + 2;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(cSO, {})]



==================== after setInfoTableStackMap ====================
T2902_B_PairingSum.Tree_static_entry() //  []
        { info_tbl: [(cSO,
                      label: T2902_B_PairingSum.Tree_static_info
                      rep:HeapRep static {
                            Con {tag: 1
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cSO:
          R1 = R1 + 2;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
T2902_B_PairingSum.Tree_static_entry() //  []
        { info_tbl: [(cSO,
                      label: T2902_B_PairingSum.Tree_static_info
                      rep:HeapRep static {
                            Con {tag: 1
                                 descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      cSO:
          R1 = R1 + 2;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[T2902_B_PairingSum.Tree_con_entry() //  []
         { info_tbl: [(cSN,
                       label: T2902_B_PairingSum.Tree_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSN:
           R1 = R1 + 2;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 },
 T2902_B_PairingSum.Tree_static_entry() //  []
         { info_tbl: [(cSO,
                       label: T2902_B_PairingSum.Tree_static_info
                       rep:HeapRep static {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSO:
           R1 = R1 + 2;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[T2902_B_PairingSum.Tree_con_entry() //  []
         { info_tbl: [(cSN,
                       label: T2902_B_PairingSum.Tree_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSN:
           R1 = R1 + 2;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 },
 T2902_B_PairingSum.Tree_static_entry() //  []
         { info_tbl: [(cSO,
                       label: T2902_B_PairingSum.Tree_static_info
                       rep:HeapRep static {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,84,50,57,48,50,95,66,95,80,97,105,114,105,110,103,83,117,109,46,84,114,101,101]} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       cSO:
           R1 = R1 + 2;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "relreadonly" {
     SMp_srt:
         const T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
         const T2902_B_PairingSum.$fSumPSumab_$cunion_closure;
         const lvl_rHo_closure;
         const T2902_B_PairingSum.$fSumPSumab_$cinsert_closure;
         const GHC.Err.undefined_closure;
         const T2902_B_PairingSum.$fSumPSumab_$cextractMin_closure;
         const T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
         const T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
         const T2902_B_PairingSum.$fSumPSumab_closure;
 }]


[3 of 3] Compiling Main             ( T2902_B.hs, T2902_B.o )

==================== Cmm produced by new codegen ====================
[section "data" { __stginit_main:Main:
 }]



==================== Post CPS Cmm ====================
[section "data" { __stginit_main:Main:
 }]



==================== Output Cmm ====================
[section "data" { __stginit_main:Main:
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     x_r23K_closure:
         const GHC.Types.I#_static_info;
         const 1;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     x_r23K_closure:
         const GHC.Types.I#_static_info;
         const 1;
 }]



==================== Output Cmm ====================
[section "data" {
     x_r23K_closure:
         const GHC.Types.I#_static_info;
         const 1;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     xs_r23L_closure:
         const :_static_info;
         const x_r23K_closure+1;
         const xs_r23L_closure+2;
         const 1;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     xs_r23L_closure:
         const :_static_info;
         const x_r23K_closure+1;
         const xs_r23L_closure+2;
         const 1;
 }]



==================== Output Cmm ====================
[section "data" {
     xs_r23L_closure:
         const :_static_info;
         const x_r23K_closure+1;
         const xs_r23L_closure+2;
         const 1;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     x1_r23M_closure:
         const GHC.Types.I#_static_info;
         const 2;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     x1_r23M_closure:
         const GHC.Types.I#_static_info;
         const 2;
 }]



==================== Output Cmm ====================
[section "data" {
     x1_r23M_closure:
         const GHC.Types.I#_static_info;
         const 2;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     xs1_r23N_closure:
         const :_static_info;
         const x1_r23M_closure+1;
         const xs1_r23N_closure+2;
         const 1;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     xs1_r23N_closure:
         const :_static_info;
         const x1_r23M_closure+1;
         const xs1_r23N_closure+2;
         const 1;
 }]



==================== Output Cmm ====================
[section "data" {
     xs1_r23N_closure:
         const :_static_info;
         const x1_r23M_closure+1;
         const xs1_r23N_closure+2;
         const 1;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     x2_r23O_closure:
         const GHC.Types.I#_static_info;
         const 3;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     x2_r23O_closure:
         const GHC.Types.I#_static_info;
         const 3;
 }]



==================== Output Cmm ====================
[section "data" {
     x2_r23O_closure:
         const GHC.Types.I#_static_info;
         const 3;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     xs2_r23P_closure:
         const :_static_info;
         const x2_r23O_closure+1;
         const xs2_r23P_closure+2;
         const 1;
 }]



==================== Post CPS Cmm ====================
[section "data" {
     xs2_r23P_closure:
         const :_static_info;
         const x2_r23O_closure+1;
         const xs2_r23P_closure+2;
         const 1;
 }]



==================== Output Cmm ====================
[section "data" {
     xs2_r23P_closure:
         const :_static_info;
         const x2_r23O_closure+1;
         const xs2_r23P_closure+2;
         const 1;
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     lvl_r23Q_closure:
         const lvl_r23Q_info;
 },
 lvl_r23Q_entry() //  []
         { info_tbl: [(c25k,
                       label: lvl_r23Q_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       c25k:
           _s23Y::P32 = P32[(old + 16)];
           _s23Z::P32 = P32[(old + 12)];
           _s240::P32 = P32[(old + 8)];
           goto c258;
       c258:
           if (Sp - <highSp> < SpLim) goto c25l; else goto c25m;
       c25l:
           R1 = lvl_r23Q_closure;
           P32[(old + 16)] = _s23Y::P32;
           P32[(old + 12)] = _s23Z::P32;
           P32[(old + 8)] = _s240::P32;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       c25m:
           I32[(young<c25a> + 4)] = c25a;
           R1 = _s240::P32;
           if (R1 & 3 != 0) goto c25a; else goto c25b;
       c25b:
           call (I32[R1])(R1) returns to c25a, args: 4, res: 4, upd: 4;
       c25a:
           _s241::P32 = R1;
           _c25g::P32 = _s241::P32 & 3;
           if (_c25g::P32 >= 2) goto c25i; else goto c25j;
       c25i:
           goto c25f;
       c25f:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c25x; else goto c25w;
       c25x:
           HpAlloc = 40;
           goto c25v;
       c25v:
           R1 = _s241::P32;
           call stg_gc_unpt_r1(R1) returns to c25a, args: 4, res: 4, upd: 4;
       c25w:
           _s242::P32 = P32[_s241::P32 + 2];
           _s243::P32 = P32[_s241::P32 + 6];
           I32[Hp - 36] = stg_ap_2_upd_info;
           P32[Hp - 28] = _s23Z::P32;
           P32[Hp - 24] = _s243::P32;
           _c25s::P32 = Hp - 36;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _s23Y::P32;
           P32[Hp - 12] = _s242::P32;
           _c25t::P32 = Hp - 19;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = _c25t::P32;
           P32[Hp] = _c25s::P32;
           _c25u::P32 = Hp - 6;
           R1 = _c25u::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
       c25j:
           goto c25e;
       c25e:
           R1 = []_closure+1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c25k:
      _s23Y::P32 = P32[(old + 16)];
      _s23Z::P32 = P32[(old + 12)];
      _s240::P32 = P32[(old + 8)];
      goto c258;
  c258:
      if (Sp - <highSp> < SpLim) goto c25l; else goto c25m;
  c25l:
      R1 = lvl_r23Q_closure;
      P32[(old + 16)] = _s23Y::P32;
      P32[(old + 12)] = _s23Z::P32;
      P32[(old + 8)] = _s240::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c25m:
      I32[(young<c25a> + 4)] = c25a;
      R1 = _s240::P32;
      if (R1 & 3 != 0) goto c25a; else goto c25b;
  c25b:
      call (I32[R1])(R1) returns to c25a, args: 4, res: 4, upd: 4;
  c25a:
      _s241::P32 = R1;
      _c25g::P32 = _s241::P32 & 3;
      if (_c25g::P32 >= 2) goto c25f; else goto c25e;
  c25f:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c25x; else goto c25w;
  c25x:
      HpAlloc = 40;
      goto c25v;
  c25v:
      R1 = _s241::P32;
      call stg_gc_unpt_r1(R1) returns to c25a, args: 4, res: 4, upd: 4;
  c25w:
      _s242::P32 = P32[_s241::P32 + 2];
      _s243::P32 = P32[_s241::P32 + 6];
      I32[Hp - 36] = stg_ap_2_upd_info;
      P32[Hp - 28] = _s23Z::P32;
      P32[Hp - 24] = _s243::P32;
      _c25s::P32 = Hp - 36;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _s23Y::P32;
      P32[Hp - 12] = _s242::P32;
      _c25t::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c25t::P32;
      P32[Hp] = _c25s::P32;
      _c25u::P32 = Hp - 6;
      R1 = _c25u::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c25e:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c25k:
      _s23Y::P32 = P32[(old + 16)];
      _s23Z::P32 = P32[(old + 12)];
      _s240::P32 = P32[(old + 8)];
      goto c258;
  c258:
      if (Sp - <highSp> < SpLim) goto c25l; else goto c25m;
  c25l:
      R1 = lvl_r23Q_closure;
      P32[(old + 16)] = _s23Y::P32;
      P32[(old + 12)] = _s23Z::P32;
      P32[(old + 8)] = _s240::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c25m:
      I32[(young<c25a> + 4)] = c25a;
      R1 = _s240::P32;
      if (R1 & 3 != 0) goto c25a; else goto c25b;
  c25b:
      call (I32[R1])(R1) returns to c25a, args: 4, res: 4, upd: 4;
  c25a:
      _s241::P32 = R1;
      _c25g::P32 = _s241::P32 & 3;
      if (_c25g::P32 >= 2) goto c25f; else goto c25e;
  c25f:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c25x; else goto c25w;
  c25x:
      HpAlloc = 40;
      goto c25v;
  c25v:
      R1 = _s241::P32;
      call stg_gc_unpt_r1(R1) returns to c25a, args: 4, res: 4, upd: 4;
  c25w:
      _s242::P32 = P32[_s241::P32 + 2];
      _s243::P32 = P32[_s241::P32 + 6];
      I32[Hp - 36] = stg_ap_2_upd_info;
      P32[Hp - 28] = _s23Z::P32;
      P32[Hp - 24] = _s243::P32;
      _c25s::P32 = Hp - 36;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _s23Y::P32;
      P32[Hp - 12] = _s242::P32;
      _c25t::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c25t::P32;
      P32[Hp] = _c25s::P32;
      _c25u::P32 = Hp - 6;
      R1 = _c25u::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c25e:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c25k:
      _s23Y::P32 = P32[(old + 16)];
      _s23Z::P32 = P32[(old + 12)];
      _s240::P32 = P32[(old + 8)];
      goto c258;
  c258:
      if (Sp - <highSp> < SpLim) goto c25l; else goto c25m;
  c25l:
      R1 = lvl_r23Q_closure;
      P32[(old + 16)] = _s23Y::P32;
      P32[(old + 12)] = _s23Z::P32;
      P32[(old + 8)] = _s240::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c25m:
      I32[(young<c25a> + 4)] = c25a;
      R1 = _s240::P32;
      if (R1 & 3 != 0) goto c25a; else goto c25b;
  c25b:
      call (I32[R1])(R1) returns to c25a, args: 4, res: 4, upd: 4;
  c25a:
      _s241::P32 = R1;
      _c25g::P32 = _s241::P32 & 3;
      if (_c25g::P32 >= 2) goto c25f; else goto c25e;
  c25f:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c25x; else goto c25w;
  c25x:
      HpAlloc = 40;
      goto c25v;
  c25v:
      R1 = _s241::P32;
      call stg_gc_unpt_r1(R1) returns to c25a, args: 4, res: 4, upd: 4;
  c25w:
      _s242::P32 = P32[_s241::P32 + 2];
      _s243::P32 = P32[_s241::P32 + 6];
      I32[Hp - 36] = stg_ap_2_upd_info;
      P32[Hp - 28] = _s23Z::P32;
      P32[Hp - 24] = _s243::P32;
      _c25s::P32 = Hp - 36;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _s23Y::P32;
      P32[Hp - 12] = _s242::P32;
      _c25t::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c25t::P32;
      P32[Hp] = _c25s::P32;
      _c25u::P32 = Hp - 6;
      R1 = _c25u::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c25e:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c25k:
      _s23Y::P32 = P32[(old + 16)];
      _s23Z::P32 = P32[(old + 12)];
      _s240::P32 = P32[(old + 8)];
      goto c258;
  c258:
      if (Sp - <highSp> < SpLim) goto c25l; else goto c25m;
  c25l:
      R1 = lvl_r23Q_closure;
      P32[(old + 16)] = _s23Y::P32;
      P32[(old + 12)] = _s23Z::P32;
      P32[(old + 8)] = _s240::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c25m:
      I32[(young<c25a> + 4)] = c25a;
      R1 = _s240::P32;
      if (_s240::P32 & 3 != 0) goto c25a; else goto c25b;
  c25b:
      call (I32[_s240::P32])(R1) returns to c25a, args: 4, res: 4, upd: 4;
  c25a:
      _s241::P32 = R1;
      _c25g::P32 = R1 & 3;
      if (_c25g::P32 >= 2) goto c25f; else goto c25e;
  c25f:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c25x; else goto c25w;
  c25x:
      HpAlloc = 40;
      goto c25v;
  c25v:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c25a, args: 4, res: 4, upd: 4;
  c25w:
      _s242::P32 = P32[R1 + 2];
      _s243::P32 = P32[R1 + 6];
      I32[Hp - 36] = stg_ap_2_upd_info;
      P32[Hp - 28] = _s23Z::P32;
      P32[Hp - 24] = _s243::P32;
      _c25s::P32 = Hp - 36;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _s23Y::P32;
      P32[Hp - 12] = _s242::P32;
      _c25t::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c25t::P32;
      P32[Hp] = _c25s::P32;
      _c25u::P32 = Hp - 6;
      R1 = _c25u::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c25e:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c25k:
      _s23Y::P32 = P32[Sp];
      _s23Z::P32 = P32[Sp + 4];
      _s240::P32 = P32[Sp + 8];
      goto c258;
  c258:
      if (Sp - 4 < SpLim) goto c25l; else goto c25m;
  c25l:
      R1 = lvl_r23Q_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c25m:
      I32[Sp - 4] = c25a;
      R1 = _s240::P32;
      Sp = Sp - 4;
      if (_s240::P32 & 3 != 0) goto c25a; else goto c25b;
  c25b:
      call (I32[_s240::P32])(R1) returns to c25a, args: 4, res: 4, upd: 4;
  c25a:
      _s23Y::P32 = P32[Sp + 4];
      _s23Z::P32 = P32[Sp + 8];
      _s241::P32 = R1;
      _c25g::P32 = R1 & 3;
      if (_c25g::P32 >= 2) goto c25f; else goto c25e;
  c25f:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c25x; else goto c25w;
  c25x:
      HpAlloc = 40;
      goto c25v;
  c25v:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c25a, args: 4, res: 4, upd: 4;
  c25w:
      _s242::P32 = P32[R1 + 2];
      _s243::P32 = P32[R1 + 6];
      I32[Hp - 36] = stg_ap_2_upd_info;
      P32[Hp - 28] = _s23Z::P32;
      P32[Hp - 24] = _s243::P32;
      _c25s::P32 = Hp - 36;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _s23Y::P32;
      P32[Hp - 12] = _s242::P32;
      _c25t::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c25t::P32;
      P32[Hp] = _c25s::P32;
      _c25u::P32 = Hp - 6;
      R1 = _c25u::P32;
      Sp = Sp + 16;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  c25e:
      R1 = []_closure+1;
      Sp = Sp + 16;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c25k:
      goto c258;
  c258:
      if ((Sp + -4) < SpLim) goto c25l; else goto c25m;
  c25l:
      R1 = lvl_r23Q_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c25m:
      I32[Sp - 4] = c25a;
      _s240::P32 = P32[Sp + 8];
      R1 = _s240::P32;
      Sp = Sp - 4;
      if (_s240::P32 & 3 != 0) goto c25a; else goto c25b;
  c25b:
      call (I32[_s240::P32])(R1) returns to c25a, args: 4, res: 4, upd: 4;
  c25a:
      if (R1 & 3 >= 2) goto c25f; else goto c25e;
  c25f:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c25x; else goto c25w;
  c25x:
      HpAlloc = 40;
      goto c25v;
  c25v:
      call stg_gc_unpt_r1(R1) returns to c25a, args: 4, res: 4, upd: 4;
  c25w:
      _s242::P32 = P32[R1 + 2];
      _s243::P32 = P32[R1 + 6];
      I32[Hp - 36] = stg_ap_2_upd_info;
      P32[Hp - 28] = P32[Sp + 8];
      P32[Hp - 24] = _s243::P32;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = P32[Sp + 4];
      P32[Hp - 12] = _s242::P32;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = Hp - 19;
      P32[Hp] = Hp - 36;
      R1 = Hp - 6;
      Sp = Sp + 16;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  c25e:
      R1 = []_closure+1;
      Sp = Sp + 16;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c258, {}), (c25a, {}), (c25b, {}), (c25e, {}), (c25f, {}),
 (c25k, {}), (c25l, {}), (c25m, {}), (c25v, {}), (c25w, {}),
 (c25x, {})]



==================== after setInfoTableStackMap ====================
lvl_r23Q_entry() //  []
        { info_tbl: [(c25a,
                      label: block_c25a_info
                      rep:StackRep [False, False, True]),
                     (c25k,
                      label: lvl_r23Q_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      c25k:
          goto c258;
      c258:
          if ((Sp + -4) < SpLim) goto c25l; else goto c25m;
      c25l:
          R1 = lvl_r23Q_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      c25m:
          I32[Sp - 4] = c25a;
          _s240::P32 = P32[Sp + 8];
          R1 = _s240::P32;
          Sp = Sp - 4;
          if (_s240::P32 & 3 != 0) goto c25a; else goto c25b;
      c25b:
          call (I32[_s240::P32])(R1) returns to c25a, args: 4, res: 4, upd: 4;
      c25a:
          if (R1 & 3 >= 2) goto c25f; else goto c25e;
      c25f:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c25x; else goto c25w;
      c25x:
          HpAlloc = 40;
          goto c25v;
      c25v:
          call stg_gc_unpt_r1(R1) returns to c25a, args: 4, res: 4, upd: 4;
      c25w:
          _s242::P32 = P32[R1 + 2];
          _s243::P32 = P32[R1 + 6];
          I32[Hp - 36] = stg_ap_2_upd_info;
          P32[Hp - 28] = P32[Sp + 8];
          P32[Hp - 24] = _s243::P32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = P32[Sp + 4];
          P32[Hp - 12] = _s242::P32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 36;
          R1 = Hp - 6;
          Sp = Sp + 16;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      c25e:
          R1 = []_closure+1;
          Sp = Sp + 16;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
lvl_r23Q_entry() //  []
        { info_tbl: [(c258,
                      label: lvl_r23Q_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} }),
                     (c25a,
                      label: block_c25a_info
                      rep:StackRep [False, False, True])]
          stack_info: arg_space: 16 updfr_space: Just 4
        }
    {offset
      c258:
          if ((Sp + -4) < SpLim) goto c25l; else goto c25m;
      c25l:
          R1 = lvl_r23Q_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
      c25m:
          I32[Sp - 4] = c25a;
          _s240::P32 = P32[Sp + 8];
          R1 = _s240::P32;
          Sp = Sp - 4;
          if (_s240::P32 & 3 != 0) goto c25a; else goto c25b;
      c25b:
          call (I32[_s240::P32])(R1) returns to c25a, args: 4, res: 4, upd: 4;
      c25a:
          if (R1 & 3 >= 2) goto c25f; else goto c25e;
      c25f:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c25x; else goto c25w;
      c25x:
          HpAlloc = 40;
          goto c25v;
      c25v:
          call stg_gc_unpt_r1(R1) returns to c25a, args: 4, res: 4, upd: 4;
      c25w:
          _s242::P32 = P32[R1 + 2];
          _s243::P32 = P32[R1 + 6];
          I32[Hp - 36] = stg_ap_2_upd_info;
          P32[Hp - 28] = P32[Sp + 8];
          P32[Hp - 24] = _s243::P32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = P32[Sp + 4];
          P32[Hp - 12] = _s242::P32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 36;
          R1 = Hp - 6;
          Sp = Sp + 16;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      c25e:
          R1 = []_closure+1;
          Sp = Sp + 16;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     lvl_r23Q_closure:
         const lvl_r23Q_info;
 },
 lvl_r23Q_entry() //  []
         { info_tbl: [(c258,
                       label: lvl_r23Q_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} }),
                      (c25a,
                       label: block_c25a_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       c258:
           if ((Sp + -4) < SpLim) goto c25l; else goto c25m;
       c25l:
           R1 = lvl_r23Q_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       c25m:
           I32[Sp - 4] = c25a;
           _s240::P32 = P32[Sp + 8];
           R1 = _s240::P32;
           Sp = Sp - 4;
           if (_s240::P32 & 3 != 0) goto c25a; else goto c25b;
       c25b:
           call (I32[_s240::P32])(R1) returns to c25a, args: 4, res: 4, upd: 4;
       c25a:
           if (R1 & 3 >= 2) goto c25f; else goto c25e;
       c25f:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c25x; else goto c25w;
       c25x:
           HpAlloc = 40;
           goto c25v;
       c25v:
           call stg_gc_unpt_r1(R1) returns to c25a, args: 4, res: 4, upd: 4;
       c25w:
           _s242::P32 = P32[R1 + 2];
           _s243::P32 = P32[R1 + 6];
           I32[Hp - 36] = stg_ap_2_upd_info;
           P32[Hp - 28] = P32[Sp + 8];
           P32[Hp - 24] = _s243::P32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = P32[Sp + 4];
           P32[Hp - 12] = _s242::P32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 36;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       c25e:
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     lvl_r23Q_closure:
         const lvl_r23Q_info;
 },
 lvl_r23Q_entry() //  []
         { info_tbl: [(c258,
                       label: lvl_r23Q_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} }),
                      (c25a,
                       label: block_c25a_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 16 updfr_space: Just 4
         }
     {offset
       c258:
           if ((Sp + -4) < SpLim) goto c25l; else goto c25m;
       c25l:
           R1 = lvl_r23Q_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
       c25m:
           I32[Sp - 4] = c25a;
           _s240::P32 = P32[Sp + 8];
           R1 = _s240::P32;
           Sp = Sp - 4;
           if (_s240::P32 & 3 != 0) goto c25a; else goto c25b;
       c25b:
           call (I32[_s240::P32])(R1) returns to c25a, args: 4, res: 4, upd: 4;
       c25a:
           if (R1 & 3 >= 2) goto c25f; else goto c25e;
       c25f:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c25x; else goto c25w;
       c25x:
           HpAlloc = 40;
           goto c25v;
       c25v:
           call stg_gc_unpt_r1(R1) returns to c25a, args: 4, res: 4, upd: 4;
       c25w:
           _s242::P32 = P32[R1 + 2];
           _s243::P32 = P32[R1 + 6];
           I32[Hp - 36] = stg_ap_2_upd_info;
           P32[Hp - 28] = P32[Sp + 8];
           P32[Hp - 24] = _s243::P32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = P32[Sp + 4];
           P32[Hp - 12] = _s242::P32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 36;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       c25e:
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     n_r23R_closure:
         const n_r23R_info;
 },
 n_r23R_entry() //  []
         { info_tbl: [(c25N,
                       label: n_r23R_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c25N:
           _s246::P32 = P32[(old + 8)];
           goto c25L;
       c25L:
           if (Sp - <highSp> < SpLim) goto c25O; else goto c25P;
       c25O:
           R1 = n_r23R_closure;
           P32[(old + 8)] = _s246::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       c25P:
           R1 = []_closure+1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c25N:
      _s246::P32 = P32[(old + 8)];
      goto c25L;
  c25L:
      if (Sp - <highSp> < SpLim) goto c25O; else goto c25P;
  c25O:
      R1 = n_r23R_closure;
      P32[(old + 8)] = _s246::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c25P:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c25N:
      _s246::P32 = P32[(old + 8)];
      goto c25L;
  c25L:
      if (Sp - <highSp> < SpLim) goto c25O; else goto c25P;
  c25O:
      R1 = n_r23R_closure;
      P32[(old + 8)] = _s246::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c25P:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c25N:
      _s246::P32 = P32[(old + 8)];
      goto c25L;
  c25L:
      if (Sp - <highSp> < SpLim) goto c25O; else goto c25P;
  c25O:
      R1 = n_r23R_closure;
      P32[(old + 8)] = _s246::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c25P:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c25N:
      _s246::P32 = P32[(old + 8)];
      goto c25L;
  c25L:
      if (Sp - <highSp> < SpLim) goto c25O; else goto c25P;
  c25O:
      R1 = n_r23R_closure;
      P32[(old + 8)] = _s246::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c25P:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c25N:
      _s246::P32 = P32[Sp];
      goto c25L;
  c25L:
      goto c25P;
  c25P:
      R1 = []_closure+1;
      Sp = Sp + 4;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c25N:
      goto c25L;
  c25L:
      goto c25P;
  c25P:
      R1 = []_closure+1;
      Sp = Sp + 4;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c25L, {}), (c25N, {}), (c25P, {})]



==================== after setInfoTableStackMap ====================
n_r23R_entry() //  []
        { info_tbl: [(c25N,
                      label: n_r23R_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      c25N:
          goto c25L;
      c25L:
          goto c25P;
      c25P:
          R1 = []_closure+1;
          Sp = Sp + 4;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
n_r23R_entry() //  []
        { info_tbl: [(c25P,
                      label: n_r23R_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      c25P:
          R1 = []_closure+1;
          Sp = Sp + 4;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     n_r23R_closure:
         const n_r23R_info;
 },
 n_r23R_entry() //  []
         { info_tbl: [(c25P,
                       label: n_r23R_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c25P:
           R1 = []_closure+1;
           Sp = Sp + 4;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     n_r23R_closure:
         const n_r23R_info;
 },
 n_r23R_entry() //  []
         { info_tbl: [(c25P,
                       label: n_r23R_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c25P:
           R1 = []_closure+1;
           Sp = Sp + 4;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     n1_r23S_closure:
         const n1_r23S_info;
 },
 n1_r23S_entry() //  []
         { info_tbl: [(c25Y,
                       label: n1_r23S_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c25Y:
           _B1::P32 = P32[(old + 8)];
           goto c25W;
       c25W:
           if (Sp - <highSp> < SpLim) goto c25Z; else goto c260;
       c25Z:
           R1 = n1_r23S_closure;
           P32[(old + 8)] = _B1::P32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       c260:
           P32[(old + 8)] = _B1::P32;
           call n_r23R_info() args: 8, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c25Y:
      _B1::P32 = P32[(old + 8)];
      goto c25W;
  c25W:
      if (Sp - <highSp> < SpLim) goto c25Z; else goto c260;
  c25Z:
      R1 = n1_r23S_closure;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c260:
      P32[(old + 8)] = _B1::P32;
      call n_r23R_info() args: 8, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c25Y:
      _B1::P32 = P32[(old + 8)];
      goto c25W;
  c25W:
      if (Sp - <highSp> < SpLim) goto c25Z; else goto c260;
  c25Z:
      R1 = n1_r23S_closure;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c260:
      P32[(old + 8)] = _B1::P32;
      call n_r23R_info() args: 8, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c25Y:
      _B1::P32 = P32[(old + 8)];
      goto c25W;
  c25W:
      if (Sp - <highSp> < SpLim) goto c25Z; else goto c260;
  c25Z:
      R1 = n1_r23S_closure;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c260:
      P32[(old + 8)] = _B1::P32;
      call n_r23R_info() args: 8, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c25Y:
      _B1::P32 = P32[(old + 8)];
      goto c25W;
  c25W:
      if (Sp - <highSp> < SpLim) goto c25Z; else goto c260;
  c25Z:
      R1 = n1_r23S_closure;
      P32[(old + 8)] = _B1::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c260:
      P32[(old + 8)] = _B1::P32;
      call n_r23R_info() args: 8, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c25Y:
      _B1::P32 = P32[Sp];
      goto c25W;
  c25W:
      goto c260;
  c260:
      call n_r23R_info() args: 8, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c25Y:
      goto c25W;
  c25W:
      goto c260;
  c260:
      call n_r23R_info() args: 8, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c25W, {}), (c25Y, {}), (c260, {})]



==================== after setInfoTableStackMap ====================
n1_r23S_entry() //  []
        { info_tbl: [(c25Y,
                      label: n1_r23S_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      c25Y:
          goto c25W;
      c25W:
          goto c260;
      c260:
          call n_r23R_info() args: 8, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
n1_r23S_entry() //  []
        { info_tbl: [(c260,
                      label: n1_r23S_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      c260:
          call n_r23R_info() args: 8, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     n1_r23S_closure:
         const n1_r23S_info;
 },
 n1_r23S_entry() //  []
         { info_tbl: [(c260,
                       label: n1_r23S_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c260:
           call n_r23R_info() args: 8, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     n1_r23S_closure:
         const n1_r23S_info;
 },
 n1_r23S_entry() //  []
         { info_tbl: [(c260,
                       label: n1_r23S_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c260:
           call n_r23R_info() args: 8, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     lvl1_r23T_closure:
         const lvl1_r23T_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r23T_entry() //  [R1]
         { info_tbl: [(c26c,
                       label: lvl1_r23T_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c26c:
           _r23T::P32 = R1;
           goto c267;
       c267:
           if (Sp - <highSp> < SpLim) goto c26d; else goto c26e;
       c26e:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c26g; else goto c26f;
       c26g:
           HpAlloc = 8;
           goto c26d;
       c26d:
           R1 = _r23T::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c26f:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c269::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _r23T::P32, Hp - 4);
           if (_c269::I32 == 0) goto c26b; else goto c26a;
       c26b:
           call (I32[_r23T::P32])() args: 4, res: 0, upd: 4;
       c26a:
           I32[(old + 12)] = stg_bh_upd_frame_info;
           P32[(old + 8)] = Hp - 4;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = GHC.Types.[]_closure+1;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c26c:
      _r23T::P32 = R1;
      goto c267;
  c267:
      if (Sp - <highSp> < SpLim) goto c26d; else goto c26e;
  c26e:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c26g; else goto c26f;
  c26g:
      HpAlloc = 8;
      goto c26d;
  c26d:
      R1 = _r23T::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26f:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c269::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r23T::P32, Hp - 4);
      if (_c269::I32 == 0) goto c26b; else goto c26a;
  c26b:
      call (I32[_r23T::P32])() args: 4, res: 0, upd: 4;
  c26a:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c26c:
      _r23T::P32 = R1;
      goto c267;
  c267:
      if (Sp - <highSp> < SpLim) goto c26d; else goto c26e;
  c26e:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c26g; else goto c26f;
  c26g:
      HpAlloc = 8;
      goto c26d;
  c26d:
      R1 = _r23T::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26f:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c269::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r23T::P32, Hp - 4);
      if (_c269::I32 == 0) goto c26b; else goto c26a;
  c26b:
      call (I32[_r23T::P32])() args: 4, res: 0, upd: 4;
  c26a:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c26c:
      _r23T::P32 = R1;
      goto c267;
  c267:
      if (Sp - <highSp> < SpLim) goto c26d; else goto c26e;
  c26e:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c26g; else goto c26f;
  c26g:
      HpAlloc = 8;
      goto c26d;
  c26d:
      R1 = _r23T::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26f:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c269::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r23T::P32, Hp - 4);
      if (_c269::I32 == 0) goto c26b; else goto c26a;
  c26b:
      call (I32[_r23T::P32])() args: 4, res: 0, upd: 4;
  c26a:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c26c:
      _r23T::P32 = R1;
      goto c267;
  c267:
      if (Sp - <highSp> < SpLim) goto c26d; else goto c26e;
  c26e:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c26g; else goto c26f;
  c26g:
      HpAlloc = 8;
      goto c26d;
  c26d:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26f:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c269::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c269::I32 == 0) goto c26b; else goto c26a;
  c26b:
      call (I32[_r23T::P32])() args: 4, res: 0, upd: 4;
  c26a:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c26c:
      _r23T::P32 = R1;
      goto c267;
  c267:
      if (Sp - 24 < SpLim) goto c26d; else goto c26e;
  c26e:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c26g; else goto c26f;
  c26g:
      HpAlloc = 8;
      goto c26d;
  c26d:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26f:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c269::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c269::I32 == 0) goto c26b; else goto c26a;
  c26b:
      call (I32[_r23T::P32])() args: 4, res: 0, upd: 4;
  c26a:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = GHC.Types.[]_closure+1;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c26c:
      goto c267;
  c267:
      if ((Sp + -24) < SpLim) goto c26d; else goto c26e;
  c26e:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c26g; else goto c26f;
  c26g:
      HpAlloc = 8;
      goto c26d;
  c26d:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26f:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c269::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c269::I32 == 0) goto c26b; else goto c26a;
  c26b:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c26a:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = GHC.Types.[]_closure+1;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c267, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c26a, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c26b, {}),
 (c26c, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c26d, {}),
 (c26e, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c26f, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c26g, {})]



==================== after setInfoTableStackMap ====================
lvl1_r23T_entry() //  [R1]
        { info_tbl: [(c26c,
                      label: lvl1_r23T_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c26c:
          goto c267;
      c267:
          if ((Sp + -24) < SpLim) goto c26d; else goto c26e;
      c26e:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c26g; else goto c26f;
      c26g:
          HpAlloc = 8;
          goto c26d;
      c26d:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c26f:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c269::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
          if (_c269::I32 == 0) goto c26b; else goto c26a;
      c26b:
          call (I32[R1])() args: 4, res: 0, upd: 4;
      c26a:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = GHC.Types.[]_closure+1;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
lvl1_r23T_entry() //  [R1]
        { info_tbl: [(c267,
                      label: lvl1_r23T_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c267:
          if ((Sp + -24) < SpLim) goto c26d; else goto c26e;
      c26e:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c26g; else goto c26f;
      c26g:
          HpAlloc = 8;
          goto c26d;
      c26d:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c26f:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c269::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
          if (_c269::I32 == 0) goto c26b; else goto c26a;
      c26b:
          call (I32[R1])() args: 4, res: 0, upd: 4;
      c26a:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = GHC.Types.[]_closure+1;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     lvl1_r23T_closure:
         const lvl1_r23T_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r23T_entry() //  [R1]
         { info_tbl: [(c267,
                       label: lvl1_r23T_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c267:
           if ((Sp + -24) < SpLim) goto c26d; else goto c26e;
       c26e:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c26g; else goto c26f;
       c26g:
           HpAlloc = 8;
           goto c26d;
       c26d:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c26f:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c269::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
           if (_c269::I32 == 0) goto c26b; else goto c26a;
       c26b:
           call (I32[R1])() args: 4, res: 0, upd: 4;
       c26a:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     lvl1_r23T_closure:
         const lvl1_r23T_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r23T_entry() //  [R1]
         { info_tbl: [(c267,
                       label: lvl1_r23T_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c267:
           if ((Sp + -24) < SpLim) goto c26d; else goto c26e;
       c26e:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c26g; else goto c26f;
       c26g:
           HpAlloc = 8;
           goto c26d;
       c26d:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c26f:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c269::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
           if (_c269::I32 == 0) goto c26b; else goto c26a;
       c26b:
           call (I32[R1])() args: 4, res: 0, upd: 4;
       c26a:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     go_r23U_closure:
         const go_r23U_info;
 },
 sat_s24g_entry() //  [R1]
         { info_tbl: [(c26W,
                       label: sat_s24g_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c26W:
           _s24g::P32 = R1;
           goto c26Q;
       c26Q:
           if (Sp - <highSp> < SpLim) goto c26X; else goto c26Y;
       c26X:
           R1 = _s24g::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c26Y:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _s24g::P32;
           _s24b::P32 = P32[_s24g::P32 + 8];
           _s247::I32 = I32[_s24g::P32 + 12];
           _s24e::I32 = _s247::I32;
           if (_s24e::I32 != 20) goto c26U; else goto c26V;
       c26U:
           _c270::I32 = _s24e::I32 + 1;
           _s24f::I32 = _c270::I32;
           I32[(old + 20)] = _s24f::I32;
           P32[(old + 16)] = _s24b::P32;
           call go_r23U_info() args: 20, res: 0, upd: 12;
       c26V:
           R1 = []_closure+1;
           call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
     }
 },
 go_r23U_entry() //  []
         { info_tbl: [(c278,
                       label: go_r23U_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 11} })]
           stack_info: arg_space: 12 updfr_space: Just 4
         }
     {offset
       c278:
           _s247::I32 = I32[(old + 12)];
           _s248::P32 = P32[(old + 8)];
           goto c26G;
       c26G:
           if (Sp - <highSp> < SpLim) goto c279; else goto c27a;
       c279:
           R1 = go_r23U_closure;
           I32[(old + 12)] = _s247::I32;
           P32[(old + 8)] = _s248::P32;
           call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
       c27a:
           I32[(young<c26I> + 4)] = c26I;
           R1 = _s248::P32;
           if (R1 & 3 != 0) goto c26I; else goto c26J;
       c26J:
           call (I32[R1])(R1) returns to c26I, args: 4, res: 4, upd: 4;
       c26I:
           _s249::P32 = R1;
           _c274::P32 = _s249::P32 & 3;
           if (_c274::P32 >= 2) goto c276; else goto c277;
       c276:
           goto c273;
       c273:
           Hp = Hp + 48;
           if (Hp > HpLim) goto c27i; else goto c27h;
       c27i:
           HpAlloc = 48;
           goto c27g;
       c27g:
           R1 = _s249::P32;
           call stg_gc_unpt_r1(R1) returns to c26I, args: 4, res: 4, upd: 4;
       c27h:
           _s24a::P32 = P32[_s249::P32 + 2];
           _s24b::P32 = P32[_s249::P32 + 6];
           I32[Hp - 44] = sat_s24g_info;
           P32[Hp - 36] = _s24b::P32;
           I32[Hp - 32] = _s247::I32;
           _c26O::P32 = Hp - 44;
           I32[Hp - 28] = GHC.Types.I#_con_info;
           I32[Hp - 24] = _s247::I32;
           _c27d::P32 = Hp - 27;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = _c27d::P32;
           P32[Hp - 12] = _s24a::P32;
           _c27e::P32 = Hp - 19;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = _c27e::P32;
           P32[Hp] = _c26O::P32;
           _c27f::P32 = Hp - 6;
           R1 = _c27f::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
       c277:
           goto c272;
       c272:
           R1 = []_closure+1;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c26W:
      _s24g::P32 = R1;
      goto c26Q;
  c26Q:
      if (Sp - <highSp> < SpLim) goto c26X; else goto c26Y;
  c26X:
      R1 = _s24g::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26Y:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24g::P32;
      _s24b::P32 = P32[_s24g::P32 + 8];
      _s247::I32 = I32[_s24g::P32 + 12];
      _s24e::I32 = _s247::I32;
      if (_s24e::I32 != 20) goto c26U; else goto c26V;
  c26U:
      _c270::I32 = _s24e::I32 + 1;
      _s24f::I32 = _c270::I32;
      I32[(old + 20)] = _s24f::I32;
      P32[(old + 16)] = _s24b::P32;
      call go_r23U_info() args: 20, res: 0, upd: 12;
  c26V:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c26W:
      _s24g::P32 = R1;
      goto c26Q;
  c26Q:
      if (Sp - <highSp> < SpLim) goto c26X; else goto c26Y;
  c26X:
      R1 = _s24g::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26Y:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24g::P32;
      _s24b::P32 = P32[_s24g::P32 + 8];
      _s247::I32 = I32[_s24g::P32 + 12];
      _s24e::I32 = _s247::I32;
      if (_s24e::I32 != 20) goto c26U; else goto c26V;
  c26U:
      _c270::I32 = _s24e::I32 + 1;
      _s24f::I32 = _c270::I32;
      I32[(old + 20)] = _s24f::I32;
      P32[(old + 16)] = _s24b::P32;
      call go_r23U_info() args: 20, res: 0, upd: 12;
  c26V:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c26W:
      _s24g::P32 = R1;
      goto c26Q;
  c26Q:
      if (Sp - <highSp> < SpLim) goto c26X; else goto c26Y;
  c26X:
      R1 = _s24g::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26Y:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24g::P32;
      _s24b::P32 = P32[_s24g::P32 + 8];
      _s247::I32 = I32[_s24g::P32 + 12];
      _s24e::I32 = _s247::I32;
      if (_s24e::I32 != 20) goto c26U; else goto c26V;
  c26U:
      _c270::I32 = _s24e::I32 + 1;
      _s24f::I32 = _c270::I32;
      I32[(old + 20)] = _s24f::I32;
      P32[(old + 16)] = _s24b::P32;
      call go_r23U_info() args: 20, res: 0, upd: 12;
  c26V:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c26W:
      _s24g::P32 = R1;
      goto c26Q;
  c26Q:
      if (Sp - <highSp> < SpLim) goto c26X; else goto c26Y;
  c26X:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26Y:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s24b::P32 = P32[R1 + 8];
      _s247::I32 = I32[R1 + 12];
      _s24e::I32 = _s247::I32;
      if (_s247::I32 != 20) goto c26U; else goto c26V;
  c26U:
      _c270::I32 = _s247::I32 + 1;
      _s24f::I32 = _c270::I32;
      I32[(old + 20)] = _c270::I32;
      P32[(old + 16)] = _s24b::P32;
      call go_r23U_info() args: 20, res: 0, upd: 12;
  c26V:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c26W:
      _s24g::P32 = R1;
      goto c26Q;
  c26Q:
      if (Sp - 16 < SpLim) goto c26X; else goto c26Y;
  c26X:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26Y:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _s24b::P32 = P32[R1 + 8];
      _s247::I32 = I32[R1 + 12];
      _s24e::I32 = _s247::I32;
      if (_s247::I32 != 20) goto c26U; else goto c26V;
  c26U:
      _c270::I32 = _s247::I32 + 1;
      _s24f::I32 = _c270::I32;
      I32[Sp - 16] = _c270::I32;
      P32[Sp - 12] = _s24b::P32;
      Sp = Sp - 16;
      call go_r23U_info() args: 20, res: 0, upd: 12;
  c26V:
      R1 = []_closure+1;
      Sp = Sp - 8;
      call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c26W:
      goto c26Q;
  c26Q:
      if ((Sp + -16) < SpLim) goto c26X; else goto c26Y;
  c26X:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c26Y:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _s247::I32 = I32[R1 + 12];
      if (_s247::I32 != 20) goto c26U; else goto c26V;
  c26U:
      I32[Sp - 16] = _s247::I32 + 1;
      P32[Sp - 12] = P32[R1 + 8];
      Sp = Sp - 16;
      call go_r23U_info() args: 20, res: 0, upd: 12;
  c26V:
      R1 = []_closure+1;
      Sp = Sp - 8;
      call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c26Q, {}), (c26U, {}), (c26V, {}), (c26W, {}), (c26X, {}),
 (c26Y, {})]



==================== after setInfoTableStackMap ====================
sat_s24g_entry() //  [R1]
        { info_tbl: [(c26W,
                      label: sat_s24g_info
                      rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c26W:
          goto c26Q;
      c26Q:
          if ((Sp + -16) < SpLim) goto c26X; else goto c26Y;
      c26X:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c26Y:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          _s247::I32 = I32[R1 + 12];
          if (_s247::I32 != 20) goto c26U; else goto c26V;
      c26U:
          I32[Sp - 16] = _s247::I32 + 1;
          P32[Sp - 12] = P32[R1 + 8];
          Sp = Sp - 16;
          call go_r23U_info() args: 20, res: 0, upd: 12;
      c26V:
          R1 = []_closure+1;
          Sp = Sp - 8;
          call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_s24g_entry() //  [R1]
        { info_tbl: [(c26Q,
                      label: sat_s24g_info
                      rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c26Q:
          if ((Sp + -16) < SpLim) goto c26X; else goto c26Y;
      c26X:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c26Y:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          _s247::I32 = I32[R1 + 12];
          if (_s247::I32 != 20) goto c26U; else goto c26V;
      c26U:
          I32[Sp - 16] = _s247::I32 + 1;
          P32[Sp - 12] = P32[R1 + 8];
          Sp = Sp - 16;
          call go_r23U_info() args: 20, res: 0, upd: 12;
      c26V:
          R1 = []_closure+1;
          Sp = Sp - 8;
          call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  c278:
      _s247::I32 = I32[(old + 12)];
      _s248::P32 = P32[(old + 8)];
      goto c26G;
  c26G:
      if (Sp - <highSp> < SpLim) goto c279; else goto c27a;
  c279:
      R1 = go_r23U_closure;
      I32[(old + 12)] = _s247::I32;
      P32[(old + 8)] = _s248::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c27a:
      I32[(young<c26I> + 4)] = c26I;
      R1 = _s248::P32;
      if (R1 & 3 != 0) goto c26I; else goto c26J;
  c26J:
      call (I32[R1])(R1) returns to c26I, args: 4, res: 4, upd: 4;
  c26I:
      _s249::P32 = R1;
      _c274::P32 = _s249::P32 & 3;
      if (_c274::P32 >= 2) goto c273; else goto c272;
  c273:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c27i; else goto c27h;
  c27i:
      HpAlloc = 48;
      goto c27g;
  c27g:
      R1 = _s249::P32;
      call stg_gc_unpt_r1(R1) returns to c26I, args: 4, res: 4, upd: 4;
  c27h:
      _s24a::P32 = P32[_s249::P32 + 2];
      _s24b::P32 = P32[_s249::P32 + 6];
      I32[Hp - 44] = sat_s24g_info;
      P32[Hp - 36] = _s24b::P32;
      I32[Hp - 32] = _s247::I32;
      _c26O::P32 = Hp - 44;
      I32[Hp - 28] = GHC.Types.I#_con_info;
      I32[Hp - 24] = _s247::I32;
      _c27d::P32 = Hp - 27;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _c27d::P32;
      P32[Hp - 12] = _s24a::P32;
      _c27e::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c27e::P32;
      P32[Hp] = _c26O::P32;
      _c27f::P32 = Hp - 6;
      R1 = _c27f::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c272:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c278:
      _s247::I32 = I32[(old + 12)];
      _s248::P32 = P32[(old + 8)];
      goto c26G;
  c26G:
      if (Sp - <highSp> < SpLim) goto c279; else goto c27a;
  c279:
      R1 = go_r23U_closure;
      I32[(old + 12)] = _s247::I32;
      P32[(old + 8)] = _s248::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c27a:
      I32[(young<c26I> + 4)] = c26I;
      R1 = _s248::P32;
      if (R1 & 3 != 0) goto c26I; else goto c26J;
  c26J:
      call (I32[R1])(R1) returns to c26I, args: 4, res: 4, upd: 4;
  c26I:
      _s249::P32 = R1;
      _c274::P32 = _s249::P32 & 3;
      if (_c274::P32 >= 2) goto c273; else goto c272;
  c273:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c27i; else goto c27h;
  c27i:
      HpAlloc = 48;
      goto c27g;
  c27g:
      R1 = _s249::P32;
      call stg_gc_unpt_r1(R1) returns to c26I, args: 4, res: 4, upd: 4;
  c27h:
      _s24a::P32 = P32[_s249::P32 + 2];
      _s24b::P32 = P32[_s249::P32 + 6];
      I32[Hp - 44] = sat_s24g_info;
      P32[Hp - 36] = _s24b::P32;
      I32[Hp - 32] = _s247::I32;
      _c26O::P32 = Hp - 44;
      I32[Hp - 28] = GHC.Types.I#_con_info;
      I32[Hp - 24] = _s247::I32;
      _c27d::P32 = Hp - 27;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _c27d::P32;
      P32[Hp - 12] = _s24a::P32;
      _c27e::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c27e::P32;
      P32[Hp] = _c26O::P32;
      _c27f::P32 = Hp - 6;
      R1 = _c27f::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c272:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c278:
      _s247::I32 = I32[(old + 12)];
      _s248::P32 = P32[(old + 8)];
      goto c26G;
  c26G:
      if (Sp - <highSp> < SpLim) goto c279; else goto c27a;
  c279:
      R1 = go_r23U_closure;
      I32[(old + 12)] = _s247::I32;
      P32[(old + 8)] = _s248::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c27a:
      I32[(young<c26I> + 4)] = c26I;
      R1 = _s248::P32;
      if (R1 & 3 != 0) goto c26I; else goto c26J;
  c26J:
      call (I32[R1])(R1) returns to c26I, args: 4, res: 4, upd: 4;
  c26I:
      _s249::P32 = R1;
      _c274::P32 = _s249::P32 & 3;
      if (_c274::P32 >= 2) goto c273; else goto c272;
  c273:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c27i; else goto c27h;
  c27i:
      HpAlloc = 48;
      goto c27g;
  c27g:
      R1 = _s249::P32;
      call stg_gc_unpt_r1(R1) returns to c26I, args: 4, res: 4, upd: 4;
  c27h:
      _s24a::P32 = P32[_s249::P32 + 2];
      _s24b::P32 = P32[_s249::P32 + 6];
      I32[Hp - 44] = sat_s24g_info;
      P32[Hp - 36] = _s24b::P32;
      I32[Hp - 32] = _s247::I32;
      _c26O::P32 = Hp - 44;
      I32[Hp - 28] = GHC.Types.I#_con_info;
      I32[Hp - 24] = _s247::I32;
      _c27d::P32 = Hp - 27;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _c27d::P32;
      P32[Hp - 12] = _s24a::P32;
      _c27e::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c27e::P32;
      P32[Hp] = _c26O::P32;
      _c27f::P32 = Hp - 6;
      R1 = _c27f::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c272:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c278:
      _s247::I32 = I32[(old + 12)];
      _s248::P32 = P32[(old + 8)];
      goto c26G;
  c26G:
      if (Sp - <highSp> < SpLim) goto c279; else goto c27a;
  c279:
      R1 = go_r23U_closure;
      I32[(old + 12)] = _s247::I32;
      P32[(old + 8)] = _s248::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c27a:
      I32[(young<c26I> + 4)] = c26I;
      R1 = _s248::P32;
      if (_s248::P32 & 3 != 0) goto c26I; else goto c26J;
  c26J:
      call (I32[_s248::P32])(R1) returns to c26I, args: 4, res: 4, upd: 4;
  c26I:
      _s249::P32 = R1;
      _c274::P32 = R1 & 3;
      if (_c274::P32 >= 2) goto c273; else goto c272;
  c273:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c27i; else goto c27h;
  c27i:
      HpAlloc = 48;
      goto c27g;
  c27g:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c26I, args: 4, res: 4, upd: 4;
  c27h:
      _s24a::P32 = P32[R1 + 2];
      _s24b::P32 = P32[R1 + 6];
      I32[Hp - 44] = sat_s24g_info;
      P32[Hp - 36] = _s24b::P32;
      I32[Hp - 32] = _s247::I32;
      _c26O::P32 = Hp - 44;
      I32[Hp - 28] = GHC.Types.I#_con_info;
      I32[Hp - 24] = _s247::I32;
      _c27d::P32 = Hp - 27;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _c27d::P32;
      P32[Hp - 12] = _s24a::P32;
      _c27e::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c27e::P32;
      P32[Hp] = _c26O::P32;
      _c27f::P32 = Hp - 6;
      R1 = _c27f::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c272:
      R1 = []_closure+1;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c278:
      _s247::I32 = I32[Sp];
      _s248::P32 = P32[Sp + 4];
      goto c26G;
  c26G:
      if (Sp - 4 < SpLim) goto c279; else goto c27a;
  c279:
      R1 = go_r23U_closure;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c27a:
      I32[Sp - 4] = c26I;
      R1 = _s248::P32;
      Sp = Sp - 4;
      if (_s248::P32 & 3 != 0) goto c26I; else goto c26J;
  c26J:
      call (I32[_s248::P32])(R1) returns to c26I, args: 4, res: 4, upd: 4;
  c26I:
      _s247::I32 = I32[Sp + 4];
      _s249::P32 = R1;
      _c274::P32 = R1 & 3;
      if (_c274::P32 >= 2) goto c273; else goto c272;
  c273:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c27i; else goto c27h;
  c27i:
      HpAlloc = 48;
      goto c27g;
  c27g:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c26I, args: 4, res: 4, upd: 4;
  c27h:
      _s24a::P32 = P32[R1 + 2];
      _s24b::P32 = P32[R1 + 6];
      I32[Hp - 44] = sat_s24g_info;
      P32[Hp - 36] = _s24b::P32;
      I32[Hp - 32] = _s247::I32;
      _c26O::P32 = Hp - 44;
      I32[Hp - 28] = GHC.Types.I#_con_info;
      I32[Hp - 24] = _s247::I32;
      _c27d::P32 = Hp - 27;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = _c27d::P32;
      P32[Hp - 12] = _s24a::P32;
      _c27e::P32 = Hp - 19;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c27e::P32;
      P32[Hp] = _c26O::P32;
      _c27f::P32 = Hp - 6;
      R1 = _c27f::P32;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  c272:
      R1 = []_closure+1;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c278:
      goto c26G;
  c26G:
      if ((Sp + -4) < SpLim) goto c279; else goto c27a;
  c279:
      R1 = go_r23U_closure;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c27a:
      I32[Sp - 4] = c26I;
      _s248::P32 = P32[Sp + 4];
      R1 = _s248::P32;
      Sp = Sp - 4;
      if (_s248::P32 & 3 != 0) goto c26I; else goto c26J;
  c26J:
      call (I32[_s248::P32])(R1) returns to c26I, args: 4, res: 4, upd: 4;
  c26I:
      if (R1 & 3 >= 2) goto c273; else goto c272;
  c273:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c27i; else goto c27h;
  c27i:
      HpAlloc = 48;
      goto c27g;
  c27g:
      call stg_gc_unpt_r1(R1) returns to c26I, args: 4, res: 4, upd: 4;
  c27h:
      _s24a::P32 = P32[R1 + 2];
      _s24b::P32 = P32[R1 + 6];
      I32[Hp - 44] = sat_s24g_info;
      P32[Hp - 36] = _s24b::P32;
      _s247::I32 = I32[Sp + 4];
      I32[Hp - 32] = _s247::I32;
      I32[Hp - 28] = GHC.Types.I#_con_info;
      I32[Hp - 24] = _s247::I32;
      I32[Hp - 20] = (,)_con_info;
      P32[Hp - 16] = Hp - 27;
      P32[Hp - 12] = _s24a::P32;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = Hp - 19;
      P32[Hp] = Hp - 44;
      R1 = Hp - 6;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
  c272:
      R1 = []_closure+1;
      Sp = Sp + 12;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c26G, {sat_s24g_closure}), (c26I, {sat_s24g_closure}),
 (c26J, {sat_s24g_closure}), (c272, {}), (c273, {sat_s24g_closure}),
 (c278, {sat_s24g_closure}), (c279, {}), (c27a, {sat_s24g_closure}),
 (c27g, {sat_s24g_closure}), (c27h, {sat_s24g_closure}),
 (c27i, {sat_s24g_closure})]



==================== after setInfoTableStackMap ====================
go_r23U_entry() //  []
        { info_tbl: [(c26I,
                      label: block_c26I_info
                      rep:StackRep [True, True]),
                     (c278,
                      label: go_r23U_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 11} })]
          stack_info: arg_space: 12 updfr_space: Just 4
        }
    {offset
      c278:
          goto c26G;
      c26G:
          if ((Sp + -4) < SpLim) goto c279; else goto c27a;
      c279:
          R1 = go_r23U_closure;
          call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
      c27a:
          I32[Sp - 4] = c26I;
          _s248::P32 = P32[Sp + 4];
          R1 = _s248::P32;
          Sp = Sp - 4;
          if (_s248::P32 & 3 != 0) goto c26I; else goto c26J;
      c26J:
          call (I32[_s248::P32])(R1) returns to c26I, args: 4, res: 4, upd: 4;
      c26I:
          if (R1 & 3 >= 2) goto c273; else goto c272;
      c273:
          Hp = Hp + 48;
          if (Hp > HpLim) goto c27i; else goto c27h;
      c27i:
          HpAlloc = 48;
          goto c27g;
      c27g:
          call stg_gc_unpt_r1(R1) returns to c26I, args: 4, res: 4, upd: 4;
      c27h:
          _s24a::P32 = P32[R1 + 2];
          _s24b::P32 = P32[R1 + 6];
          I32[Hp - 44] = sat_s24g_info;
          P32[Hp - 36] = _s24b::P32;
          _s247::I32 = I32[Sp + 4];
          I32[Hp - 32] = _s247::I32;
          I32[Hp - 28] = GHC.Types.I#_con_info;
          I32[Hp - 24] = _s247::I32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = Hp - 27;
          P32[Hp - 12] = _s24a::P32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 44;
          R1 = Hp - 6;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      c272:
          R1 = []_closure+1;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
go_r23U_entry() //  []
        { info_tbl: [(c26G,
                      label: go_r23U_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 11} }),
                     (c26I,
                      label: block_c26I_info
                      rep:StackRep [True, True])]
          stack_info: arg_space: 12 updfr_space: Just 4
        }
    {offset
      c26G:
          if ((Sp + -4) < SpLim) goto c279; else goto c27a;
      c279:
          R1 = go_r23U_closure;
          call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
      c27a:
          I32[Sp - 4] = c26I;
          _s248::P32 = P32[Sp + 4];
          R1 = _s248::P32;
          Sp = Sp - 4;
          if (_s248::P32 & 3 != 0) goto c26I; else goto c26J;
      c26J:
          call (I32[_s248::P32])(R1) returns to c26I, args: 4, res: 4, upd: 4;
      c26I:
          if (R1 & 3 >= 2) goto c273; else goto c272;
      c273:
          Hp = Hp + 48;
          if (Hp > HpLim) goto c27i; else goto c27h;
      c27i:
          HpAlloc = 48;
          goto c27g;
      c27g:
          call stg_gc_unpt_r1(R1) returns to c26I, args: 4, res: 4, upd: 4;
      c27h:
          _s24a::P32 = P32[R1 + 2];
          _s24b::P32 = P32[R1 + 6];
          I32[Hp - 44] = sat_s24g_info;
          P32[Hp - 36] = _s24b::P32;
          _s247::I32 = I32[Sp + 4];
          I32[Hp - 32] = _s247::I32;
          I32[Hp - 28] = GHC.Types.I#_con_info;
          I32[Hp - 24] = _s247::I32;
          I32[Hp - 20] = (,)_con_info;
          P32[Hp - 16] = Hp - 27;
          P32[Hp - 12] = _s24a::P32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 19;
          P32[Hp] = Hp - 44;
          R1 = Hp - 6;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
      c272:
          R1 = []_closure+1;
          Sp = Sp + 12;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     go_r23U_closure:
         const go_r23U_info;
 },
 sat_s24g_entry() //  [R1]
         { info_tbl: [(c26Q,
                       label: sat_s24g_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c26Q:
           if ((Sp + -16) < SpLim) goto c26X; else goto c26Y;
       c26X:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c26Y:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           _s247::I32 = I32[R1 + 12];
           if (_s247::I32 != 20) goto c26U; else goto c26V;
       c26U:
           I32[Sp - 16] = _s247::I32 + 1;
           P32[Sp - 12] = P32[R1 + 8];
           Sp = Sp - 16;
           call go_r23U_info() args: 20, res: 0, upd: 12;
       c26V:
           R1 = []_closure+1;
           Sp = Sp - 8;
           call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
     }
 },
 go_r23U_entry() //  []
         { info_tbl: [(c26G,
                       label: go_r23U_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 11} }),
                      (c26I,
                       label: block_c26I_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 12 updfr_space: Just 4
         }
     {offset
       c26G:
           if ((Sp + -4) < SpLim) goto c279; else goto c27a;
       c279:
           R1 = go_r23U_closure;
           call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
       c27a:
           I32[Sp - 4] = c26I;
           _s248::P32 = P32[Sp + 4];
           R1 = _s248::P32;
           Sp = Sp - 4;
           if (_s248::P32 & 3 != 0) goto c26I; else goto c26J;
       c26J:
           call (I32[_s248::P32])(R1) returns to c26I, args: 4, res: 4, upd: 4;
       c26I:
           if (R1 & 3 >= 2) goto c273; else goto c272;
       c273:
           Hp = Hp + 48;
           if (Hp > HpLim) goto c27i; else goto c27h;
       c27i:
           HpAlloc = 48;
           goto c27g;
       c27g:
           call stg_gc_unpt_r1(R1) returns to c26I, args: 4, res: 4, upd: 4;
       c27h:
           _s24a::P32 = P32[R1 + 2];
           _s24b::P32 = P32[R1 + 6];
           I32[Hp - 44] = sat_s24g_info;
           P32[Hp - 36] = _s24b::P32;
           _s247::I32 = I32[Sp + 4];
           I32[Hp - 32] = _s247::I32;
           I32[Hp - 28] = GHC.Types.I#_con_info;
           I32[Hp - 24] = _s247::I32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = Hp - 27;
           P32[Hp - 12] = _s24a::P32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 44;
           R1 = Hp - 6;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       c272:
           R1 = []_closure+1;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     go_r23U_closure:
         const go_r23U_info;
 },
 sat_s24g_entry() //  [R1]
         { info_tbl: [(c26Q,
                       label: sat_s24g_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c26Q:
           if ((Sp + -16) < SpLim) goto c26X; else goto c26Y;
       c26X:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c26Y:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           _s247::I32 = I32[R1 + 12];
           if (_s247::I32 != 20) goto c26U; else goto c26V;
       c26U:
           I32[Sp - 16] = _s247::I32 + 1;
           P32[Sp - 12] = P32[R1 + 8];
           Sp = Sp - 16;
           call go_r23U_info() args: 20, res: 0, upd: 12;
       c26V:
           R1 = []_closure+1;
           Sp = Sp - 8;
           call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
     }
 },
 go_r23U_entry() //  []
         { info_tbl: [(c26G,
                       label: go_r23U_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 11} }),
                      (c26I,
                       label: block_c26I_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 12 updfr_space: Just 4
         }
     {offset
       c26G:
           if ((Sp + -4) < SpLim) goto c279; else goto c27a;
       c279:
           R1 = go_r23U_closure;
           call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
       c27a:
           I32[Sp - 4] = c26I;
           _s248::P32 = P32[Sp + 4];
           R1 = _s248::P32;
           Sp = Sp - 4;
           if (_s248::P32 & 3 != 0) goto c26I; else goto c26J;
       c26J:
           call (I32[_s248::P32])(R1) returns to c26I, args: 4, res: 4, upd: 4;
       c26I:
           if (R1 & 3 >= 2) goto c273; else goto c272;
       c273:
           Hp = Hp + 48;
           if (Hp > HpLim) goto c27i; else goto c27h;
       c27i:
           HpAlloc = 48;
           goto c27g;
       c27g:
           call stg_gc_unpt_r1(R1) returns to c26I, args: 4, res: 4, upd: 4;
       c27h:
           _s24a::P32 = P32[R1 + 2];
           _s24b::P32 = P32[R1 + 6];
           I32[Hp - 44] = sat_s24g_info;
           P32[Hp - 36] = _s24b::P32;
           _s247::I32 = I32[Sp + 4];
           I32[Hp - 32] = _s247::I32;
           I32[Hp - 28] = GHC.Types.I#_con_info;
           I32[Hp - 24] = _s247::I32;
           I32[Hp - 20] = (,)_con_info;
           P32[Hp - 16] = Hp - 27;
           P32[Hp - 12] = _s24a::P32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 19;
           P32[Hp] = Hp - 44;
           R1 = Hp - 6;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
       c272:
           R1 = []_closure+1;
           Sp = Sp + 12;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main_go_closure:
         const Main.main_go_info;
         const 0;
 },
 sat_s24B_entry() //  [R1]
         { info_tbl: [(c28Y,
                       label: sat_s24B_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28Y:
           _s24B::P32 = R1;
           goto c28S;
       c28S:
           if (Sp - <highSp> < SpLim) goto c28Z; else goto c290;
       c28Z:
           R1 = _s24B::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c290:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _s24B::P32;
           _s24h::I32 = I32[_s24B::P32 + 8];
           _s24z::I32 = _s24h::I32;
           if (_s24z::I32 != 20) goto c28W; else goto c28X;
       c28W:
           _c292::I32 = _s24z::I32 + 1;
           _s24A::I32 = _c292::I32;
           I32[(old + 16)] = _s24A::I32;
           call Main.main_go_info() args: 16, res: 0, upd: 12;
       c28X:
           R1 = []_closure+1;
           call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
     }
 },
 sat_s24u_entry() //  [R1]
         { info_tbl: [(c293,
                       label: sat_s24u_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c293:
           _s24u::P32 = R1;
           goto c289;
       c289:
           if (Sp - <highSp> < SpLim) goto c294; else goto c29l;
       c294:
           R1 = _s24u::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c29l:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _s24u::P32;
           _s24h::I32 = I32[_s24u::P32 + 8];
           _c28b::I32 = 3 + _s24h::I32;
           _s24q::I32 = _c28b::I32;
           _c28e::I32 = %MO_S_Ge_W32(_s24q::I32, _s24h::I32);
           if (_c28e::I32 >= 1) goto c29n; else goto c29o;
       c29n:
           goto c29g;
       c29g:
           I32[(young<c29f> + 4)] = c29f;
           P32[(young<c29f> + 32)] = lvl_r23Q_closure+3;
           P32[(young<c29f> + 28)] = n1_r23S_closure+1;
           I32[(young<c29f> + 24)] = _s24h::I32;
           I32[(young<c29f> + 20)] = _s24q::I32;
           I32[(young<c29f> + 16)] = 20;
           I32[(young<c29f> + 12)] = stg_ap_p_info;
           P32[(young<c29f> + 8)] = xs2_r23P_closure+2;
           call GHC.Enum.efdtIntUpFB_info() returns to c29f, args: 32, res: 4, upd: 12;
       c29f:
           _s24t::P32 = R1;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = _s24t::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
       c29o:
           goto c299;
       c299:
           I32[(young<c297> + 4)] = c297;
           P32[(young<c297> + 32)] = lvl_r23Q_closure+3;
           P32[(young<c297> + 28)] = n1_r23S_closure+1;
           I32[(young<c297> + 24)] = _s24h::I32;
           I32[(young<c297> + 20)] = _s24q::I32;
           I32[(young<c297> + 16)] = 20;
           I32[(young<c297> + 12)] = stg_ap_p_info;
           P32[(young<c297> + 8)] = xs2_r23P_closure+2;
           call GHC.Enum.efdtIntDnFB_info() returns to c297, args: 32, res: 4, upd: 12;
       c297:
           _s24s::P32 = R1;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = _s24s::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24p_entry() //  [R1]
         { info_tbl: [(c29p,
                       label: sat_s24p_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c29p:
           _s24p::P32 = R1;
           goto c28x;
       c28x:
           if (Sp - <highSp> < SpLim) goto c29q; else goto c29H;
       c29q:
           R1 = _s24p::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c29H:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _s24p::P32;
           _s24h::I32 = I32[_s24p::P32 + 8];
           _c28z::I32 = 2 + _s24h::I32;
           _s24l::I32 = _c28z::I32;
           _c28C::I32 = %MO_S_Ge_W32(_s24l::I32, _s24h::I32);
           if (_c28C::I32 >= 1) goto c29J; else goto c29K;
       c29J:
           goto c29C;
       c29C:
           I32[(young<c29B> + 4)] = c29B;
           P32[(young<c29B> + 32)] = lvl_r23Q_closure+3;
           P32[(young<c29B> + 28)] = n_r23R_closure+1;
           I32[(young<c29B> + 24)] = _s24h::I32;
           I32[(young<c29B> + 20)] = _s24l::I32;
           I32[(young<c29B> + 16)] = 20;
           I32[(young<c29B> + 12)] = stg_ap_p_info;
           P32[(young<c29B> + 8)] = xs1_r23N_closure+2;
           call GHC.Enum.efdtIntUpFB_info() returns to c29B, args: 32, res: 4, upd: 12;
       c29B:
           _s24o::P32 = R1;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = _s24o::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
       c29K:
           goto c29v;
       c29v:
           I32[(young<c29t> + 4)] = c29t;
           P32[(young<c29t> + 32)] = lvl_r23Q_closure+3;
           P32[(young<c29t> + 28)] = n_r23R_closure+1;
           I32[(young<c29t> + 24)] = _s24h::I32;
           I32[(young<c29t> + 20)] = _s24l::I32;
           I32[(young<c29t> + 16)] = 20;
           I32[(young<c29t> + 12)] = stg_ap_p_info;
           P32[(young<c29t> + 8)] = xs1_r23N_closure+2;
           call GHC.Enum.efdtIntDnFB_info() returns to c29t, args: 32, res: 4, upd: 12;
       c29t:
           _s24n::P32 = R1;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = _s24n::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24k_entry() //  [R1]
         { info_tbl: [(c29S,
                       label: sat_s24k_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c29S:
           _s24k::P32 = R1;
           goto c28P;
       c28P:
           if (Sp - <highSp> < SpLim) goto c29T; else goto c2a0;
       c29T:
           R1 = _s24k::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2a0:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _s24k::P32;
           _s24h::I32 = I32[_s24k::P32 + 8];
           _c28R::I32 = %MO_S_Gt_W32(_s24h::I32, 20);
           if (_c28R::I32 >= 1) goto c29Q; else goto c29R;
       c29Q:
           goto c29O;
       c29O:
           R1 = lvl1_r23T_closure;
           call (I32[R1])(R1) args: 12, res: 0, upd: 12;
       c29R:
           goto c29N;
       c29N:
           I32[(young<c29V> + 4)] = c29V;
           I32[(young<c29V> + 12)] = _s24h::I32;
           P32[(young<c29V> + 8)] = xs_r23L_closure+2;
           call go_r23U_info() returns to c29V, args: 12, res: 4, upd: 12;
       c29V:
           _s24j::P32 = R1;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = _s24j::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24y_entry() //  [R1]
         { info_tbl: [(c2a2,
                       label: sat_s24y_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2a2:
           _s24y::P32 = R1;
           goto c285;
       c285:
           if (Sp - <highSp> < SpLim) goto c2a3; else goto c2a4;
       c2a4:
           Hp = Hp + 72;
           if (Hp > HpLim) goto c2a6; else goto c2a5;
       c2a6:
           HpAlloc = 72;
           goto c2a3;
       c2a3:
           R1 = _s24y::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2a5:
           I32[(old + 12)] = stg_upd_frame_info;
           P32[(old + 8)] = _s24y::P32;
           _s24h::I32 = I32[_s24y::P32 + 8];
           I32[Hp - 68] = sat_s24u_info;
           I32[Hp - 60] = _s24h::I32;
           _c287::P32 = Hp - 68;
           I32[Hp - 56] = :_con_info;
           P32[Hp - 52] = _c287::P32;
           P32[Hp - 48] = GHC.Types.[]_closure+1;
           _c28u::P32 = Hp - 54;
           I32[Hp - 44] = sat_s24p_info;
           I32[Hp - 36] = _s24h::I32;
           _c28v::P32 = Hp - 44;
           I32[Hp - 32] = :_con_info;
           P32[Hp - 28] = _c28v::P32;
           P32[Hp - 24] = _c28u::P32;
           _c28M::P32 = Hp - 30;
           I32[Hp - 20] = sat_s24k_info;
           I32[Hp - 12] = _s24h::I32;
           _c28N::P32 = Hp - 20;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = _c28N::P32;
           P32[Hp] = _c28M::P32;
           _c2a1::P32 = Hp - 6;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = _c2a1::P32;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 },
 Main.main_go_entry() //  []
         { info_tbl: [(c2a8,
                       label: Main.main_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c2a8:
           _s24h::I32 = I32[(old + 8)];
           goto c27Z;
       c27Z:
           if (Sp - <highSp> < SpLim) goto c2a9; else goto c2aa;
       c2aa:
           Hp = Hp + 36;
           if (Hp > HpLim) goto c2ac; else goto c2ab;
       c2ac:
           HpAlloc = 36;
           goto c2a9;
       c2a9:
           R1 = Main.main_go_closure;
           I32[(old + 8)] = _s24h::I32;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       c2ab:
           I32[Hp - 32] = sat_s24B_info;
           I32[Hp - 24] = _s24h::I32;
           _c281::P32 = Hp - 32;
           I32[Hp - 20] = sat_s24y_info;
           I32[Hp - 12] = _s24h::I32;
           _c283::P32 = Hp - 20;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = _c283::P32;
           P32[Hp] = _c281::P32;
           _c2a7::P32 = Hp - 6;
           R1 = _c2a7::P32;
           call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c28Y:
      _s24B::P32 = R1;
      goto c28S;
  c28S:
      if (Sp - <highSp> < SpLim) goto c28Z; else goto c290;
  c28Z:
      R1 = _s24B::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c290:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24B::P32;
      _s24h::I32 = I32[_s24B::P32 + 8];
      _s24z::I32 = _s24h::I32;
      if (_s24z::I32 != 20) goto c28W; else goto c28X;
  c28W:
      _c292::I32 = _s24z::I32 + 1;
      _s24A::I32 = _c292::I32;
      I32[(old + 16)] = _s24A::I32;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
  c28X:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c28Y:
      _s24B::P32 = R1;
      goto c28S;
  c28S:
      if (Sp - <highSp> < SpLim) goto c28Z; else goto c290;
  c28Z:
      R1 = _s24B::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c290:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24B::P32;
      _s24h::I32 = I32[_s24B::P32 + 8];
      _s24z::I32 = _s24h::I32;
      if (_s24z::I32 != 20) goto c28W; else goto c28X;
  c28W:
      _c292::I32 = _s24z::I32 + 1;
      _s24A::I32 = _c292::I32;
      I32[(old + 16)] = _s24A::I32;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
  c28X:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c28Y:
      _s24B::P32 = R1;
      goto c28S;
  c28S:
      if (Sp - <highSp> < SpLim) goto c28Z; else goto c290;
  c28Z:
      R1 = _s24B::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c290:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24B::P32;
      _s24h::I32 = I32[_s24B::P32 + 8];
      _s24z::I32 = _s24h::I32;
      if (_s24z::I32 != 20) goto c28W; else goto c28X;
  c28W:
      _c292::I32 = _s24z::I32 + 1;
      _s24A::I32 = _c292::I32;
      I32[(old + 16)] = _s24A::I32;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
  c28X:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c28Y:
      _s24B::P32 = R1;
      goto c28S;
  c28S:
      if (Sp - <highSp> < SpLim) goto c28Z; else goto c290;
  c28Z:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c290:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s24h::I32 = I32[R1 + 8];
      _s24z::I32 = _s24h::I32;
      if (_s24h::I32 != 20) goto c28W; else goto c28X;
  c28W:
      _c292::I32 = _s24h::I32 + 1;
      _s24A::I32 = _c292::I32;
      I32[(old + 16)] = _c292::I32;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
  c28X:
      R1 = []_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c28Y:
      _s24B::P32 = R1;
      goto c28S;
  c28S:
      if (Sp - 12 < SpLim) goto c28Z; else goto c290;
  c28Z:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c290:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _s24h::I32 = I32[R1 + 8];
      _s24z::I32 = _s24h::I32;
      if (_s24h::I32 != 20) goto c28W; else goto c28X;
  c28W:
      _c292::I32 = _s24h::I32 + 1;
      _s24A::I32 = _c292::I32;
      I32[Sp - 12] = _c292::I32;
      Sp = Sp - 12;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
  c28X:
      R1 = []_closure+1;
      Sp = Sp - 8;
      call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c28Y:
      goto c28S;
  c28S:
      if ((Sp + -12) < SpLim) goto c28Z; else goto c290;
  c28Z:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c290:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _s24h::I32 = I32[R1 + 8];
      if (_s24h::I32 != 20) goto c28W; else goto c28X;
  c28W:
      I32[Sp - 12] = _s24h::I32 + 1;
      Sp = Sp - 12;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
  c28X:
      R1 = []_closure+1;
      Sp = Sp - 8;
      call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c28S, {Main.main_go_closure}), (c28W, {Main.main_go_closure}),
 (c28X, {}), (c28Y, {Main.main_go_closure}), (c28Z, {}),
 (c290, {Main.main_go_closure})]



==================== after setInfoTableStackMap ====================
sat_s24B_entry() //  [R1]
        { info_tbl: [(c28Y,
                      label: sat_s24B_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c28Y:
          goto c28S;
      c28S:
          if ((Sp + -12) < SpLim) goto c28Z; else goto c290;
      c28Z:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c290:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          _s24h::I32 = I32[R1 + 8];
          if (_s24h::I32 != 20) goto c28W; else goto c28X;
      c28W:
          I32[Sp - 12] = _s24h::I32 + 1;
          Sp = Sp - 12;
          call Main.main_go_info() args: 16, res: 0, upd: 12;
      c28X:
          R1 = []_closure+1;
          Sp = Sp - 8;
          call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_s24B_entry() //  [R1]
        { info_tbl: [(c28S,
                      label: sat_s24B_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c28S:
          if ((Sp + -12) < SpLim) goto c28Z; else goto c290;
      c28Z:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c290:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          _s24h::I32 = I32[R1 + 8];
          if (_s24h::I32 != 20) goto c28W; else goto c28X;
      c28W:
          I32[Sp - 12] = _s24h::I32 + 1;
          Sp = Sp - 12;
          call Main.main_go_info() args: 16, res: 0, upd: 12;
      c28X:
          R1 = []_closure+1;
          Sp = Sp - 8;
          call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  c293:
      _s24u::P32 = R1;
      goto c289;
  c289:
      if (Sp - <highSp> < SpLim) goto c294; else goto c29l;
  c294:
      R1 = _s24u::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29l:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24u::P32;
      _s24h::I32 = I32[_s24u::P32 + 8];
      _c28b::I32 = 3 + _s24h::I32;
      _s24q::I32 = _c28b::I32;
      _c28e::I32 = %MO_S_Ge_W32(_s24q::I32, _s24h::I32);
      if (_c28e::I32 >= 1) goto c29g; else goto c299;
  c29g:
      I32[(young<c29f> + 4)] = c29f;
      P32[(young<c29f> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c29f> + 28)] = n1_r23S_closure+1;
      I32[(young<c29f> + 24)] = _s24h::I32;
      I32[(young<c29f> + 20)] = _s24q::I32;
      I32[(young<c29f> + 16)] = 20;
      I32[(young<c29f> + 12)] = stg_ap_p_info;
      P32[(young<c29f> + 8)] = xs2_r23P_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29f, args: 32, res: 4, upd: 12;
  c29f:
      _s24t::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24t::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c299:
      I32[(young<c297> + 4)] = c297;
      P32[(young<c297> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c297> + 28)] = n1_r23S_closure+1;
      I32[(young<c297> + 24)] = _s24h::I32;
      I32[(young<c297> + 20)] = _s24q::I32;
      I32[(young<c297> + 16)] = 20;
      I32[(young<c297> + 12)] = stg_ap_p_info;
      P32[(young<c297> + 8)] = xs2_r23P_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c297, args: 32, res: 4, upd: 12;
  c297:
      _s24s::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24s::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c293:
      _s24u::P32 = R1;
      goto c289;
  c289:
      if (Sp - <highSp> < SpLim) goto c294; else goto c29l;
  c294:
      R1 = _s24u::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29l:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24u::P32;
      _s24h::I32 = I32[_s24u::P32 + 8];
      _c28b::I32 = 3 + _s24h::I32;
      _s24q::I32 = _c28b::I32;
      _c28e::I32 = %MO_S_Ge_W32(_s24q::I32, _s24h::I32);
      if (_c28e::I32 >= 1) goto c29g; else goto c299;
  c29g:
      I32[(young<c29f> + 4)] = c29f;
      P32[(young<c29f> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c29f> + 28)] = n1_r23S_closure+1;
      I32[(young<c29f> + 24)] = _s24h::I32;
      I32[(young<c29f> + 20)] = _s24q::I32;
      I32[(young<c29f> + 16)] = 20;
      I32[(young<c29f> + 12)] = stg_ap_p_info;
      P32[(young<c29f> + 8)] = xs2_r23P_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29f, args: 32, res: 4, upd: 12;
  c29f:
      _s24t::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24t::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c299:
      I32[(young<c297> + 4)] = c297;
      P32[(young<c297> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c297> + 28)] = n1_r23S_closure+1;
      I32[(young<c297> + 24)] = _s24h::I32;
      I32[(young<c297> + 20)] = _s24q::I32;
      I32[(young<c297> + 16)] = 20;
      I32[(young<c297> + 12)] = stg_ap_p_info;
      P32[(young<c297> + 8)] = xs2_r23P_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c297, args: 32, res: 4, upd: 12;
  c297:
      _s24s::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24s::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c293:
      _s24u::P32 = R1;
      goto c289;
  c289:
      if (Sp - <highSp> < SpLim) goto c294; else goto c29l;
  c294:
      R1 = _s24u::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29l:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24u::P32;
      _s24h::I32 = I32[_s24u::P32 + 8];
      _c28b::I32 = 3 + _s24h::I32;
      _s24q::I32 = _c28b::I32;
      _c28e::I32 = %MO_S_Ge_W32(_s24q::I32, _s24h::I32);
      if (_c28e::I32 >= 1) goto c29g; else goto c299;
  c29g:
      I32[(young<c29f> + 4)] = c29f;
      P32[(young<c29f> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c29f> + 28)] = n1_r23S_closure+1;
      I32[(young<c29f> + 24)] = _s24h::I32;
      I32[(young<c29f> + 20)] = _s24q::I32;
      I32[(young<c29f> + 16)] = 20;
      I32[(young<c29f> + 12)] = stg_ap_p_info;
      P32[(young<c29f> + 8)] = xs2_r23P_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29f, args: 32, res: 4, upd: 12;
  c29f:
      _s24t::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24t::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c299:
      I32[(young<c297> + 4)] = c297;
      P32[(young<c297> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c297> + 28)] = n1_r23S_closure+1;
      I32[(young<c297> + 24)] = _s24h::I32;
      I32[(young<c297> + 20)] = _s24q::I32;
      I32[(young<c297> + 16)] = 20;
      I32[(young<c297> + 12)] = stg_ap_p_info;
      P32[(young<c297> + 8)] = xs2_r23P_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c297, args: 32, res: 4, upd: 12;
  c297:
      _s24s::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24s::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c293:
      _s24u::P32 = R1;
      goto c289;
  c289:
      if (Sp - <highSp> < SpLim) goto c294; else goto c29l;
  c294:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29l:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s24h::I32 = I32[R1 + 8];
      _c28b::I32 = 3 + _s24h::I32;
      _s24q::I32 = _c28b::I32;
      _c28e::I32 = %MO_S_Ge_W32(_c28b::I32, _s24h::I32);
      if (_c28e::I32 >= 1) goto c29g; else goto c299;
  c29g:
      I32[(young<c29f> + 4)] = c29f;
      P32[(young<c29f> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c29f> + 28)] = n1_r23S_closure+1;
      I32[(young<c29f> + 24)] = _s24h::I32;
      I32[(young<c29f> + 20)] = _c28b::I32;
      I32[(young<c29f> + 16)] = 20;
      I32[(young<c29f> + 12)] = stg_ap_p_info;
      P32[(young<c29f> + 8)] = xs2_r23P_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29f, args: 32, res: 4, upd: 12;
  c29f:
      _s24t::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c299:
      I32[(young<c297> + 4)] = c297;
      P32[(young<c297> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c297> + 28)] = n1_r23S_closure+1;
      I32[(young<c297> + 24)] = _s24h::I32;
      I32[(young<c297> + 20)] = _c28b::I32;
      I32[(young<c297> + 16)] = 20;
      I32[(young<c297> + 12)] = stg_ap_p_info;
      P32[(young<c297> + 8)] = xs2_r23P_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c297, args: 32, res: 4, upd: 12;
  c297:
      _s24s::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c293:
      _s24u::P32 = R1;
      goto c289;
  c289:
      if (Sp - 40 < SpLim) goto c294; else goto c29l;
  c294:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29l:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _s24h::I32 = I32[R1 + 8];
      _c28b::I32 = 3 + _s24h::I32;
      _s24q::I32 = _c28b::I32;
      _c28e::I32 = %MO_S_Ge_W32(_c28b::I32, _s24h::I32);
      if (_c28e::I32 >= 1) goto c29g; else goto c299;
  c29g:
      I32[Sp - 12] = c29f;
      P32[Sp - 40] = lvl_r23Q_closure+3;
      P32[Sp - 36] = n1_r23S_closure+1;
      I32[Sp - 32] = _s24h::I32;
      I32[Sp - 28] = _c28b::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs2_r23P_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntUpFB_info() returns to c29f, args: 32, res: 4, upd: 12;
  c29f:
      _s24t::P32 = R1;
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c299:
      I32[Sp - 12] = c297;
      P32[Sp - 40] = lvl_r23Q_closure+3;
      P32[Sp - 36] = n1_r23S_closure+1;
      I32[Sp - 32] = _s24h::I32;
      I32[Sp - 28] = _c28b::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs2_r23P_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntDnFB_info() returns to c297, args: 32, res: 4, upd: 12;
  c297:
      _s24s::P32 = R1;
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c293:
      goto c289;
  c289:
      if ((Sp + -40) < SpLim) goto c294; else goto c29l;
  c294:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29l:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _s24h::I32 = I32[R1 + 8];
      _c28b::I32 = _s24h::I32 + 3;
      if (%MO_S_Ge_W32(_c28b::I32,
                       _s24h::I32)) goto c29g; else goto c299;
  c29g:
      I32[Sp - 12] = c29f;
      P32[Sp - 40] = lvl_r23Q_closure+3;
      P32[Sp - 36] = n1_r23S_closure+1;
      I32[Sp - 32] = _s24h::I32;
      I32[Sp - 28] = _c28b::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs2_r23P_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntUpFB_info() returns to c29f, args: 32, res: 4, upd: 12;
  c29f:
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c299:
      I32[Sp - 12] = c297;
      P32[Sp - 40] = lvl_r23Q_closure+3;
      P32[Sp - 36] = n1_r23S_closure+1;
      I32[Sp - 32] = _s24h::I32;
      I32[Sp - 28] = _c28b::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs2_r23P_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntDnFB_info() returns to c297, args: 32, res: 4, upd: 12;
  c297:
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c289, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c293, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c294, {}),
 (c297, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c299, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29f, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29g, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29l, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure})]



==================== after setInfoTableStackMap ====================
sat_s24u_entry() //  [R1]
        { info_tbl: [(c293,
                      label: sat_s24u_info
                      rep:HeapRep 1 nonptrs { Thunk }),
                     (c297,
                      label: block_c297_info
                      rep:StackRep []),
                     (c29f,
                      label: block_c29f_info
                      rep:StackRep [])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c293:
          goto c289;
      c289:
          if ((Sp + -40) < SpLim) goto c294; else goto c29l;
      c294:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c29l:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          _s24h::I32 = I32[R1 + 8];
          _c28b::I32 = _s24h::I32 + 3;
          if (%MO_S_Ge_W32(_c28b::I32,
                           _s24h::I32)) goto c29g; else goto c299;
      c29g:
          I32[Sp - 12] = c29f;
          P32[Sp - 40] = lvl_r23Q_closure+3;
          P32[Sp - 36] = n1_r23S_closure+1;
          I32[Sp - 32] = _s24h::I32;
          I32[Sp - 28] = _c28b::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs2_r23P_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntUpFB_info() returns to c29f, args: 32, res: 4, upd: 12;
      c29f:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
      c299:
          I32[Sp - 12] = c297;
          P32[Sp - 40] = lvl_r23Q_closure+3;
          P32[Sp - 36] = n1_r23S_closure+1;
          I32[Sp - 32] = _s24h::I32;
          I32[Sp - 28] = _c28b::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs2_r23P_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntDnFB_info() returns to c297, args: 32, res: 4, upd: 12;
      c297:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_s24u_entry() //  [R1]
        { info_tbl: [(c289,
                      label: sat_s24u_info
                      rep:HeapRep 1 nonptrs { Thunk }),
                     (c297,
                      label: block_c297_info
                      rep:StackRep []),
                     (c29f,
                      label: block_c29f_info
                      rep:StackRep [])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c289:
          if ((Sp + -40) < SpLim) goto c294; else goto c29l;
      c294:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c29l:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          _s24h::I32 = I32[R1 + 8];
          _c28b::I32 = _s24h::I32 + 3;
          if (%MO_S_Ge_W32(_c28b::I32,
                           _s24h::I32)) goto c29g; else goto c299;
      c29g:
          I32[Sp - 12] = c29f;
          P32[Sp - 40] = lvl_r23Q_closure+3;
          P32[Sp - 36] = n1_r23S_closure+1;
          I32[Sp - 32] = _s24h::I32;
          I32[Sp - 28] = _c28b::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs2_r23P_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntUpFB_info() returns to c29f, args: 32, res: 4, upd: 12;
      c29f:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
      c299:
          I32[Sp - 12] = c297;
          P32[Sp - 40] = lvl_r23Q_closure+3;
          P32[Sp - 36] = n1_r23S_closure+1;
          I32[Sp - 32] = _s24h::I32;
          I32[Sp - 28] = _c28b::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs2_r23P_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntDnFB_info() returns to c297, args: 32, res: 4, upd: 12;
      c297:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  c29p:
      _s24p::P32 = R1;
      goto c28x;
  c28x:
      if (Sp - <highSp> < SpLim) goto c29q; else goto c29H;
  c29q:
      R1 = _s24p::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29H:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24p::P32;
      _s24h::I32 = I32[_s24p::P32 + 8];
      _c28z::I32 = 2 + _s24h::I32;
      _s24l::I32 = _c28z::I32;
      _c28C::I32 = %MO_S_Ge_W32(_s24l::I32, _s24h::I32);
      if (_c28C::I32 >= 1) goto c29C; else goto c29v;
  c29C:
      I32[(young<c29B> + 4)] = c29B;
      P32[(young<c29B> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c29B> + 28)] = n_r23R_closure+1;
      I32[(young<c29B> + 24)] = _s24h::I32;
      I32[(young<c29B> + 20)] = _s24l::I32;
      I32[(young<c29B> + 16)] = 20;
      I32[(young<c29B> + 12)] = stg_ap_p_info;
      P32[(young<c29B> + 8)] = xs1_r23N_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29B, args: 32, res: 4, upd: 12;
  c29B:
      _s24o::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24o::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29v:
      I32[(young<c29t> + 4)] = c29t;
      P32[(young<c29t> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c29t> + 28)] = n_r23R_closure+1;
      I32[(young<c29t> + 24)] = _s24h::I32;
      I32[(young<c29t> + 20)] = _s24l::I32;
      I32[(young<c29t> + 16)] = 20;
      I32[(young<c29t> + 12)] = stg_ap_p_info;
      P32[(young<c29t> + 8)] = xs1_r23N_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c29t, args: 32, res: 4, upd: 12;
  c29t:
      _s24n::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24n::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c29p:
      _s24p::P32 = R1;
      goto c28x;
  c28x:
      if (Sp - <highSp> < SpLim) goto c29q; else goto c29H;
  c29q:
      R1 = _s24p::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29H:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24p::P32;
      _s24h::I32 = I32[_s24p::P32 + 8];
      _c28z::I32 = 2 + _s24h::I32;
      _s24l::I32 = _c28z::I32;
      _c28C::I32 = %MO_S_Ge_W32(_s24l::I32, _s24h::I32);
      if (_c28C::I32 >= 1) goto c29C; else goto c29v;
  c29C:
      I32[(young<c29B> + 4)] = c29B;
      P32[(young<c29B> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c29B> + 28)] = n_r23R_closure+1;
      I32[(young<c29B> + 24)] = _s24h::I32;
      I32[(young<c29B> + 20)] = _s24l::I32;
      I32[(young<c29B> + 16)] = 20;
      I32[(young<c29B> + 12)] = stg_ap_p_info;
      P32[(young<c29B> + 8)] = xs1_r23N_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29B, args: 32, res: 4, upd: 12;
  c29B:
      _s24o::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24o::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29v:
      I32[(young<c29t> + 4)] = c29t;
      P32[(young<c29t> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c29t> + 28)] = n_r23R_closure+1;
      I32[(young<c29t> + 24)] = _s24h::I32;
      I32[(young<c29t> + 20)] = _s24l::I32;
      I32[(young<c29t> + 16)] = 20;
      I32[(young<c29t> + 12)] = stg_ap_p_info;
      P32[(young<c29t> + 8)] = xs1_r23N_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c29t, args: 32, res: 4, upd: 12;
  c29t:
      _s24n::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24n::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c29p:
      _s24p::P32 = R1;
      goto c28x;
  c28x:
      if (Sp - <highSp> < SpLim) goto c29q; else goto c29H;
  c29q:
      R1 = _s24p::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29H:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24p::P32;
      _s24h::I32 = I32[_s24p::P32 + 8];
      _c28z::I32 = 2 + _s24h::I32;
      _s24l::I32 = _c28z::I32;
      _c28C::I32 = %MO_S_Ge_W32(_s24l::I32, _s24h::I32);
      if (_c28C::I32 >= 1) goto c29C; else goto c29v;
  c29C:
      I32[(young<c29B> + 4)] = c29B;
      P32[(young<c29B> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c29B> + 28)] = n_r23R_closure+1;
      I32[(young<c29B> + 24)] = _s24h::I32;
      I32[(young<c29B> + 20)] = _s24l::I32;
      I32[(young<c29B> + 16)] = 20;
      I32[(young<c29B> + 12)] = stg_ap_p_info;
      P32[(young<c29B> + 8)] = xs1_r23N_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29B, args: 32, res: 4, upd: 12;
  c29B:
      _s24o::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24o::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29v:
      I32[(young<c29t> + 4)] = c29t;
      P32[(young<c29t> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c29t> + 28)] = n_r23R_closure+1;
      I32[(young<c29t> + 24)] = _s24h::I32;
      I32[(young<c29t> + 20)] = _s24l::I32;
      I32[(young<c29t> + 16)] = 20;
      I32[(young<c29t> + 12)] = stg_ap_p_info;
      P32[(young<c29t> + 8)] = xs1_r23N_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c29t, args: 32, res: 4, upd: 12;
  c29t:
      _s24n::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24n::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c29p:
      _s24p::P32 = R1;
      goto c28x;
  c28x:
      if (Sp - <highSp> < SpLim) goto c29q; else goto c29H;
  c29q:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29H:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s24h::I32 = I32[R1 + 8];
      _c28z::I32 = 2 + _s24h::I32;
      _s24l::I32 = _c28z::I32;
      _c28C::I32 = %MO_S_Ge_W32(_c28z::I32, _s24h::I32);
      if (_c28C::I32 >= 1) goto c29C; else goto c29v;
  c29C:
      I32[(young<c29B> + 4)] = c29B;
      P32[(young<c29B> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c29B> + 28)] = n_r23R_closure+1;
      I32[(young<c29B> + 24)] = _s24h::I32;
      I32[(young<c29B> + 20)] = _c28z::I32;
      I32[(young<c29B> + 16)] = 20;
      I32[(young<c29B> + 12)] = stg_ap_p_info;
      P32[(young<c29B> + 8)] = xs1_r23N_closure+2;
      call GHC.Enum.efdtIntUpFB_info() returns to c29B, args: 32, res: 4, upd: 12;
  c29B:
      _s24o::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29v:
      I32[(young<c29t> + 4)] = c29t;
      P32[(young<c29t> + 32)] = lvl_r23Q_closure+3;
      P32[(young<c29t> + 28)] = n_r23R_closure+1;
      I32[(young<c29t> + 24)] = _s24h::I32;
      I32[(young<c29t> + 20)] = _c28z::I32;
      I32[(young<c29t> + 16)] = 20;
      I32[(young<c29t> + 12)] = stg_ap_p_info;
      P32[(young<c29t> + 8)] = xs1_r23N_closure+2;
      call GHC.Enum.efdtIntDnFB_info() returns to c29t, args: 32, res: 4, upd: 12;
  c29t:
      _s24n::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c29p:
      _s24p::P32 = R1;
      goto c28x;
  c28x:
      if (Sp - 40 < SpLim) goto c29q; else goto c29H;
  c29q:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29H:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _s24h::I32 = I32[R1 + 8];
      _c28z::I32 = 2 + _s24h::I32;
      _s24l::I32 = _c28z::I32;
      _c28C::I32 = %MO_S_Ge_W32(_c28z::I32, _s24h::I32);
      if (_c28C::I32 >= 1) goto c29C; else goto c29v;
  c29C:
      I32[Sp - 12] = c29B;
      P32[Sp - 40] = lvl_r23Q_closure+3;
      P32[Sp - 36] = n_r23R_closure+1;
      I32[Sp - 32] = _s24h::I32;
      I32[Sp - 28] = _c28z::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs1_r23N_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntUpFB_info() returns to c29B, args: 32, res: 4, upd: 12;
  c29B:
      _s24o::P32 = R1;
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29v:
      I32[Sp - 12] = c29t;
      P32[Sp - 40] = lvl_r23Q_closure+3;
      P32[Sp - 36] = n_r23R_closure+1;
      I32[Sp - 32] = _s24h::I32;
      I32[Sp - 28] = _c28z::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs1_r23N_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntDnFB_info() returns to c29t, args: 32, res: 4, upd: 12;
  c29t:
      _s24n::P32 = R1;
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c29p:
      goto c28x;
  c28x:
      if ((Sp + -40) < SpLim) goto c29q; else goto c29H;
  c29q:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c29H:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _s24h::I32 = I32[R1 + 8];
      _c28z::I32 = _s24h::I32 + 2;
      if (%MO_S_Ge_W32(_c28z::I32,
                       _s24h::I32)) goto c29C; else goto c29v;
  c29C:
      I32[Sp - 12] = c29B;
      P32[Sp - 40] = lvl_r23Q_closure+3;
      P32[Sp - 36] = n_r23R_closure+1;
      I32[Sp - 32] = _s24h::I32;
      I32[Sp - 28] = _c28z::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs1_r23N_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntUpFB_info() returns to c29B, args: 32, res: 4, upd: 12;
  c29B:
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
  c29v:
      I32[Sp - 12] = c29t;
      P32[Sp - 40] = lvl_r23Q_closure+3;
      P32[Sp - 36] = n_r23R_closure+1;
      I32[Sp - 32] = _s24h::I32;
      I32[Sp - 28] = _c28z::I32;
      I32[Sp - 24] = 20;
      I32[Sp - 20] = stg_ap_p_info;
      P32[Sp - 16] = xs1_r23N_closure+2;
      Sp = Sp - 40;
      call GHC.Enum.efdtIntDnFB_info() returns to c29t, args: 32, res: 4, upd: 12;
  c29t:
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c28x, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29p, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29q, {}),
 (c29t, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29v, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29B, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29C, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29H, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure})]



==================== after setInfoTableStackMap ====================
sat_s24p_entry() //  [R1]
        { info_tbl: [(c29p,
                      label: sat_s24p_info
                      rep:HeapRep 1 nonptrs { Thunk }),
                     (c29t,
                      label: block_c29t_info
                      rep:StackRep []),
                     (c29B,
                      label: block_c29B_info
                      rep:StackRep [])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c29p:
          goto c28x;
      c28x:
          if ((Sp + -40) < SpLim) goto c29q; else goto c29H;
      c29q:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c29H:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          _s24h::I32 = I32[R1 + 8];
          _c28z::I32 = _s24h::I32 + 2;
          if (%MO_S_Ge_W32(_c28z::I32,
                           _s24h::I32)) goto c29C; else goto c29v;
      c29C:
          I32[Sp - 12] = c29B;
          P32[Sp - 40] = lvl_r23Q_closure+3;
          P32[Sp - 36] = n_r23R_closure+1;
          I32[Sp - 32] = _s24h::I32;
          I32[Sp - 28] = _c28z::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs1_r23N_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntUpFB_info() returns to c29B, args: 32, res: 4, upd: 12;
      c29B:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
      c29v:
          I32[Sp - 12] = c29t;
          P32[Sp - 40] = lvl_r23Q_closure+3;
          P32[Sp - 36] = n_r23R_closure+1;
          I32[Sp - 32] = _s24h::I32;
          I32[Sp - 28] = _c28z::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs1_r23N_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntDnFB_info() returns to c29t, args: 32, res: 4, upd: 12;
      c29t:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_s24p_entry() //  [R1]
        { info_tbl: [(c28x,
                      label: sat_s24p_info
                      rep:HeapRep 1 nonptrs { Thunk }),
                     (c29t,
                      label: block_c29t_info
                      rep:StackRep []),
                     (c29B,
                      label: block_c29B_info
                      rep:StackRep [])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c28x:
          if ((Sp + -40) < SpLim) goto c29q; else goto c29H;
      c29q:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c29H:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          _s24h::I32 = I32[R1 + 8];
          _c28z::I32 = _s24h::I32 + 2;
          if (%MO_S_Ge_W32(_c28z::I32,
                           _s24h::I32)) goto c29C; else goto c29v;
      c29C:
          I32[Sp - 12] = c29B;
          P32[Sp - 40] = lvl_r23Q_closure+3;
          P32[Sp - 36] = n_r23R_closure+1;
          I32[Sp - 32] = _s24h::I32;
          I32[Sp - 28] = _c28z::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs1_r23N_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntUpFB_info() returns to c29B, args: 32, res: 4, upd: 12;
      c29B:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
      c29v:
          I32[Sp - 12] = c29t;
          P32[Sp - 40] = lvl_r23Q_closure+3;
          P32[Sp - 36] = n_r23R_closure+1;
          I32[Sp - 32] = _s24h::I32;
          I32[Sp - 28] = _c28z::I32;
          I32[Sp - 24] = 20;
          I32[Sp - 20] = stg_ap_p_info;
          P32[Sp - 16] = xs1_r23N_closure+2;
          Sp = Sp - 40;
          call GHC.Enum.efdtIntDnFB_info() returns to c29t, args: 32, res: 4, upd: 12;
      c29t:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  c29S:
      _s24k::P32 = R1;
      goto c28P;
  c28P:
      if (Sp - <highSp> < SpLim) goto c29T; else goto c2a0;
  c29T:
      R1 = _s24k::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a0:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24k::P32;
      _s24h::I32 = I32[_s24k::P32 + 8];
      _c28R::I32 = %MO_S_Gt_W32(_s24h::I32, 20);
      if (_c28R::I32 >= 1) goto c29O; else goto c29N;
  c29O:
      R1 = lvl1_r23T_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
  c29N:
      I32[(young<c29V> + 4)] = c29V;
      I32[(young<c29V> + 12)] = _s24h::I32;
      P32[(young<c29V> + 8)] = xs_r23L_closure+2;
      call go_r23U_info() returns to c29V, args: 12, res: 4, upd: 12;
  c29V:
      _s24j::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24j::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c29S:
      _s24k::P32 = R1;
      goto c28P;
  c28P:
      if (Sp - <highSp> < SpLim) goto c29T; else goto c2a0;
  c29T:
      R1 = _s24k::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a0:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24k::P32;
      _s24h::I32 = I32[_s24k::P32 + 8];
      _c28R::I32 = %MO_S_Gt_W32(_s24h::I32, 20);
      if (_c28R::I32 >= 1) goto c29O; else goto c29N;
  c29O:
      R1 = lvl1_r23T_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
  c29N:
      I32[(young<c29V> + 4)] = c29V;
      I32[(young<c29V> + 12)] = _s24h::I32;
      P32[(young<c29V> + 8)] = xs_r23L_closure+2;
      call go_r23U_info() returns to c29V, args: 12, res: 4, upd: 12;
  c29V:
      _s24j::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24j::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c29S:
      _s24k::P32 = R1;
      goto c28P;
  c28P:
      if (Sp - <highSp> < SpLim) goto c29T; else goto c2a0;
  c29T:
      R1 = _s24k::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a0:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24k::P32;
      _s24h::I32 = I32[_s24k::P32 + 8];
      _c28R::I32 = %MO_S_Gt_W32(_s24h::I32, 20);
      if (_c28R::I32 >= 1) goto c29O; else goto c29N;
  c29O:
      R1 = lvl1_r23T_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
  c29N:
      I32[(young<c29V> + 4)] = c29V;
      I32[(young<c29V> + 12)] = _s24h::I32;
      P32[(young<c29V> + 8)] = xs_r23L_closure+2;
      call go_r23U_info() returns to c29V, args: 12, res: 4, upd: 12;
  c29V:
      _s24j::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _s24j::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c29S:
      _s24k::P32 = R1;
      goto c28P;
  c28P:
      if (Sp - <highSp> < SpLim) goto c29T; else goto c2a0;
  c29T:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a0:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s24h::I32 = I32[R1 + 8];
      _c28R::I32 = %MO_S_Gt_W32(_s24h::I32, 20);
      if (_c28R::I32 >= 1) goto c29O; else goto c29N;
  c29O:
      R1 = lvl1_r23T_closure;
      call (I32[lvl1_r23T_closure])(R1) args: 12, res: 0, upd: 12;
  c29N:
      I32[(young<c29V> + 4)] = c29V;
      I32[(young<c29V> + 12)] = _s24h::I32;
      P32[(young<c29V> + 8)] = xs_r23L_closure+2;
      call go_r23U_info() returns to c29V, args: 12, res: 4, upd: 12;
  c29V:
      _s24j::P32 = R1;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = R1;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c29S:
      _s24k::P32 = R1;
      goto c28P;
  c28P:
      if (Sp - 24 < SpLim) goto c29T; else goto c2a0;
  c29T:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a0:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _s24h::I32 = I32[R1 + 8];
      _c28R::I32 = %MO_S_Gt_W32(_s24h::I32, 20);
      if (_c28R::I32 >= 1) goto c29O; else goto c29N;
  c29O:
      R1 = lvl1_r23T_closure;
      Sp = Sp - 8;
      call (I32[lvl1_r23T_closure])(R1) args: 12, res: 0, upd: 12;
  c29N:
      I32[Sp - 12] = c29V;
      I32[Sp - 20] = _s24h::I32;
      P32[Sp - 16] = xs_r23L_closure+2;
      Sp = Sp - 20;
      call go_r23U_info() returns to c29V, args: 12, res: 4, upd: 12;
  c29V:
      _s24j::P32 = R1;
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c29S:
      goto c28P;
  c28P:
      if ((Sp + -24) < SpLim) goto c29T; else goto c2a0;
  c29T:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a0:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _s24h::I32 = I32[R1 + 8];
      if (%MO_S_Gt_W32(_s24h::I32, 20)) goto c29O; else goto c29N;
  c29O:
      R1 = lvl1_r23T_closure;
      Sp = Sp - 8;
      call (I32[lvl1_r23T_closure])(R1) args: 12, res: 0, upd: 12;
  c29N:
      I32[Sp - 12] = c29V;
      I32[Sp - 20] = _s24h::I32;
      P32[Sp - 16] = xs_r23L_closure+2;
      Sp = Sp - 20;
      call go_r23U_info() returns to c29V, args: 12, res: 4, upd: 12;
  c29V:
      P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 4] = GHC.Num.$fNumInt_closure;
      P32[Sp] = R1;
      Sp = Sp - 12;
      call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c28P,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   lvl1_r23T_closure}),
 (c29N, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c29O, {lvl1_r23T_closure}),
 (c29S,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   lvl1_r23T_closure}),
 (c29T, {}),
 (c29V, {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure}),
 (c2a0,
  {T2902_B_PairingSum.$fSumPSumab_$cfromList_closure,
   lvl1_r23T_closure})]



==================== after setInfoTableStackMap ====================
sat_s24k_entry() //  [R1]
        { info_tbl: [(c29S,
                      label: sat_s24k_info
                      rep:HeapRep 1 nonptrs { Thunk }),
                     (c29V,
                      label: block_c29V_info
                      rep:StackRep [])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c29S:
          goto c28P;
      c28P:
          if ((Sp + -24) < SpLim) goto c29T; else goto c2a0;
      c29T:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2a0:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          _s24h::I32 = I32[R1 + 8];
          if (%MO_S_Gt_W32(_s24h::I32, 20)) goto c29O; else goto c29N;
      c29O:
          R1 = lvl1_r23T_closure;
          Sp = Sp - 8;
          call (I32[lvl1_r23T_closure])(R1) args: 12, res: 0, upd: 12;
      c29N:
          I32[Sp - 12] = c29V;
          I32[Sp - 20] = _s24h::I32;
          P32[Sp - 16] = xs_r23L_closure+2;
          Sp = Sp - 20;
          call go_r23U_info() returns to c29V, args: 12, res: 4, upd: 12;
      c29V:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_s24k_entry() //  [R1]
        { info_tbl: [(c28P,
                      label: sat_s24k_info
                      rep:HeapRep 1 nonptrs { Thunk }),
                     (c29V,
                      label: block_c29V_info
                      rep:StackRep [])]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c28P:
          if ((Sp + -24) < SpLim) goto c29T; else goto c2a0;
      c29T:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2a0:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          _s24h::I32 = I32[R1 + 8];
          if (%MO_S_Gt_W32(_s24h::I32, 20)) goto c29O; else goto c29N;
      c29O:
          R1 = lvl1_r23T_closure;
          Sp = Sp - 8;
          call (I32[lvl1_r23T_closure])(R1) args: 12, res: 0, upd: 12;
      c29N:
          I32[Sp - 12] = c29V;
          I32[Sp - 20] = _s24h::I32;
          P32[Sp - 16] = xs_r23L_closure+2;
          Sp = Sp - 20;
          call go_r23U_info() returns to c29V, args: 12, res: 4, upd: 12;
      c29V:
          P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 4] = GHC.Num.$fNumInt_closure;
          P32[Sp] = R1;
          Sp = Sp - 12;
          call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  c2a2:
      _s24y::P32 = R1;
      goto c285;
  c285:
      if (Sp - <highSp> < SpLim) goto c2a3; else goto c2a4;
  c2a4:
      Hp = Hp + 72;
      if (Hp > HpLim) goto c2a6; else goto c2a5;
  c2a6:
      HpAlloc = 72;
      goto c2a3;
  c2a3:
      R1 = _s24y::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a5:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24y::P32;
      _s24h::I32 = I32[_s24y::P32 + 8];
      I32[Hp - 68] = sat_s24u_info;
      I32[Hp - 60] = _s24h::I32;
      _c287::P32 = Hp - 68;
      I32[Hp - 56] = :_con_info;
      P32[Hp - 52] = _c287::P32;
      P32[Hp - 48] = GHC.Types.[]_closure+1;
      _c28u::P32 = Hp - 54;
      I32[Hp - 44] = sat_s24p_info;
      I32[Hp - 36] = _s24h::I32;
      _c28v::P32 = Hp - 44;
      I32[Hp - 32] = :_con_info;
      P32[Hp - 28] = _c28v::P32;
      P32[Hp - 24] = _c28u::P32;
      _c28M::P32 = Hp - 30;
      I32[Hp - 20] = sat_s24k_info;
      I32[Hp - 12] = _s24h::I32;
      _c28N::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c28N::P32;
      P32[Hp] = _c28M::P32;
      _c2a1::P32 = Hp - 6;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _c2a1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c2a2:
      _s24y::P32 = R1;
      goto c285;
  c285:
      if (Sp - <highSp> < SpLim) goto c2a3; else goto c2a4;
  c2a4:
      Hp = Hp + 72;
      if (Hp > HpLim) goto c2a6; else goto c2a5;
  c2a6:
      HpAlloc = 72;
      goto c2a3;
  c2a3:
      R1 = _s24y::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a5:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24y::P32;
      _s24h::I32 = I32[_s24y::P32 + 8];
      I32[Hp - 68] = sat_s24u_info;
      I32[Hp - 60] = _s24h::I32;
      _c287::P32 = Hp - 68;
      I32[Hp - 56] = :_con_info;
      P32[Hp - 52] = _c287::P32;
      P32[Hp - 48] = GHC.Types.[]_closure+1;
      _c28u::P32 = Hp - 54;
      I32[Hp - 44] = sat_s24p_info;
      I32[Hp - 36] = _s24h::I32;
      _c28v::P32 = Hp - 44;
      I32[Hp - 32] = :_con_info;
      P32[Hp - 28] = _c28v::P32;
      P32[Hp - 24] = _c28u::P32;
      _c28M::P32 = Hp - 30;
      I32[Hp - 20] = sat_s24k_info;
      I32[Hp - 12] = _s24h::I32;
      _c28N::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c28N::P32;
      P32[Hp] = _c28M::P32;
      _c2a1::P32 = Hp - 6;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _c2a1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c2a2:
      _s24y::P32 = R1;
      goto c285;
  c285:
      if (Sp - <highSp> < SpLim) goto c2a3; else goto c2a4;
  c2a4:
      Hp = Hp + 72;
      if (Hp > HpLim) goto c2a6; else goto c2a5;
  c2a6:
      HpAlloc = 72;
      goto c2a3;
  c2a3:
      R1 = _s24y::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a5:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s24y::P32;
      _s24h::I32 = I32[_s24y::P32 + 8];
      I32[Hp - 68] = sat_s24u_info;
      I32[Hp - 60] = _s24h::I32;
      _c287::P32 = Hp - 68;
      I32[Hp - 56] = :_con_info;
      P32[Hp - 52] = _c287::P32;
      P32[Hp - 48] = GHC.Types.[]_closure+1;
      _c28u::P32 = Hp - 54;
      I32[Hp - 44] = sat_s24p_info;
      I32[Hp - 36] = _s24h::I32;
      _c28v::P32 = Hp - 44;
      I32[Hp - 32] = :_con_info;
      P32[Hp - 28] = _c28v::P32;
      P32[Hp - 24] = _c28u::P32;
      _c28M::P32 = Hp - 30;
      I32[Hp - 20] = sat_s24k_info;
      I32[Hp - 12] = _s24h::I32;
      _c28N::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c28N::P32;
      P32[Hp] = _c28M::P32;
      _c2a1::P32 = Hp - 6;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _c2a1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2a2:
      _s24y::P32 = R1;
      goto c285;
  c285:
      if (Sp - <highSp> < SpLim) goto c2a3; else goto c2a4;
  c2a4:
      Hp = Hp + 72;
      if (Hp > HpLim) goto c2a6; else goto c2a5;
  c2a6:
      HpAlloc = 72;
      goto c2a3;
  c2a3:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a5:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s24h::I32 = I32[R1 + 8];
      I32[Hp - 68] = sat_s24u_info;
      I32[Hp - 60] = _s24h::I32;
      _c287::P32 = Hp - 68;
      I32[Hp - 56] = :_con_info;
      P32[Hp - 52] = _c287::P32;
      P32[Hp - 48] = GHC.Types.[]_closure+1;
      _c28u::P32 = Hp - 54;
      I32[Hp - 44] = sat_s24p_info;
      I32[Hp - 36] = _s24h::I32;
      _c28v::P32 = Hp - 44;
      I32[Hp - 32] = :_con_info;
      P32[Hp - 28] = _c28v::P32;
      P32[Hp - 24] = _c28u::P32;
      _c28M::P32 = Hp - 30;
      I32[Hp - 20] = sat_s24k_info;
      I32[Hp - 12] = _s24h::I32;
      _c28N::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c28N::P32;
      P32[Hp] = _c28M::P32;
      _c2a1::P32 = Hp - 6;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = _c2a1::P32;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c2a2:
      _s24y::P32 = R1;
      goto c285;
  c285:
      if (Sp - 24 < SpLim) goto c2a3; else goto c2a4;
  c2a4:
      Hp = Hp + 72;
      if (Hp > HpLim) goto c2a6; else goto c2a5;
  c2a6:
      HpAlloc = 72;
      goto c2a3;
  c2a3:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a5:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _s24h::I32 = I32[R1 + 8];
      I32[Hp - 68] = sat_s24u_info;
      I32[Hp - 60] = _s24h::I32;
      _c287::P32 = Hp - 68;
      I32[Hp - 56] = :_con_info;
      P32[Hp - 52] = _c287::P32;
      P32[Hp - 48] = GHC.Types.[]_closure+1;
      _c28u::P32 = Hp - 54;
      I32[Hp - 44] = sat_s24p_info;
      I32[Hp - 36] = _s24h::I32;
      _c28v::P32 = Hp - 44;
      I32[Hp - 32] = :_con_info;
      P32[Hp - 28] = _c28v::P32;
      P32[Hp - 24] = _c28u::P32;
      _c28M::P32 = Hp - 30;
      I32[Hp - 20] = sat_s24k_info;
      I32[Hp - 12] = _s24h::I32;
      _c28N::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c28N::P32;
      P32[Hp] = _c28M::P32;
      _c2a1::P32 = Hp - 6;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = _c2a1::P32;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c2a2:
      goto c285;
  c285:
      if ((Sp + -24) < SpLim) goto c2a3; else goto c2a4;
  c2a4:
      Hp = Hp + 72;
      if (Hp > HpLim) goto c2a6; else goto c2a5;
  c2a6:
      HpAlloc = 72;
      goto c2a3;
  c2a3:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2a5:
      I32[Sp - 8] = stg_upd_frame_info;
      P32[Sp - 4] = R1;
      _s24h::I32 = I32[R1 + 8];
      I32[Hp - 68] = sat_s24u_info;
      I32[Hp - 60] = _s24h::I32;
      I32[Hp - 56] = :_con_info;
      P32[Hp - 52] = Hp - 68;
      P32[Hp - 48] = GHC.Types.[]_closure+1;
      I32[Hp - 44] = sat_s24p_info;
      I32[Hp - 36] = _s24h::I32;
      I32[Hp - 32] = :_con_info;
      P32[Hp - 28] = Hp - 44;
      P32[Hp - 24] = Hp - 54;
      I32[Hp - 20] = sat_s24k_info;
      I32[Hp - 12] = _s24h::I32;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = Hp - 20;
      P32[Hp] = Hp - 30;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = Hp - 6;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c285,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure, sat_s24k_closure,
   sat_s24p_closure, sat_s24u_closure}),
 (c2a2,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure, sat_s24k_closure,
   sat_s24p_closure, sat_s24u_closure}),
 (c2a3, {}),
 (c2a4,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure, sat_s24k_closure,
   sat_s24p_closure, sat_s24u_closure}),
 (c2a5,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure, sat_s24k_closure,
   sat_s24p_closure, sat_s24u_closure}),
 (c2a6, {})]



==================== after setInfoTableStackMap ====================
sat_s24y_entry() //  [R1]
        { info_tbl: [(c2a2,
                      label: sat_s24y_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2a2:
          goto c285;
      c285:
          if ((Sp + -24) < SpLim) goto c2a3; else goto c2a4;
      c2a4:
          Hp = Hp + 72;
          if (Hp > HpLim) goto c2a6; else goto c2a5;
      c2a6:
          HpAlloc = 72;
          goto c2a3;
      c2a3:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2a5:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          _s24h::I32 = I32[R1 + 8];
          I32[Hp - 68] = sat_s24u_info;
          I32[Hp - 60] = _s24h::I32;
          I32[Hp - 56] = :_con_info;
          P32[Hp - 52] = Hp - 68;
          P32[Hp - 48] = GHC.Types.[]_closure+1;
          I32[Hp - 44] = sat_s24p_info;
          I32[Hp - 36] = _s24h::I32;
          I32[Hp - 32] = :_con_info;
          P32[Hp - 28] = Hp - 44;
          P32[Hp - 24] = Hp - 54;
          I32[Hp - 20] = sat_s24k_info;
          I32[Hp - 12] = _s24h::I32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 20;
          P32[Hp] = Hp - 30;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = Hp - 6;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
sat_s24y_entry() //  [R1]
        { info_tbl: [(c285,
                      label: sat_s24y_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c285:
          if ((Sp + -24) < SpLim) goto c2a3; else goto c2a4;
      c2a4:
          Hp = Hp + 72;
          if (Hp > HpLim) goto c2a6; else goto c2a5;
      c2a6:
          HpAlloc = 72;
          goto c2a3;
      c2a3:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2a5:
          I32[Sp - 8] = stg_upd_frame_info;
          P32[Sp - 4] = R1;
          _s24h::I32 = I32[R1 + 8];
          I32[Hp - 68] = sat_s24u_info;
          I32[Hp - 60] = _s24h::I32;
          I32[Hp - 56] = :_con_info;
          P32[Hp - 52] = Hp - 68;
          P32[Hp - 48] = GHC.Types.[]_closure+1;
          I32[Hp - 44] = sat_s24p_info;
          I32[Hp - 36] = _s24h::I32;
          I32[Hp - 32] = :_con_info;
          P32[Hp - 28] = Hp - 44;
          P32[Hp - 24] = Hp - 54;
          I32[Hp - 20] = sat_s24k_info;
          I32[Hp - 12] = _s24h::I32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 20;
          P32[Hp] = Hp - 30;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = Hp - 6;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
{offset
  c2a8:
      _s24h::I32 = I32[(old + 8)];
      goto c27Z;
  c27Z:
      if (Sp - <highSp> < SpLim) goto c2a9; else goto c2aa;
  c2aa:
      Hp = Hp + 36;
      if (Hp > HpLim) goto c2ac; else goto c2ab;
  c2ac:
      HpAlloc = 36;
      goto c2a9;
  c2a9:
      R1 = Main.main_go_closure;
      I32[(old + 8)] = _s24h::I32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2ab:
      I32[Hp - 32] = sat_s24B_info;
      I32[Hp - 24] = _s24h::I32;
      _c281::P32 = Hp - 32;
      I32[Hp - 20] = sat_s24y_info;
      I32[Hp - 12] = _s24h::I32;
      _c283::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c283::P32;
      P32[Hp] = _c281::P32;
      _c2a7::P32 = Hp - 6;
      R1 = _c2a7::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c2a8:
      _s24h::I32 = I32[(old + 8)];
      goto c27Z;
  c27Z:
      if (Sp - <highSp> < SpLim) goto c2a9; else goto c2aa;
  c2aa:
      Hp = Hp + 36;
      if (Hp > HpLim) goto c2ac; else goto c2ab;
  c2ac:
      HpAlloc = 36;
      goto c2a9;
  c2a9:
      R1 = Main.main_go_closure;
      I32[(old + 8)] = _s24h::I32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2ab:
      I32[Hp - 32] = sat_s24B_info;
      I32[Hp - 24] = _s24h::I32;
      _c281::P32 = Hp - 32;
      I32[Hp - 20] = sat_s24y_info;
      I32[Hp - 12] = _s24h::I32;
      _c283::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c283::P32;
      P32[Hp] = _c281::P32;
      _c2a7::P32 = Hp - 6;
      R1 = _c2a7::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c2a8:
      _s24h::I32 = I32[(old + 8)];
      goto c27Z;
  c27Z:
      if (Sp - <highSp> < SpLim) goto c2a9; else goto c2aa;
  c2aa:
      Hp = Hp + 36;
      if (Hp > HpLim) goto c2ac; else goto c2ab;
  c2ac:
      HpAlloc = 36;
      goto c2a9;
  c2a9:
      R1 = Main.main_go_closure;
      I32[(old + 8)] = _s24h::I32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2ab:
      I32[Hp - 32] = sat_s24B_info;
      I32[Hp - 24] = _s24h::I32;
      _c281::P32 = Hp - 32;
      I32[Hp - 20] = sat_s24y_info;
      I32[Hp - 12] = _s24h::I32;
      _c283::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c283::P32;
      P32[Hp] = _c281::P32;
      _c2a7::P32 = Hp - 6;
      R1 = _c2a7::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2a8:
      _s24h::I32 = I32[(old + 8)];
      goto c27Z;
  c27Z:
      if (Sp - <highSp> < SpLim) goto c2a9; else goto c2aa;
  c2aa:
      Hp = Hp + 36;
      if (Hp > HpLim) goto c2ac; else goto c2ab;
  c2ac:
      HpAlloc = 36;
      goto c2a9;
  c2a9:
      R1 = Main.main_go_closure;
      I32[(old + 8)] = _s24h::I32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2ab:
      I32[Hp - 32] = sat_s24B_info;
      I32[Hp - 24] = _s24h::I32;
      _c281::P32 = Hp - 32;
      I32[Hp - 20] = sat_s24y_info;
      I32[Hp - 12] = _s24h::I32;
      _c283::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c283::P32;
      P32[Hp] = _c281::P32;
      _c2a7::P32 = Hp - 6;
      R1 = _c2a7::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c2a8:
      _s24h::I32 = I32[Sp];
      goto c27Z;
  c27Z:
      goto c2aa;
  c2aa:
      Hp = Hp + 36;
      if (Hp > HpLim) goto c2ac; else goto c2ab;
  c2ac:
      HpAlloc = 36;
      goto c2a9;
  c2a9:
      R1 = Main.main_go_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2ab:
      I32[Hp - 32] = sat_s24B_info;
      I32[Hp - 24] = _s24h::I32;
      _c281::P32 = Hp - 32;
      I32[Hp - 20] = sat_s24y_info;
      I32[Hp - 12] = _s24h::I32;
      _c283::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c283::P32;
      P32[Hp] = _c281::P32;
      _c2a7::P32 = Hp - 6;
      R1 = _c2a7::P32;
      Sp = Sp + 4;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c2a8:
      goto c27Z;
  c27Z:
      goto c2aa;
  c2aa:
      Hp = Hp + 36;
      if (Hp > HpLim) goto c2ac; else goto c2ab;
  c2ac:
      HpAlloc = 36;
      goto c2a9;
  c2a9:
      R1 = Main.main_go_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2ab:
      I32[Hp - 32] = sat_s24B_info;
      _s24h::I32 = I32[Sp];
      I32[Hp - 24] = _s24h::I32;
      I32[Hp - 20] = sat_s24y_info;
      I32[Hp - 12] = _s24h::I32;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = Hp - 20;
      P32[Hp] = Hp - 32;
      R1 = Hp - 6;
      Sp = Sp + 4;
      call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c27Z,
  {Main.main_go_closure, sat_s24y_closure, sat_s24B_closure}),
 (c2a8, {Main.main_go_closure, sat_s24y_closure, sat_s24B_closure}),
 (c2a9, {Main.main_go_closure}),
 (c2aa, {Main.main_go_closure, sat_s24y_closure, sat_s24B_closure}),
 (c2ab, {sat_s24y_closure, sat_s24B_closure}),
 (c2ac, {Main.main_go_closure})]



==================== after setInfoTableStackMap ====================
Main.main_go_entry() //  []
        { info_tbl: [(c2a8,
                      label: Main.main_go_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      c2a8:
          goto c27Z;
      c27Z:
          goto c2aa;
      c2aa:
          Hp = Hp + 36;
          if (Hp > HpLim) goto c2ac; else goto c2ab;
      c2ac:
          HpAlloc = 36;
          goto c2a9;
      c2a9:
          R1 = Main.main_go_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      c2ab:
          I32[Hp - 32] = sat_s24B_info;
          _s24h::I32 = I32[Sp];
          I32[Hp - 24] = _s24h::I32;
          I32[Hp - 20] = sat_s24y_info;
          I32[Hp - 12] = _s24h::I32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 20;
          P32[Hp] = Hp - 32;
          R1 = Hp - 6;
          Sp = Sp + 4;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
Main.main_go_entry() //  []
        { info_tbl: [(c2aa,
                      label: Main.main_go_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 4
        }
    {offset
      c2aa:
          Hp = Hp + 36;
          if (Hp > HpLim) goto c2ac; else goto c2ab;
      c2ac:
          HpAlloc = 36;
          goto c2a9;
      c2a9:
          R1 = Main.main_go_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
      c2ab:
          I32[Hp - 32] = sat_s24B_info;
          _s24h::I32 = I32[Sp];
          I32[Hp - 24] = _s24h::I32;
          I32[Hp - 20] = sat_s24y_info;
          I32[Hp - 12] = _s24h::I32;
          I32[Hp - 8] = :_con_info;
          P32[Hp - 4] = Hp - 20;
          P32[Hp] = Hp - 32;
          R1 = Hp - 6;
          Sp = Sp + 4;
          call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main_go_closure:
         const Main.main_go_info;
         const 0;
 },
 sat_s24B_entry() //  [R1]
         { info_tbl: [(c28S,
                       label: sat_s24B_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28S:
           if ((Sp + -12) < SpLim) goto c28Z; else goto c290;
       c28Z:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c290:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           _s24h::I32 = I32[R1 + 8];
           if (_s24h::I32 != 20) goto c28W; else goto c28X;
       c28W:
           I32[Sp - 12] = _s24h::I32 + 1;
           Sp = Sp - 12;
           call Main.main_go_info() args: 16, res: 0, upd: 12;
       c28X:
           R1 = []_closure+1;
           Sp = Sp - 8;
           call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
     }
 },
 sat_s24u_entry() //  [R1]
         { info_tbl: [(c289,
                       label: sat_s24u_info
                       rep:HeapRep 1 nonptrs { Thunk }),
                      (c297,
                       label: block_c297_info
                       rep:StackRep []),
                      (c29f,
                       label: block_c29f_info
                       rep:StackRep [])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c289:
           if ((Sp + -40) < SpLim) goto c294; else goto c29l;
       c294:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c29l:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           _s24h::I32 = I32[R1 + 8];
           _c28b::I32 = _s24h::I32 + 3;
           if (%MO_S_Ge_W32(_c28b::I32,
                            _s24h::I32)) goto c29g; else goto c299;
       c29g:
           I32[Sp - 12] = c29f;
           P32[Sp - 40] = lvl_r23Q_closure+3;
           P32[Sp - 36] = n1_r23S_closure+1;
           I32[Sp - 32] = _s24h::I32;
           I32[Sp - 28] = _c28b::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs2_r23P_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntUpFB_info() returns to c29f, args: 32, res: 4, upd: 12;
       c29f:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
       c299:
           I32[Sp - 12] = c297;
           P32[Sp - 40] = lvl_r23Q_closure+3;
           P32[Sp - 36] = n1_r23S_closure+1;
           I32[Sp - 32] = _s24h::I32;
           I32[Sp - 28] = _c28b::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs2_r23P_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntDnFB_info() returns to c297, args: 32, res: 4, upd: 12;
       c297:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24p_entry() //  [R1]
         { info_tbl: [(c28x,
                       label: sat_s24p_info
                       rep:HeapRep 1 nonptrs { Thunk }),
                      (c29t,
                       label: block_c29t_info
                       rep:StackRep []),
                      (c29B,
                       label: block_c29B_info
                       rep:StackRep [])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28x:
           if ((Sp + -40) < SpLim) goto c29q; else goto c29H;
       c29q:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c29H:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           _s24h::I32 = I32[R1 + 8];
           _c28z::I32 = _s24h::I32 + 2;
           if (%MO_S_Ge_W32(_c28z::I32,
                            _s24h::I32)) goto c29C; else goto c29v;
       c29C:
           I32[Sp - 12] = c29B;
           P32[Sp - 40] = lvl_r23Q_closure+3;
           P32[Sp - 36] = n_r23R_closure+1;
           I32[Sp - 32] = _s24h::I32;
           I32[Sp - 28] = _c28z::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs1_r23N_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntUpFB_info() returns to c29B, args: 32, res: 4, upd: 12;
       c29B:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
       c29v:
           I32[Sp - 12] = c29t;
           P32[Sp - 40] = lvl_r23Q_closure+3;
           P32[Sp - 36] = n_r23R_closure+1;
           I32[Sp - 32] = _s24h::I32;
           I32[Sp - 28] = _c28z::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs1_r23N_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntDnFB_info() returns to c29t, args: 32, res: 4, upd: 12;
       c29t:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24k_entry() //  [R1]
         { info_tbl: [(c28P,
                       label: sat_s24k_info
                       rep:HeapRep 1 nonptrs { Thunk }),
                      (c29V,
                       label: block_c29V_info
                       rep:StackRep [])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28P:
           if ((Sp + -24) < SpLim) goto c29T; else goto c2a0;
       c29T:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2a0:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           _s24h::I32 = I32[R1 + 8];
           if (%MO_S_Gt_W32(_s24h::I32, 20)) goto c29O; else goto c29N;
       c29O:
           R1 = lvl1_r23T_closure;
           Sp = Sp - 8;
           call (I32[lvl1_r23T_closure])(R1) args: 12, res: 0, upd: 12;
       c29N:
           I32[Sp - 12] = c29V;
           I32[Sp - 20] = _s24h::I32;
           P32[Sp - 16] = xs_r23L_closure+2;
           Sp = Sp - 20;
           call go_r23U_info() returns to c29V, args: 12, res: 4, upd: 12;
       c29V:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24y_entry() //  [R1]
         { info_tbl: [(c285,
                       label: sat_s24y_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c285:
           if ((Sp + -24) < SpLim) goto c2a3; else goto c2a4;
       c2a4:
           Hp = Hp + 72;
           if (Hp > HpLim) goto c2a6; else goto c2a5;
       c2a6:
           HpAlloc = 72;
           goto c2a3;
       c2a3:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2a5:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           _s24h::I32 = I32[R1 + 8];
           I32[Hp - 68] = sat_s24u_info;
           I32[Hp - 60] = _s24h::I32;
           I32[Hp - 56] = :_con_info;
           P32[Hp - 52] = Hp - 68;
           P32[Hp - 48] = GHC.Types.[]_closure+1;
           I32[Hp - 44] = sat_s24p_info;
           I32[Hp - 36] = _s24h::I32;
           I32[Hp - 32] = :_con_info;
           P32[Hp - 28] = Hp - 44;
           P32[Hp - 24] = Hp - 54;
           I32[Hp - 20] = sat_s24k_info;
           I32[Hp - 12] = _s24h::I32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 20;
           P32[Hp] = Hp - 30;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = Hp - 6;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 },
 Main.main_go_entry() //  []
         { info_tbl: [(c2aa,
                       label: Main.main_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c2aa:
           Hp = Hp + 36;
           if (Hp > HpLim) goto c2ac; else goto c2ab;
       c2ac:
           HpAlloc = 36;
           goto c2a9;
       c2a9:
           R1 = Main.main_go_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       c2ab:
           I32[Hp - 32] = sat_s24B_info;
           _s24h::I32 = I32[Sp];
           I32[Hp - 24] = _s24h::I32;
           I32[Hp - 20] = sat_s24y_info;
           I32[Hp - 12] = _s24h::I32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 20;
           P32[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 4;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main_go_closure:
         const Main.main_go_info;
         const 0;
 },
 sat_s24B_entry() //  [R1]
         { info_tbl: [(c28S,
                       label: sat_s24B_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28S:
           if ((Sp + -12) < SpLim) goto c28Z; else goto c290;
       c28Z:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c290:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           _s24h::I32 = I32[R1 + 8];
           if (_s24h::I32 != 20) goto c28W; else goto c28X;
       c28W:
           I32[Sp - 12] = _s24h::I32 + 1;
           Sp = Sp - 12;
           call Main.main_go_info() args: 16, res: 0, upd: 12;
       c28X:
           R1 = []_closure+1;
           Sp = Sp - 8;
           call (P32[Sp])(R1) args: 12, res: 0, upd: 12;
     }
 },
 sat_s24u_entry() //  [R1]
         { info_tbl: [(c289,
                       label: sat_s24u_info
                       rep:HeapRep 1 nonptrs { Thunk }),
                      (c297,
                       label: block_c297_info
                       rep:StackRep []),
                      (c29f,
                       label: block_c29f_info
                       rep:StackRep [])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c289:
           if ((Sp + -40) < SpLim) goto c294; else goto c29l;
       c294:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c29l:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           _s24h::I32 = I32[R1 + 8];
           _c28b::I32 = _s24h::I32 + 3;
           if (%MO_S_Ge_W32(_c28b::I32,
                            _s24h::I32)) goto c29g; else goto c299;
       c29g:
           I32[Sp - 12] = c29f;
           P32[Sp - 40] = lvl_r23Q_closure+3;
           P32[Sp - 36] = n1_r23S_closure+1;
           I32[Sp - 32] = _s24h::I32;
           I32[Sp - 28] = _c28b::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs2_r23P_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntUpFB_info() returns to c29f, args: 32, res: 4, upd: 12;
       c29f:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
       c299:
           I32[Sp - 12] = c297;
           P32[Sp - 40] = lvl_r23Q_closure+3;
           P32[Sp - 36] = n1_r23S_closure+1;
           I32[Sp - 32] = _s24h::I32;
           I32[Sp - 28] = _c28b::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs2_r23P_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntDnFB_info() returns to c297, args: 32, res: 4, upd: 12;
       c297:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24p_entry() //  [R1]
         { info_tbl: [(c28x,
                       label: sat_s24p_info
                       rep:HeapRep 1 nonptrs { Thunk }),
                      (c29t,
                       label: block_c29t_info
                       rep:StackRep []),
                      (c29B,
                       label: block_c29B_info
                       rep:StackRep [])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28x:
           if ((Sp + -40) < SpLim) goto c29q; else goto c29H;
       c29q:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c29H:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           _s24h::I32 = I32[R1 + 8];
           _c28z::I32 = _s24h::I32 + 2;
           if (%MO_S_Ge_W32(_c28z::I32,
                            _s24h::I32)) goto c29C; else goto c29v;
       c29C:
           I32[Sp - 12] = c29B;
           P32[Sp - 40] = lvl_r23Q_closure+3;
           P32[Sp - 36] = n_r23R_closure+1;
           I32[Sp - 32] = _s24h::I32;
           I32[Sp - 28] = _c28z::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs1_r23N_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntUpFB_info() returns to c29B, args: 32, res: 4, upd: 12;
       c29B:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
       c29v:
           I32[Sp - 12] = c29t;
           P32[Sp - 40] = lvl_r23Q_closure+3;
           P32[Sp - 36] = n_r23R_closure+1;
           I32[Sp - 32] = _s24h::I32;
           I32[Sp - 28] = _c28z::I32;
           I32[Sp - 24] = 20;
           I32[Sp - 20] = stg_ap_p_info;
           P32[Sp - 16] = xs1_r23N_closure+2;
           Sp = Sp - 40;
           call GHC.Enum.efdtIntDnFB_info() returns to c29t, args: 32, res: 4, upd: 12;
       c29t:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24k_entry() //  [R1]
         { info_tbl: [(c28P,
                       label: sat_s24k_info
                       rep:HeapRep 1 nonptrs { Thunk }),
                      (c29V,
                       label: block_c29V_info
                       rep:StackRep [])]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c28P:
           if ((Sp + -24) < SpLim) goto c29T; else goto c2a0;
       c29T:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2a0:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           _s24h::I32 = I32[R1 + 8];
           if (%MO_S_Gt_W32(_s24h::I32, 20)) goto c29O; else goto c29N;
       c29O:
           R1 = lvl1_r23T_closure;
           Sp = Sp - 8;
           call (I32[lvl1_r23T_closure])(R1) args: 12, res: 0, upd: 12;
       c29N:
           I32[Sp - 12] = c29V;
           I32[Sp - 20] = _s24h::I32;
           P32[Sp - 16] = xs_r23L_closure+2;
           Sp = Sp - 20;
           call go_r23U_info() returns to c29V, args: 12, res: 4, upd: 12;
       c29V:
           P32[Sp - 12] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 8] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 4] = GHC.Num.$fNumInt_closure;
           P32[Sp] = R1;
           Sp = Sp - 12;
           call T2902_B_PairingSum.$fSumPSumab_$cfromList_info() args: 28, res: 0, upd: 12;
     }
 },
 sat_s24y_entry() //  [R1]
         { info_tbl: [(c285,
                       label: sat_s24y_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c285:
           if ((Sp + -24) < SpLim) goto c2a3; else goto c2a4;
       c2a4:
           Hp = Hp + 72;
           if (Hp > HpLim) goto c2a6; else goto c2a5;
       c2a6:
           HpAlloc = 72;
           goto c2a3;
       c2a3:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2a5:
           I32[Sp - 8] = stg_upd_frame_info;
           P32[Sp - 4] = R1;
           _s24h::I32 = I32[R1 + 8];
           I32[Hp - 68] = sat_s24u_info;
           I32[Hp - 60] = _s24h::I32;
           I32[Hp - 56] = :_con_info;
           P32[Hp - 52] = Hp - 68;
           P32[Hp - 48] = GHC.Types.[]_closure+1;
           I32[Hp - 44] = sat_s24p_info;
           I32[Hp - 36] = _s24h::I32;
           I32[Hp - 32] = :_con_info;
           P32[Hp - 28] = Hp - 44;
           P32[Hp - 24] = Hp - 54;
           I32[Hp - 20] = sat_s24k_info;
           I32[Hp - 12] = _s24h::I32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 20;
           P32[Hp] = Hp - 30;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = Hp - 6;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 },
 Main.main_go_entry() //  []
         { info_tbl: [(c2aa,
                       label: Main.main_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 4
         }
     {offset
       c2aa:
           Hp = Hp + 36;
           if (Hp > HpLim) goto c2ac; else goto c2ab;
       c2ac:
           HpAlloc = 36;
           goto c2a9;
       c2a9:
           R1 = Main.main_go_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
       c2ab:
           I32[Hp - 32] = sat_s24B_info;
           _s24h::I32 = I32[Sp];
           I32[Hp - 24] = _s24h::I32;
           I32[Hp - 20] = sat_s24y_info;
           I32[Hp - 12] = _s24h::I32;
           I32[Hp - 8] = :_con_info;
           P32[Hp - 4] = Hp - 20;
           P32[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 4;
           call (P32[Sp])(R1) args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main6_closure:
         const Main.main6_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main6_entry() //  [R1]
         { info_tbl: [(c2aM,
                       label: Main.main6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2aM:
           _rT0::P32 = R1;
           goto c2aH;
       c2aH:
           if (Sp - <highSp> < SpLim) goto c2aN; else goto c2aO;
       c2aO:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2aQ; else goto c2aP;
       c2aQ:
           HpAlloc = 8;
           goto c2aN;
       c2aN:
           R1 = _rT0::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2aP:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2aJ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT0::P32, Hp - 4);
           if (_c2aJ::I32 == 0) goto c2aL; else goto c2aK;
       c2aL:
           call (I32[_rT0::P32])() args: 4, res: 0, upd: 4;
       c2aK:
           I32[(old + 12)] = stg_bh_upd_frame_info;
           P32[(old + 8)] = Hp - 4;
           I32[(old + 16)] = 1;
           call Main.main_go_info() args: 16, res: 0, upd: 12;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2aM:
      _rT0::P32 = R1;
      goto c2aH;
  c2aH:
      if (Sp - <highSp> < SpLim) goto c2aN; else goto c2aO;
  c2aO:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2aQ; else goto c2aP;
  c2aQ:
      HpAlloc = 8;
      goto c2aN;
  c2aN:
      R1 = _rT0::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aP:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2aJ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT0::P32, Hp - 4);
      if (_c2aJ::I32 == 0) goto c2aL; else goto c2aK;
  c2aL:
      call (I32[_rT0::P32])() args: 4, res: 0, upd: 4;
  c2aK:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = 1;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c2aM:
      _rT0::P32 = R1;
      goto c2aH;
  c2aH:
      if (Sp - <highSp> < SpLim) goto c2aN; else goto c2aO;
  c2aO:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2aQ; else goto c2aP;
  c2aQ:
      HpAlloc = 8;
      goto c2aN;
  c2aN:
      R1 = _rT0::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aP:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2aJ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT0::P32, Hp - 4);
      if (_c2aJ::I32 == 0) goto c2aL; else goto c2aK;
  c2aL:
      call (I32[_rT0::P32])() args: 4, res: 0, upd: 4;
  c2aK:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = 1;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c2aM:
      _rT0::P32 = R1;
      goto c2aH;
  c2aH:
      if (Sp - <highSp> < SpLim) goto c2aN; else goto c2aO;
  c2aO:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2aQ; else goto c2aP;
  c2aQ:
      HpAlloc = 8;
      goto c2aN;
  c2aN:
      R1 = _rT0::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aP:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2aJ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT0::P32, Hp - 4);
      if (_c2aJ::I32 == 0) goto c2aL; else goto c2aK;
  c2aL:
      call (I32[_rT0::P32])() args: 4, res: 0, upd: 4;
  c2aK:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = 1;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2aM:
      _rT0::P32 = R1;
      goto c2aH;
  c2aH:
      if (Sp - <highSp> < SpLim) goto c2aN; else goto c2aO;
  c2aO:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2aQ; else goto c2aP;
  c2aQ:
      HpAlloc = 8;
      goto c2aN;
  c2aN:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aP:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2aJ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2aJ::I32 == 0) goto c2aL; else goto c2aK;
  c2aL:
      call (I32[_rT0::P32])() args: 4, res: 0, upd: 4;
  c2aK:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = 1;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c2aM:
      _rT0::P32 = R1;
      goto c2aH;
  c2aH:
      if (Sp - 12 < SpLim) goto c2aN; else goto c2aO;
  c2aO:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2aQ; else goto c2aP;
  c2aQ:
      HpAlloc = 8;
      goto c2aN;
  c2aN:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aP:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2aJ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2aJ::I32 == 0) goto c2aL; else goto c2aK;
  c2aL:
      call (I32[_rT0::P32])() args: 4, res: 0, upd: 4;
  c2aK:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      I32[Sp - 12] = 1;
      Sp = Sp - 12;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c2aM:
      goto c2aH;
  c2aH:
      if ((Sp + -12) < SpLim) goto c2aN; else goto c2aO;
  c2aO:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2aQ; else goto c2aP;
  c2aQ:
      HpAlloc = 8;
      goto c2aN;
  c2aN:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2aP:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2aJ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2aJ::I32 == 0) goto c2aL; else goto c2aK;
  c2aL:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2aK:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      I32[Sp - 12] = 1;
      Sp = Sp - 12;
      call Main.main_go_info() args: 16, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c2aH, {Main.main_go_closure}), (c2aK, {Main.main_go_closure}),
 (c2aL, {}), (c2aM, {Main.main_go_closure}), (c2aN, {}),
 (c2aO, {Main.main_go_closure}), (c2aP, {Main.main_go_closure}),
 (c2aQ, {})]



==================== after setInfoTableStackMap ====================
Main.main6_entry() //  [R1]
        { info_tbl: [(c2aM,
                      label: Main.main6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2aM:
          goto c2aH;
      c2aH:
          if ((Sp + -12) < SpLim) goto c2aN; else goto c2aO;
      c2aO:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2aQ; else goto c2aP;
      c2aQ:
          HpAlloc = 8;
          goto c2aN;
      c2aN:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2aP:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2aJ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
          if (_c2aJ::I32 == 0) goto c2aL; else goto c2aK;
      c2aL:
          call (I32[R1])() args: 4, res: 0, upd: 4;
      c2aK:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          I32[Sp - 12] = 1;
          Sp = Sp - 12;
          call Main.main_go_info() args: 16, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
Main.main6_entry() //  [R1]
        { info_tbl: [(c2aH,
                      label: Main.main6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2aH:
          if ((Sp + -12) < SpLim) goto c2aN; else goto c2aO;
      c2aO:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2aQ; else goto c2aP;
      c2aQ:
          HpAlloc = 8;
          goto c2aN;
      c2aN:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2aP:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2aJ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
          if (_c2aJ::I32 == 0) goto c2aL; else goto c2aK;
      c2aL:
          call (I32[R1])() args: 4, res: 0, upd: 4;
      c2aK:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          I32[Sp - 12] = 1;
          Sp = Sp - 12;
          call Main.main_go_info() args: 16, res: 0, upd: 12;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main6_closure:
         const Main.main6_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main6_entry() //  [R1]
         { info_tbl: [(c2aH,
                       label: Main.main6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2aH:
           if ((Sp + -12) < SpLim) goto c2aN; else goto c2aO;
       c2aO:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2aQ; else goto c2aP;
       c2aQ:
           HpAlloc = 8;
           goto c2aN;
       c2aN:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2aP:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2aJ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
           if (_c2aJ::I32 == 0) goto c2aL; else goto c2aK;
       c2aL:
           call (I32[R1])() args: 4, res: 0, upd: 4;
       c2aK:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           I32[Sp - 12] = 1;
           Sp = Sp - 12;
           call Main.main_go_info() args: 16, res: 0, upd: 12;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main6_closure:
         const Main.main6_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main6_entry() //  [R1]
         { info_tbl: [(c2aH,
                       label: Main.main6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2aH:
           if ((Sp + -12) < SpLim) goto c2aN; else goto c2aO;
       c2aO:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2aQ; else goto c2aP;
       c2aQ:
           HpAlloc = 8;
           goto c2aN;
       c2aN:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2aP:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2aJ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
           if (_c2aJ::I32 == 0) goto c2aL; else goto c2aK;
       c2aL:
           call (I32[R1])() args: 4, res: 0, upd: 4;
       c2aK:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           I32[Sp - 12] = 1;
           Sp = Sp - 12;
           call Main.main_go_info() args: 16, res: 0, upd: 12;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main5_closure:
         const Main.main5_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main5_entry() //  [R1]
         { info_tbl: [(c2b6,
                       label: Main.main5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2b6:
           _rT1::P32 = R1;
           goto c2b1;
       c2b1:
           if (Sp - <highSp> < SpLim) goto c2b7; else goto c2b8;
       c2b8:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2ba; else goto c2b9;
       c2ba:
           HpAlloc = 8;
           goto c2b7;
       c2b7:
           R1 = _rT1::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2b9:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2b3::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT1::P32, Hp - 4);
           if (_c2b3::I32 == 0) goto c2b5; else goto c2b4;
       c2b5:
           call (I32[_rT1::P32])() args: 4, res: 0, upd: 4;
       c2b4:
           I32[(old + 12)] = stg_bh_upd_frame_info;
           P32[(old + 8)] = Hp - 4;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = Main.main6_closure;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2b6:
      _rT1::P32 = R1;
      goto c2b1;
  c2b1:
      if (Sp - <highSp> < SpLim) goto c2b7; else goto c2b8;
  c2b8:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2ba; else goto c2b9;
  c2ba:
      HpAlloc = 8;
      goto c2b7;
  c2b7:
      R1 = _rT1::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2b9:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2b3::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT1::P32, Hp - 4);
      if (_c2b3::I32 == 0) goto c2b5; else goto c2b4;
  c2b5:
      call (I32[_rT1::P32])() args: 4, res: 0, upd: 4;
  c2b4:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main6_closure;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c2b6:
      _rT1::P32 = R1;
      goto c2b1;
  c2b1:
      if (Sp - <highSp> < SpLim) goto c2b7; else goto c2b8;
  c2b8:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2ba; else goto c2b9;
  c2ba:
      HpAlloc = 8;
      goto c2b7;
  c2b7:
      R1 = _rT1::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2b9:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2b3::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT1::P32, Hp - 4);
      if (_c2b3::I32 == 0) goto c2b5; else goto c2b4;
  c2b5:
      call (I32[_rT1::P32])() args: 4, res: 0, upd: 4;
  c2b4:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main6_closure;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c2b6:
      _rT1::P32 = R1;
      goto c2b1;
  c2b1:
      if (Sp - <highSp> < SpLim) goto c2b7; else goto c2b8;
  c2b8:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2ba; else goto c2b9;
  c2ba:
      HpAlloc = 8;
      goto c2b7;
  c2b7:
      R1 = _rT1::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2b9:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2b3::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT1::P32, Hp - 4);
      if (_c2b3::I32 == 0) goto c2b5; else goto c2b4;
  c2b5:
      call (I32[_rT1::P32])() args: 4, res: 0, upd: 4;
  c2b4:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main6_closure;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2b6:
      _rT1::P32 = R1;
      goto c2b1;
  c2b1:
      if (Sp - <highSp> < SpLim) goto c2b7; else goto c2b8;
  c2b8:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2ba; else goto c2b9;
  c2ba:
      HpAlloc = 8;
      goto c2b7;
  c2b7:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2b9:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2b3::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2b3::I32 == 0) goto c2b5; else goto c2b4;
  c2b5:
      call (I32[_rT1::P32])() args: 4, res: 0, upd: 4;
  c2b4:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main6_closure;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c2b6:
      _rT1::P32 = R1;
      goto c2b1;
  c2b1:
      if (Sp - 24 < SpLim) goto c2b7; else goto c2b8;
  c2b8:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2ba; else goto c2b9;
  c2ba:
      HpAlloc = 8;
      goto c2b7;
  c2b7:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2b9:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2b3::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2b3::I32 == 0) goto c2b5; else goto c2b4;
  c2b5:
      call (I32[_rT1::P32])() args: 4, res: 0, upd: 4;
  c2b4:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = Main.main6_closure;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c2b6:
      goto c2b1;
  c2b1:
      if ((Sp + -24) < SpLim) goto c2b7; else goto c2b8;
  c2b8:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2ba; else goto c2b9;
  c2ba:
      HpAlloc = 8;
      goto c2b7;
  c2b7:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2b9:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2b3::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2b3::I32 == 0) goto c2b5; else goto c2b4;
  c2b5:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2b4:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = Main.main6_closure;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c2b1,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   Main.main6_closure}),
 (c2b4,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   Main.main6_closure}),
 (c2b5, {}),
 (c2b6,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   Main.main6_closure}),
 (c2b7, {}),
 (c2b8,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   Main.main6_closure}),
 (c2b9,
  {T2902_B_PairingSum.$fSumPSumab_$cunions_closure,
   Main.main6_closure}),
 (c2ba, {})]



==================== after setInfoTableStackMap ====================
Main.main5_entry() //  [R1]
        { info_tbl: [(c2b6,
                      label: Main.main5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2b6:
          goto c2b1;
      c2b1:
          if ((Sp + -24) < SpLim) goto c2b7; else goto c2b8;
      c2b8:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2ba; else goto c2b9;
      c2ba:
          HpAlloc = 8;
          goto c2b7;
      c2b7:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2b9:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2b3::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
          if (_c2b3::I32 == 0) goto c2b5; else goto c2b4;
      c2b5:
          call (I32[R1])() args: 4, res: 0, upd: 4;
      c2b4:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = Main.main6_closure;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
Main.main5_entry() //  [R1]
        { info_tbl: [(c2b1,
                      label: Main.main5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2b1:
          if ((Sp + -24) < SpLim) goto c2b7; else goto c2b8;
      c2b8:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2ba; else goto c2b9;
      c2ba:
          HpAlloc = 8;
          goto c2b7;
      c2b7:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2b9:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2b3::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
          if (_c2b3::I32 == 0) goto c2b5; else goto c2b4;
      c2b5:
          call (I32[R1])() args: 4, res: 0, upd: 4;
      c2b4:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = Main.main6_closure;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main5_closure:
         const Main.main5_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main5_entry() //  [R1]
         { info_tbl: [(c2b1,
                       label: Main.main5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2b1:
           if ((Sp + -24) < SpLim) goto c2b7; else goto c2b8;
       c2b8:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2ba; else goto c2b9;
       c2ba:
           HpAlloc = 8;
           goto c2b7;
       c2b7:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2b9:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2b3::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
           if (_c2b3::I32 == 0) goto c2b5; else goto c2b4;
       c2b5:
           call (I32[R1])() args: 4, res: 0, upd: 4;
       c2b4:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = Main.main6_closure;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main5_closure:
         const Main.main5_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main5_entry() //  [R1]
         { info_tbl: [(c2b1,
                       label: Main.main5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2b1:
           if ((Sp + -24) < SpLim) goto c2b7; else goto c2b8;
       c2b8:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2ba; else goto c2b9;
       c2ba:
           HpAlloc = 8;
           goto c2b7;
       c2b7:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2b9:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2b3::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
           if (_c2b3::I32 == 0) goto c2b5; else goto c2b4;
       c2b5:
           call (I32[R1])() args: 4, res: 0, upd: 4;
       c2b4:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = Main.main6_closure;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$cunions_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main4_closure:
         const Main.main4_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main4_entry() //  [R1]
         { info_tbl: [(c2bq,
                       label: Main.main4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bq:
           _rT2::P32 = R1;
           goto c2bl;
       c2bl:
           if (Sp - <highSp> < SpLim) goto c2br; else goto c2bs;
       c2bs:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bu; else goto c2bt;
       c2bu:
           HpAlloc = 8;
           goto c2br;
       c2br:
           R1 = _rT2::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2bt:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2bn::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT2::P32, Hp - 4);
           if (_c2bn::I32 == 0) goto c2bp; else goto c2bo;
       c2bp:
           call (I32[_rT2::P32])() args: 4, res: 0, upd: 4;
       c2bo:
           I32[(old + 12)] = stg_bh_upd_frame_info;
           P32[(old + 8)] = Hp - 4;
           P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
           P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
           P32[(old + 20)] = GHC.Num.$fNumInt_closure;
           P32[(old + 16)] = Main.main5_closure;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2bq:
      _rT2::P32 = R1;
      goto c2bl;
  c2bl:
      if (Sp - <highSp> < SpLim) goto c2br; else goto c2bs;
  c2bs:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bu; else goto c2bt;
  c2bu:
      HpAlloc = 8;
      goto c2br;
  c2br:
      R1 = _rT2::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bt:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bn::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT2::P32, Hp - 4);
      if (_c2bn::I32 == 0) goto c2bp; else goto c2bo;
  c2bp:
      call (I32[_rT2::P32])() args: 4, res: 0, upd: 4;
  c2bo:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main5_closure;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c2bq:
      _rT2::P32 = R1;
      goto c2bl;
  c2bl:
      if (Sp - <highSp> < SpLim) goto c2br; else goto c2bs;
  c2bs:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bu; else goto c2bt;
  c2bu:
      HpAlloc = 8;
      goto c2br;
  c2br:
      R1 = _rT2::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bt:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bn::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT2::P32, Hp - 4);
      if (_c2bn::I32 == 0) goto c2bp; else goto c2bo;
  c2bp:
      call (I32[_rT2::P32])() args: 4, res: 0, upd: 4;
  c2bo:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main5_closure;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c2bq:
      _rT2::P32 = R1;
      goto c2bl;
  c2bl:
      if (Sp - <highSp> < SpLim) goto c2br; else goto c2bs;
  c2bs:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bu; else goto c2bt;
  c2bu:
      HpAlloc = 8;
      goto c2br;
  c2br:
      R1 = _rT2::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bt:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bn::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT2::P32, Hp - 4);
      if (_c2bn::I32 == 0) goto c2bp; else goto c2bo;
  c2bp:
      call (I32[_rT2::P32])() args: 4, res: 0, upd: 4;
  c2bo:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main5_closure;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2bq:
      _rT2::P32 = R1;
      goto c2bl;
  c2bl:
      if (Sp - <highSp> < SpLim) goto c2br; else goto c2bs;
  c2bs:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bu; else goto c2bt;
  c2bu:
      HpAlloc = 8;
      goto c2br;
  c2br:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bt:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bn::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2bn::I32 == 0) goto c2bp; else goto c2bo;
  c2bp:
      call (I32[_rT2::P32])() args: 4, res: 0, upd: 4;
  c2bo:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Classes.$fOrdInt_closure;
      P32[(old + 24)] = GHC.Classes.$fEqInt_closure;
      P32[(old + 20)] = GHC.Num.$fNumInt_closure;
      P32[(old + 16)] = Main.main5_closure;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c2bq:
      _rT2::P32 = R1;
      goto c2bl;
  c2bl:
      if (Sp - 24 < SpLim) goto c2br; else goto c2bs;
  c2bs:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bu; else goto c2bt;
  c2bu:
      HpAlloc = 8;
      goto c2br;
  c2br:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bt:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bn::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2bn::I32 == 0) goto c2bp; else goto c2bo;
  c2bp:
      call (I32[_rT2::P32])() args: 4, res: 0, upd: 4;
  c2bo:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = Main.main5_closure;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c2bq:
      goto c2bl;
  c2bl:
      if ((Sp + -24) < SpLim) goto c2br; else goto c2bs;
  c2bs:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bu; else goto c2bt;
  c2bu:
      HpAlloc = 8;
      goto c2br;
  c2br:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bt:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bn::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2bn::I32 == 0) goto c2bp; else goto c2bo;
  c2bp:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2bo:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
      P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
      P32[Sp - 16] = GHC.Num.$fNumInt_closure;
      P32[Sp - 12] = Main.main5_closure;
      Sp = Sp - 24;
      call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c2bl,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   Main.main5_closure}),
 (c2bo,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   Main.main5_closure}),
 (c2bp, {}),
 (c2bq,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   Main.main5_closure}),
 (c2br, {}),
 (c2bs,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   Main.main5_closure}),
 (c2bt,
  {T2902_B_PairingSum.$fSumPSumab_$ctoList_closure,
   Main.main5_closure}),
 (c2bu, {})]



==================== after setInfoTableStackMap ====================
Main.main4_entry() //  [R1]
        { info_tbl: [(c2bq,
                      label: Main.main4_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2bq:
          goto c2bl;
      c2bl:
          if ((Sp + -24) < SpLim) goto c2br; else goto c2bs;
      c2bs:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2bu; else goto c2bt;
      c2bu:
          HpAlloc = 8;
          goto c2br;
      c2br:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2bt:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2bn::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
          if (_c2bn::I32 == 0) goto c2bp; else goto c2bo;
      c2bp:
          call (I32[R1])() args: 4, res: 0, upd: 4;
      c2bo:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = Main.main5_closure;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
Main.main4_entry() //  [R1]
        { info_tbl: [(c2bl,
                      label: Main.main4_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2bl:
          if ((Sp + -24) < SpLim) goto c2br; else goto c2bs;
      c2bs:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2bu; else goto c2bt;
      c2bu:
          HpAlloc = 8;
          goto c2br;
      c2br:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2bt:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2bn::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
          if (_c2bn::I32 == 0) goto c2bp; else goto c2bo;
      c2bp:
          call (I32[R1])() args: 4, res: 0, upd: 4;
      c2bo:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
          P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
          P32[Sp - 16] = GHC.Num.$fNumInt_closure;
          P32[Sp - 12] = Main.main5_closure;
          Sp = Sp - 24;
          call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main4_closure:
         const Main.main4_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main4_entry() //  [R1]
         { info_tbl: [(c2bl,
                       label: Main.main4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bl:
           if ((Sp + -24) < SpLim) goto c2br; else goto c2bs;
       c2bs:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bu; else goto c2bt;
       c2bu:
           HpAlloc = 8;
           goto c2br;
       c2br:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2bt:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2bn::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
           if (_c2bn::I32 == 0) goto c2bp; else goto c2bo;
       c2bp:
           call (I32[R1])() args: 4, res: 0, upd: 4;
       c2bo:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = Main.main5_closure;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main4_closure:
         const Main.main4_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main4_entry() //  [R1]
         { info_tbl: [(c2bl,
                       label: Main.main4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bl:
           if ((Sp + -24) < SpLim) goto c2br; else goto c2bs;
       c2bs:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bu; else goto c2bt;
       c2bu:
           HpAlloc = 8;
           goto c2br;
       c2br:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2bt:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2bn::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
           if (_c2bn::I32 == 0) goto c2bp; else goto c2bo;
       c2bp:
           call (I32[R1])() args: 4, res: 0, upd: 4;
       c2bo:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Classes.$fOrdInt_closure;
           P32[Sp - 20] = GHC.Classes.$fEqInt_closure;
           P32[Sp - 16] = GHC.Num.$fNumInt_closure;
           P32[Sp - 12] = Main.main5_closure;
           Sp = Sp - 24;
           call T2902_B_PairingSum.$fSumPSumab_$ctoList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main3_closure:
         const Main.main3_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main3_entry() //  [R1]
         { info_tbl: [(c2bK,
                       label: Main.main3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bK:
           _rT4::P32 = R1;
           goto c2bF;
       c2bF:
           if (Sp - <highSp> < SpLim) goto c2bL; else goto c2bM;
       c2bM:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bO; else goto c2bN;
       c2bO:
           HpAlloc = 8;
           goto c2bL;
       c2bL:
           R1 = _rT4::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2bN:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2bH::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT4::P32, Hp - 4);
           if (_c2bH::I32 == 0) goto c2bJ; else goto c2bI;
       c2bJ:
           call (I32[_rT4::P32])() args: 4, res: 0, upd: 4;
       c2bI:
           I32[(old + 12)] = stg_bh_upd_frame_info;
           P32[(old + 8)] = Hp - 4;
           I32[(old + 20)] = 20;
           P32[(old + 16)] = Main.main4_closure;
           call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2bK:
      _rT4::P32 = R1;
      goto c2bF;
  c2bF:
      if (Sp - <highSp> < SpLim) goto c2bL; else goto c2bM;
  c2bM:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bO; else goto c2bN;
  c2bO:
      HpAlloc = 8;
      goto c2bL;
  c2bL:
      R1 = _rT4::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bN:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bH::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT4::P32, Hp - 4);
      if (_c2bH::I32 == 0) goto c2bJ; else goto c2bI;
  c2bJ:
      call (I32[_rT4::P32])() args: 4, res: 0, upd: 4;
  c2bI:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 20)] = 20;
      P32[(old + 16)] = Main.main4_closure;
      call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c2bK:
      _rT4::P32 = R1;
      goto c2bF;
  c2bF:
      if (Sp - <highSp> < SpLim) goto c2bL; else goto c2bM;
  c2bM:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bO; else goto c2bN;
  c2bO:
      HpAlloc = 8;
      goto c2bL;
  c2bL:
      R1 = _rT4::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bN:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bH::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT4::P32, Hp - 4);
      if (_c2bH::I32 == 0) goto c2bJ; else goto c2bI;
  c2bJ:
      call (I32[_rT4::P32])() args: 4, res: 0, upd: 4;
  c2bI:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 20)] = 20;
      P32[(old + 16)] = Main.main4_closure;
      call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c2bK:
      _rT4::P32 = R1;
      goto c2bF;
  c2bF:
      if (Sp - <highSp> < SpLim) goto c2bL; else goto c2bM;
  c2bM:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bO; else goto c2bN;
  c2bO:
      HpAlloc = 8;
      goto c2bL;
  c2bL:
      R1 = _rT4::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bN:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bH::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT4::P32, Hp - 4);
      if (_c2bH::I32 == 0) goto c2bJ; else goto c2bI;
  c2bJ:
      call (I32[_rT4::P32])() args: 4, res: 0, upd: 4;
  c2bI:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 20)] = 20;
      P32[(old + 16)] = Main.main4_closure;
      call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2bK:
      _rT4::P32 = R1;
      goto c2bF;
  c2bF:
      if (Sp - <highSp> < SpLim) goto c2bL; else goto c2bM;
  c2bM:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bO; else goto c2bN;
  c2bO:
      HpAlloc = 8;
      goto c2bL;
  c2bL:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bN:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bH::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2bH::I32 == 0) goto c2bJ; else goto c2bI;
  c2bJ:
      call (I32[_rT4::P32])() args: 4, res: 0, upd: 4;
  c2bI:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 20)] = 20;
      P32[(old + 16)] = Main.main4_closure;
      call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c2bK:
      _rT4::P32 = R1;
      goto c2bF;
  c2bF:
      if (Sp - 16 < SpLim) goto c2bL; else goto c2bM;
  c2bM:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bO; else goto c2bN;
  c2bO:
      HpAlloc = 8;
      goto c2bL;
  c2bL:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bN:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bH::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2bH::I32 == 0) goto c2bJ; else goto c2bI;
  c2bJ:
      call (I32[_rT4::P32])() args: 4, res: 0, upd: 4;
  c2bI:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      I32[Sp - 16] = 20;
      P32[Sp - 12] = Main.main4_closure;
      Sp = Sp - 16;
      call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c2bK:
      goto c2bF;
  c2bF:
      if ((Sp + -16) < SpLim) goto c2bL; else goto c2bM;
  c2bM:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2bO; else goto c2bN;
  c2bO:
      HpAlloc = 8;
      goto c2bL;
  c2bL:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2bN:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2bH::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2bH::I32 == 0) goto c2bJ; else goto c2bI;
  c2bJ:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2bI:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      I32[Sp - 16] = 20;
      P32[Sp - 12] = Main.main4_closure;
      Sp = Sp - 16;
      call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c2bF, {Main.main4_closure}), (c2bI, {Main.main4_closure}),
 (c2bJ, {}), (c2bK, {Main.main4_closure}), (c2bL, {}),
 (c2bM, {Main.main4_closure}), (c2bN, {Main.main4_closure}),
 (c2bO, {})]



==================== after setInfoTableStackMap ====================
Main.main3_entry() //  [R1]
        { info_tbl: [(c2bK,
                      label: Main.main3_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2bK:
          goto c2bF;
      c2bF:
          if ((Sp + -16) < SpLim) goto c2bL; else goto c2bM;
      c2bM:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2bO; else goto c2bN;
      c2bO:
          HpAlloc = 8;
          goto c2bL;
      c2bL:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2bN:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2bH::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
          if (_c2bH::I32 == 0) goto c2bJ; else goto c2bI;
      c2bJ:
          call (I32[R1])() args: 4, res: 0, upd: 4;
      c2bI:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          I32[Sp - 16] = 20;
          P32[Sp - 12] = Main.main4_closure;
          Sp = Sp - 16;
          call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
Main.main3_entry() //  [R1]
        { info_tbl: [(c2bF,
                      label: Main.main3_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2bF:
          if ((Sp + -16) < SpLim) goto c2bL; else goto c2bM;
      c2bM:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2bO; else goto c2bN;
      c2bO:
          HpAlloc = 8;
          goto c2bL;
      c2bL:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2bN:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2bH::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
          if (_c2bH::I32 == 0) goto c2bJ; else goto c2bI;
      c2bJ:
          call (I32[R1])() args: 4, res: 0, upd: 4;
      c2bI:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          I32[Sp - 16] = 20;
          P32[Sp - 12] = Main.main4_closure;
          Sp = Sp - 16;
          call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main3_closure:
         const Main.main3_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main3_entry() //  [R1]
         { info_tbl: [(c2bF,
                       label: Main.main3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bF:
           if ((Sp + -16) < SpLim) goto c2bL; else goto c2bM;
       c2bM:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bO; else goto c2bN;
       c2bO:
           HpAlloc = 8;
           goto c2bL;
       c2bL:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2bN:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2bH::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
           if (_c2bH::I32 == 0) goto c2bJ; else goto c2bI;
       c2bJ:
           call (I32[R1])() args: 4, res: 0, upd: 4;
       c2bI:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           I32[Sp - 16] = 20;
           P32[Sp - 12] = Main.main4_closure;
           Sp = Sp - 16;
           call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main3_closure:
         const Main.main3_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main3_entry() //  [R1]
         { info_tbl: [(c2bF,
                       label: Main.main3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bF:
           if ((Sp + -16) < SpLim) goto c2bL; else goto c2bM;
       c2bM:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2bO; else goto c2bN;
       c2bO:
           HpAlloc = 8;
           goto c2bL;
       c2bL:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2bN:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2bH::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
           if (_c2bH::I32 == 0) goto c2bJ; else goto c2bI;
       c2bJ:
           call (I32[R1])() args: 4, res: 0, upd: 4;
       c2bI:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           I32[Sp - 16] = 20;
           P32[Sp - 12] = Main.main4_closure;
           Sp = Sp - 16;
           call GHC.List.take_unsafe_UInt_info() args: 20, res: 0, upd: 12;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main2_closure:
         const Main.main2_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main2_entry() //  [R1]
         { info_tbl: [(c2c4,
                       label: Main.main2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2c4:
           _rT7::P32 = R1;
           goto c2bZ;
       c2bZ:
           if (Sp - <highSp> < SpLim) goto c2c5; else goto c2c6;
       c2c6:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2c8; else goto c2c7;
       c2c8:
           HpAlloc = 8;
           goto c2c5;
       c2c5:
           R1 = _rT7::P32;
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2c7:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2c1::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
           if (_c2c1::I32 == 0) goto c2c3; else goto c2c2;
       c2c3:
           call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
       c2c2:
           I32[(old + 12)] = stg_bh_upd_frame_info;
           P32[(old + 8)] = Hp - 4;
           P32[(old + 28)] = GHC.Show.$fShowInt_closure;
           P32[(old + 24)] = GHC.Show.$fShowInt_closure;
           P32[(old + 20)] = Main.main3_closure;
           P32[(old + 16)] = GHC.Types.[]_closure+1;
           call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2c4:
      _rT7::P32 = R1;
      goto c2bZ;
  c2bZ:
      if (Sp - <highSp> < SpLim) goto c2c5; else goto c2c6;
  c2c6:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2c8; else goto c2c7;
  c2c8:
      HpAlloc = 8;
      goto c2c5;
  c2c5:
      R1 = _rT7::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2c7:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2c1::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
      if (_c2c1::I32 == 0) goto c2c3; else goto c2c2;
  c2c3:
      call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
  c2c2:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Show.$fShowInt_closure;
      P32[(old + 24)] = GHC.Show.$fShowInt_closure;
      P32[(old + 20)] = Main.main3_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
}



==================== Post common block elimination ====================
{offset
  c2c4:
      _rT7::P32 = R1;
      goto c2bZ;
  c2bZ:
      if (Sp - <highSp> < SpLim) goto c2c5; else goto c2c6;
  c2c6:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2c8; else goto c2c7;
  c2c8:
      HpAlloc = 8;
      goto c2c5;
  c2c5:
      R1 = _rT7::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2c7:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2c1::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
      if (_c2c1::I32 == 0) goto c2c3; else goto c2c2;
  c2c3:
      call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
  c2c2:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Show.$fShowInt_closure;
      P32[(old + 24)] = GHC.Show.$fShowInt_closure;
      P32[(old + 20)] = Main.main3_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
}



==================== Loopify tail calls ====================
{offset
  c2c4:
      _rT7::P32 = R1;
      goto c2bZ;
  c2bZ:
      if (Sp - <highSp> < SpLim) goto c2c5; else goto c2c6;
  c2c6:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2c8; else goto c2c7;
  c2c8:
      HpAlloc = 8;
      goto c2c5;
  c2c5:
      R1 = _rT7::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2c7:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2c1::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _rT7::P32, Hp - 4);
      if (_c2c1::I32 == 0) goto c2c3; else goto c2c2;
  c2c3:
      call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
  c2c2:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Show.$fShowInt_closure;
      P32[(old + 24)] = GHC.Show.$fShowInt_closure;
      P32[(old + 20)] = Main.main3_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2c4:
      _rT7::P32 = R1;
      goto c2bZ;
  c2bZ:
      if (Sp - <highSp> < SpLim) goto c2c5; else goto c2c6;
  c2c6:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2c8; else goto c2c7;
  c2c8:
      HpAlloc = 8;
      goto c2c5;
  c2c5:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2c7:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2c1::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2c1::I32 == 0) goto c2c3; else goto c2c2;
  c2c3:
      call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
  c2c2:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 28)] = GHC.Show.$fShowInt_closure;
      P32[(old + 24)] = GHC.Show.$fShowInt_closure;
      P32[(old + 20)] = Main.main3_closure;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
}



==================== Layout Stack ====================
{offset
  c2c4:
      _rT7::P32 = R1;
      goto c2bZ;
  c2bZ:
      if (Sp - 24 < SpLim) goto c2c5; else goto c2c6;
  c2c6:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2c8; else goto c2c7;
  c2c8:
      HpAlloc = 8;
      goto c2c5;
  c2c5:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2c7:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2c1::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2c1::I32 == 0) goto c2c3; else goto c2c2;
  c2c3:
      call (I32[_rT7::P32])() args: 4, res: 0, upd: 4;
  c2c2:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Show.$fShowInt_closure;
      P32[Sp - 20] = GHC.Show.$fShowInt_closure;
      P32[Sp - 16] = Main.main3_closure;
      P32[Sp - 12] = GHC.Types.[]_closure+1;
      Sp = Sp - 24;
      call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
}



==================== Sink assignments (2) ====================
{offset
  c2c4:
      goto c2bZ;
  c2bZ:
      if ((Sp + -24) < SpLim) goto c2c5; else goto c2c6;
  c2c6:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2c8; else goto c2c7;
  c2c8:
      HpAlloc = 8;
      goto c2c5;
  c2c5:
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2c7:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2c1::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2c1::I32 == 0) goto c2c3; else goto c2c2;
  c2c3:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2c2:
      I32[Sp - 8] = stg_bh_upd_frame_info;
      P32[Sp - 4] = Hp - 4;
      P32[Sp - 24] = GHC.Show.$fShowInt_closure;
      P32[Sp - 20] = GHC.Show.$fShowInt_closure;
      P32[Sp - 16] = Main.main3_closure;
      P32[Sp - 12] = GHC.Types.[]_closure+1;
      Sp = Sp - 24;
      call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
}



==================== CAFEnv ====================
[(c2bZ,
  {Main.main3_closure, GHC.Show.$fShow(,)_$cshowList_closure}),
 (c2c2,
  {Main.main3_closure, GHC.Show.$fShow(,)_$cshowList_closure}),
 (c2c3, {}),
 (c2c4,
  {Main.main3_closure, GHC.Show.$fShow(,)_$cshowList_closure}),
 (c2c5, {}),
 (c2c6,
  {Main.main3_closure, GHC.Show.$fShow(,)_$cshowList_closure}),
 (c2c7,
  {Main.main3_closure, GHC.Show.$fShow(,)_$cshowList_closure}),
 (c2c8, {})]



==================== after setInfoTableStackMap ====================
Main.main2_entry() //  [R1]
        { info_tbl: [(c2c4,
                      label: Main.main2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2c4:
          goto c2bZ;
      c2bZ:
          if ((Sp + -24) < SpLim) goto c2c5; else goto c2c6;
      c2c6:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2c8; else goto c2c7;
      c2c8:
          HpAlloc = 8;
          goto c2c5;
      c2c5:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2c7:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2c1::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
          if (_c2c1::I32 == 0) goto c2c3; else goto c2c2;
      c2c3:
          call (I32[R1])() args: 4, res: 0, upd: 4;
      c2c2:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Show.$fShowInt_closure;
          P32[Sp - 20] = GHC.Show.$fShowInt_closure;
          P32[Sp - 16] = Main.main3_closure;
          P32[Sp - 12] = GHC.Types.[]_closure+1;
          Sp = Sp - 24;
          call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post control-flow optimisations ====================
Main.main2_entry() //  [R1]
        { info_tbl: [(c2bZ,
                      label: Main.main2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2bZ:
          if ((Sp + -24) < SpLim) goto c2c5; else goto c2c6;
      c2c6:
          Hp = Hp + 8;
          if (Hp > HpLim) goto c2c8; else goto c2c7;
      c2c8:
          HpAlloc = 8;
          goto c2c5;
      c2c5:
          call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
      c2c7:
          I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
          I32[Hp] = CurrentTSO;
          (_c2c1::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                   PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
          if (_c2c1::I32 == 0) goto c2c3; else goto c2c2;
      c2c3:
          call (I32[R1])() args: 4, res: 0, upd: 4;
      c2c2:
          I32[Sp - 8] = stg_bh_upd_frame_info;
          P32[Sp - 4] = Hp - 4;
          P32[Sp - 24] = GHC.Show.$fShowInt_closure;
          P32[Sp - 20] = GHC.Show.$fShowInt_closure;
          P32[Sp - 16] = Main.main3_closure;
          P32[Sp - 12] = GHC.Types.[]_closure+1;
          Sp = Sp - 24;
          call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main2_closure:
         const Main.main2_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main2_entry() //  [R1]
         { info_tbl: [(c2bZ,
                       label: Main.main2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bZ:
           if ((Sp + -24) < SpLim) goto c2c5; else goto c2c6;
       c2c6:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2c8; else goto c2c7;
       c2c8:
           HpAlloc = 8;
           goto c2c5;
       c2c5:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2c7:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2c1::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
           if (_c2c1::I32 == 0) goto c2c3; else goto c2c2;
       c2c3:
           call (I32[R1])() args: 4, res: 0, upd: 4;
       c2c2:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Show.$fShowInt_closure;
           P32[Sp - 20] = GHC.Show.$fShowInt_closure;
           P32[Sp - 16] = Main.main3_closure;
           P32[Sp - 12] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main2_closure:
         const Main.main2_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main2_entry() //  [R1]
         { info_tbl: [(c2bZ,
                       label: Main.main2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2bZ:
           if ((Sp + -24) < SpLim) goto c2c5; else goto c2c6;
       c2c6:
           Hp = Hp + 8;
           if (Hp > HpLim) goto c2c8; else goto c2c7;
       c2c8:
           HpAlloc = 8;
           goto c2c5;
       c2c5:
           call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
       c2c7:
           I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
           I32[Hp] = CurrentTSO;
           (_c2c1::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                                    PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
           if (_c2c1::I32 == 0) goto c2c3; else goto c2c2;
       c2c3:
           call (I32[R1])() args: 4, res: 0, upd: 4;
       c2c2:
           I32[Sp - 8] = stg_bh_upd_frame_info;
           P32[Sp - 4] = Hp - 4;
           P32[Sp - 24] = GHC.Show.$fShowInt_closure;
           P32[Sp - 20] = GHC.Show.$fShowInt_closure;
           P32[Sp - 16] = Main.main3_closure;
           P32[Sp - 12] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call GHC.Show.$fShow(,)_$cshowList_info() args: 28, res: 0, upd: 12;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main1_closure:
         const Main.main1_info;
         const 0;
 },
 Main.main1_entry() //  []
         { info_tbl: [(c2cl,
                       label: Main.main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cl:
           goto c2cj;
       c2cj:
           if (Sp - <highSp> < SpLim) goto c2cm; else goto c2cn;
       c2cm:
           R1 = Main.main1_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cn:
           P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
           P32[(old + 12)] = Main.main2_closure;
           P32[(old + 8)] = GHC.Types.True_closure+2;
           call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2cj:
      if (Sp - <highSp> < SpLim) goto c2cm; else goto c2cn;
  c2cm:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cn:
      P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
      P32[(old + 12)] = Main.main2_closure;
      P32[(old + 8)] = GHC.Types.True_closure+2;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c2cj:
      if (Sp - <highSp> < SpLim) goto c2cm; else goto c2cn;
  c2cm:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cn:
      P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
      P32[(old + 12)] = Main.main2_closure;
      P32[(old + 8)] = GHC.Types.True_closure+2;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c2cj:
      if (Sp - <highSp> < SpLim) goto c2cm; else goto c2cn;
  c2cm:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cn:
      P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
      P32[(old + 12)] = Main.main2_closure;
      P32[(old + 8)] = GHC.Types.True_closure+2;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2cj:
      if (Sp - <highSp> < SpLim) goto c2cm; else goto c2cn;
  c2cm:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cn:
      P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
      P32[(old + 12)] = Main.main2_closure;
      P32[(old + 8)] = GHC.Types.True_closure+2;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c2cj:
      if (Sp - 12 < SpLim) goto c2cm; else goto c2cn;
  c2cm:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cn:
      P32[Sp - 12] = GHC.IO.Handle.FD.stdout_closure;
      P32[Sp - 8] = Main.main2_closure;
      P32[Sp - 4] = GHC.Types.True_closure+2;
      Sp = Sp - 12;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c2cj:
      if ((Sp + -12) < SpLim) goto c2cm; else goto c2cn;
  c2cm:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cn:
      P32[Sp - 12] = GHC.IO.Handle.FD.stdout_closure;
      P32[Sp - 8] = Main.main2_closure;
      P32[Sp - 4] = GHC.Types.True_closure+2;
      Sp = Sp - 12;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c2cj,
  {Main.main2_closure, GHC.IO.Handle.FD.stdout_closure,
   GHC.IO.Handle.Text.hPutStr2_closure, Main.main1_closure}),
 (c2cm, {Main.main1_closure}),
 (c2cn,
  {Main.main2_closure, GHC.IO.Handle.FD.stdout_closure,
   GHC.IO.Handle.Text.hPutStr2_closure})]



==================== after setInfoTableStackMap ====================
Main.main1_entry() //  []
        { info_tbl: [(c2cj,
                      label: Main.main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cj:
          if ((Sp + -12) < SpLim) goto c2cm; else goto c2cn;
      c2cm:
          R1 = Main.main1_closure;
          call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
      c2cn:
          P32[Sp - 12] = GHC.IO.Handle.FD.stdout_closure;
          P32[Sp - 8] = Main.main2_closure;
          P32[Sp - 4] = GHC.Types.True_closure+2;
          Sp = Sp - 12;
          call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
Main.main1_entry() //  []
        { info_tbl: [(c2cj,
                      label: Main.main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cj:
          if ((Sp + -12) < SpLim) goto c2cm; else goto c2cn;
      c2cm:
          R1 = Main.main1_closure;
          call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
      c2cn:
          P32[Sp - 12] = GHC.IO.Handle.FD.stdout_closure;
          P32[Sp - 8] = Main.main2_closure;
          P32[Sp - 4] = GHC.Types.True_closure+2;
          Sp = Sp - 12;
          call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main1_closure:
         const Main.main1_info;
         const 0;
 },
 Main.main1_entry() //  []
         { info_tbl: [(c2cj,
                       label: Main.main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cj:
           if ((Sp + -12) < SpLim) goto c2cm; else goto c2cn;
       c2cm:
           R1 = Main.main1_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cn:
           P32[Sp - 12] = GHC.IO.Handle.FD.stdout_closure;
           P32[Sp - 8] = Main.main2_closure;
           P32[Sp - 4] = GHC.Types.True_closure+2;
           Sp = Sp - 12;
           call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main1_closure:
         const Main.main1_info;
         const 0;
 },
 Main.main1_entry() //  []
         { info_tbl: [(c2cj,
                       label: Main.main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cj:
           if ((Sp + -12) < SpLim) goto c2cm; else goto c2cn;
       c2cm:
           R1 = Main.main1_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cn:
           P32[Sp - 12] = GHC.IO.Handle.FD.stdout_closure;
           P32[Sp - 8] = Main.main2_closure;
           P32[Sp - 4] = GHC.Types.True_closure+2;
           Sp = Sp - 12;
           call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main_closure:
         const Main.main_info;
         const 0;
 },
 Main.main_entry() //  []
         { info_tbl: [(c2cx,
                       label: Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cx:
           goto c2cv;
       c2cv:
           if (Sp - <highSp> < SpLim) goto c2cy; else goto c2cz;
       c2cy:
           R1 = Main.main_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cz:
           call Main.main1_info() args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2cv:
      if (Sp - <highSp> < SpLim) goto c2cy; else goto c2cz;
  c2cy:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cz:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c2cv:
      if (Sp - <highSp> < SpLim) goto c2cy; else goto c2cz;
  c2cy:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cz:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c2cv:
      if (Sp - <highSp> < SpLim) goto c2cy; else goto c2cz;
  c2cy:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cz:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2cv:
      if (Sp - <highSp> < SpLim) goto c2cy; else goto c2cz;
  c2cy:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cz:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c2cv:
      goto c2cz;
  c2cz:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c2cv:
      goto c2cz;
  c2cz:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c2cv, {Main.main1_closure}), (c2cz, {Main.main1_closure})]



==================== after setInfoTableStackMap ====================
Main.main_entry() //  []
        { info_tbl: [(c2cv,
                      label: Main.main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cv:
          goto c2cz;
      c2cz:
          call Main.main1_info() args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
Main.main_entry() //  []
        { info_tbl: [(c2cz,
                      label: Main.main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cz:
          call Main.main1_info() args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main_closure:
         const Main.main_info;
         const 0;
 },
 Main.main_entry() //  []
         { info_tbl: [(c2cz,
                       label: Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cz:
           call Main.main1_info() args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main_closure:
         const Main.main_info;
         const 0;
 },
 Main.main_entry() //  []
         { info_tbl: [(c2cz,
                       label: Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cz:
           call Main.main1_info() args: 4, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     Main.main7_closure:
         const Main.main7_info;
         const 0;
 },
 Main.main7_entry() //  []
         { info_tbl: [(c2cI,
                       label: Main.main7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cI:
           goto c2cG;
       c2cG:
           if (Sp - <highSp> < SpLim) goto c2cJ; else goto c2cK;
       c2cJ:
           R1 = Main.main7_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cK:
           P32[(old + 8)] = Main.main1_closure+1;
           call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2cG:
      if (Sp - <highSp> < SpLim) goto c2cJ; else goto c2cK;
  c2cJ:
      R1 = Main.main7_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cK:
      P32[(old + 8)] = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c2cG:
      if (Sp - <highSp> < SpLim) goto c2cJ; else goto c2cK;
  c2cJ:
      R1 = Main.main7_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cK:
      P32[(old + 8)] = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c2cG:
      if (Sp - <highSp> < SpLim) goto c2cJ; else goto c2cK;
  c2cJ:
      R1 = Main.main7_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cK:
      P32[(old + 8)] = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2cG:
      if (Sp - <highSp> < SpLim) goto c2cJ; else goto c2cK;
  c2cJ:
      R1 = Main.main7_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cK:
      P32[(old + 8)] = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c2cG:
      if (Sp - 4 < SpLim) goto c2cJ; else goto c2cK;
  c2cJ:
      R1 = Main.main7_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cK:
      P32[Sp - 4] = Main.main1_closure+1;
      Sp = Sp - 4;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c2cG:
      if ((Sp + -4) < SpLim) goto c2cJ; else goto c2cK;
  c2cJ:
      R1 = Main.main7_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cK:
      P32[Sp - 4] = Main.main1_closure+1;
      Sp = Sp - 4;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c2cG,
  {GHC.TopHandler.runMainIO1_closure, Main.main1_closure,
   Main.main7_closure}),
 (c2cJ, {Main.main7_closure}),
 (c2cK, {GHC.TopHandler.runMainIO1_closure, Main.main1_closure})]



==================== after setInfoTableStackMap ====================
Main.main7_entry() //  []
        { info_tbl: [(c2cG,
                      label: Main.main7_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cG:
          if ((Sp + -4) < SpLim) goto c2cJ; else goto c2cK;
      c2cJ:
          R1 = Main.main7_closure;
          call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
      c2cK:
          P32[Sp - 4] = Main.main1_closure+1;
          Sp = Sp - 4;
          call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
Main.main7_entry() //  []
        { info_tbl: [(c2cG,
                      label: Main.main7_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cG:
          if ((Sp + -4) < SpLim) goto c2cJ; else goto c2cK;
      c2cJ:
          R1 = Main.main7_closure;
          call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
      c2cK:
          P32[Sp - 4] = Main.main1_closure+1;
          Sp = Sp - 4;
          call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     Main.main7_closure:
         const Main.main7_info;
         const 0;
 },
 Main.main7_entry() //  []
         { info_tbl: [(c2cG,
                       label: Main.main7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cG:
           if ((Sp + -4) < SpLim) goto c2cJ; else goto c2cK;
       c2cJ:
           R1 = Main.main7_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cK:
           P32[Sp - 4] = Main.main1_closure+1;
           Sp = Sp - 4;
           call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     Main.main7_closure:
         const Main.main7_info;
         const 0;
 },
 Main.main7_entry() //  []
         { info_tbl: [(c2cG,
                       label: Main.main7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cG:
           if ((Sp + -4) < SpLim) goto c2cJ; else goto c2cK;
       c2cJ:
           R1 = Main.main7_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cK:
           P32[Sp - 4] = Main.main1_closure+1;
           Sp = Sp - 4;
           call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
     }
 }]



==================== Cmm produced by new codegen ====================
[section "data" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
 },
 :Main.main_entry() //  []
         { info_tbl: [(c2cU,
                       label: :Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cU:
           goto c2cS;
       c2cS:
           if (Sp - <highSp> < SpLim) goto c2cV; else goto c2cW;
       c2cV:
           R1 = :Main.main_closure;
           call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
       c2cW:
           call Main.main7_info() args: 4, res: 0, upd: 4;
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  c2cS:
      if (Sp - <highSp> < SpLim) goto c2cV; else goto c2cW;
  c2cV:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cW:
      call Main.main7_info() args: 4, res: 0, upd: 4;
}



==================== Post common block elimination ====================
{offset
  c2cS:
      if (Sp - <highSp> < SpLim) goto c2cV; else goto c2cW;
  c2cV:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cW:
      call Main.main7_info() args: 4, res: 0, upd: 4;
}



==================== Loopify tail calls ====================
{offset
  c2cS:
      if (Sp - <highSp> < SpLim) goto c2cV; else goto c2cW;
  c2cV:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cW:
      call Main.main7_info() args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2cS:
      if (Sp - <highSp> < SpLim) goto c2cV; else goto c2cW;
  c2cV:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2cW:
      call Main.main7_info() args: 4, res: 0, upd: 4;
}



==================== Layout Stack ====================
{offset
  c2cS:
      goto c2cW;
  c2cW:
      call Main.main7_info() args: 4, res: 0, upd: 4;
}



==================== Sink assignments (2) ====================
{offset
  c2cS:
      goto c2cW;
  c2cW:
      call Main.main7_info() args: 4, res: 0, upd: 4;
}



==================== CAFEnv ====================
[(c2cS, {Main.main7_closure}), (c2cW, {Main.main7_closure})]



==================== after setInfoTableStackMap ====================
:Main.main_entry() //  []
        { info_tbl: [(c2cS,
                      label: :Main.main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cS:
          goto c2cW;
      c2cW:
          call Main.main7_info() args: 4, res: 0, upd: 4;
    }
}



==================== Post control-flow optimisations ====================
:Main.main_entry() //  []
        { info_tbl: [(c2cW,
                      label: :Main.main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 4 updfr_space: Just 4
        }
    {offset
      c2cW:
          call Main.main7_info() args: 4, res: 0, upd: 4;
    }
}



==================== Post CPS Cmm ====================
[section "data" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
 },
 :Main.main_entry() //  []
         { info_tbl: [(c2cW,
                       label: :Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cW:
           call Main.main7_info() args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "data" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
 },
 :Main.main_entry() //  []
         { info_tbl: [(c2cW,
                       label: :Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 4 updfr_space: Just 4
         }
     {offset
       c2cW:
           call Main.main7_info() args: 4, res: 0, upd: 4;
     }
 }]



==================== Output Cmm ====================
[section "relreadonly" {
     S26h_srt:
         const T2902_B_PairingSum.$fSumPSumab_$cfromList_closure;
         const Main.main_go_closure;
         const lvl1_r23T_closure;
         const T2902_B_PairingSum.$fSumPSumab_$cunions_closure;
         const Main.main6_closure;
         const T2902_B_PairingSum.$fSumPSumab_$ctoList_closure;
         const Main.main5_closure;
         const Main.main4_closure;
         const Main.main3_closure;
         const GHC.Show.$fShow(,)_$cshowList_closure;
         const Main.main2_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.Text.hPutStr2_closure;
         const Main.main1_closure;
         const GHC.TopHandler.runMainIO1_closure;
         const Main.main7_closure;
 }]


Linking T2902_B ...
