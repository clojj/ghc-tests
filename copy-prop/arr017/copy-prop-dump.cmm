[1 of 1] Compiling Main             ( arr017.hs, arr017.o )

==================== Before copy propagation ====================
{offset
  c2nE:
      _r2h8::P32 = R1;
      _s2hQ::P32 = P32[(old + 16)];
      _s2hR::F64 = F64[(old + 12)];
      R1 = _r2h8::P32;
      P32[(old + 16)] = _s2hQ::P32;
      F64[(old + 12)] = _s2hR::F64;
      call Main.$wsum'1_info(R1) args: 16, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2nE:
      _r2h8::P32 = R1;
      _s2hQ::P32 = P32[(old + 16)];
      _s2hR::F64 = F64[(old + 12)];
      R1 = R1;
      P32[(old + 16)] = _s2hQ::P32;
      F64[(old + 12)] = _s2hR::F64;
      call Main.$wsum'1_info(R1) args: 16, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2nR:
      _s2hQ::P32 = P32[(old + 16)];
      _s2hR::F64 = F64[(old + 12)];
      goto c2nF;
  c2nF:
      if (Sp - <highSp> < SpLim) goto c2nS; else goto c2nT;
  c2nS:
      R1 = Main.$wsum'1_closure;
      P32[(old + 16)] = _s2hQ::P32;
      F64[(old + 12)] = _s2hR::F64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2nT:
      I32[(young<c2nH> + 4)] = c2nH;
      R1 = _s2hQ::P32;
      if (R1 & 3 != 0) goto c2nH; else goto c2nI;
  c2nI:
      call (I32[R1])(R1) returns to c2nH, args: 4, res: 4, upd: 4;
  c2nH:
      _s2hS::P32 = R1;
      _c2nN::P32 = _s2hS::P32 & 3;
      if (_c2nN::P32 >= 2) goto c2nM; else goto c2nL;
  c2nM:
      _s2hT::P32 = P32[_s2hS::P32 + 2];
      _s2hU::P32 = P32[_s2hS::P32 + 6];
      I32[(young<c2nZ> + 4)] = c2nZ;
      R1 = _s2hT::P32;
      if (R1 & 3 != 0) goto c2nZ; else goto c2o1;
  c2o1:
      call (I32[R1])(R1) returns to c2nZ, args: 4, res: 4, upd: 4;
  c2nZ:
      _s2hV::P32 = R1;
      _s2hW::F64 = F64[_s2hV::P32 + 3];
      _c2o6::F64 = %MO_F_Add_W64(_s2hR::F64, _s2hW::F64);
      _s2hX::F64 = _c2o6::F64;
      P32[(old + 16)] = _s2hU::P32;
      F64[(old + 12)] = _s2hX::F64;
      call Main.$wsum'1_info() args: 16, res: 0, upd: 4;
  c2nL:
      D1 = _s2hR::F64;
      call (P32[(old + 4)])(D1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2nR:
      _s2hQ::P32 = P32[(old + 16)];
      _s2hR::F64 = F64[(old + 12)];
      goto c2nF;
  c2nF:
      if (Sp - <highSp> < SpLim) goto c2nS; else goto c2nT;
  c2nS:
      R1 = Main.$wsum'1_closure;
      P32[(old + 16)] = _s2hQ::P32;
      F64[(old + 12)] = _s2hR::F64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2nT:
      I32[(young<c2nH> + 4)] = c2nH;
      R1 = _s2hQ::P32;
      if (_s2hQ::P32 & 3 != 0) goto c2nH; else goto c2nI;
  c2nI:
      call (I32[_s2hQ::P32])(R1) returns to c2nH, args: 4, res: 4, upd: 4;
  c2nH:
      _s2hS::P32 = R1;
      _c2nN::P32 = R1 & 3;
      if (_c2nN::P32 >= 2) goto c2nM; else goto c2nL;
  c2nM:
      _s2hT::P32 = P32[R1 + 2];
      _s2hU::P32 = P32[R1 + 6];
      I32[(young<c2nZ> + 4)] = c2nZ;
      R1 = _s2hT::P32;
      if (_s2hT::P32 & 3 != 0) goto c2nZ; else goto c2o1;
  c2o1:
      call (I32[_s2hT::P32])(R1) returns to c2nZ, args: 4, res: 4, upd: 4;
  c2nZ:
      _s2hV::P32 = R1;
      _s2hW::F64 = F64[R1 + 3];
      _c2o6::F64 = %MO_F_Add_W64(_s2hR::F64, _s2hW::F64);
      _s2hX::F64 = _c2o6::F64;
      P32[(old + 16)] = _s2hU::P32;
      F64[(old + 12)] = _c2o6::F64;
      call Main.$wsum'1_info() args: 16, res: 0, upd: 4;
  c2nL:
      D1 = _s2hR::F64;
      call (P32[(old + 4)])(D1) args: 4, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2ox:
      _s2hY::P32 = P32[(old + 12)];
      _s2hZ::P32 = P32[(old + 8)];
      goto c2os;
  c2os:
      if (Sp - <highSp> < SpLim) goto c2oF; else goto c2oG;
  c2oF:
      R1 = Main.$ssum_sum'1_closure;
      P32[(old + 12)] = _s2hY::P32;
      P32[(old + 8)] = _s2hZ::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c2oG:
      I32[(young<c2ou> + 4)] = c2ou;
      R1 = _s2hZ::P32;
      if (R1 & 3 != 0) goto c2ou; else goto c2ov;
  c2ov:
      call (I32[R1])(R1) returns to c2ou, args: 4, res: 4, upd: 4;
  c2ou:
      _s2i0::P32 = R1;
      _s2i1::F64 = F64[_s2i0::P32 + 3];
      I32[(young<c2oA> + 4)] = c2oA;
      P32[(young<c2oA> + 16)] = _s2hY::P32;
      F64[(young<c2oA> + 12)] = _s2i1::F64;
      call Main.$wsum'1_info() returns to c2oA, args: 16, res: 4, upd: 4;
  c2oA:
      _s2i2::F64 = D1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2oK; else goto c2oJ;
  c2oK:
      HpAlloc = 12;
      goto c2oI;
  c2oI:
      D1 = _s2i2::F64;
      call stg_gc_d1(D1) returns to c2oA, args: 4, res: 4, upd: 4;
  c2oJ:
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _s2i2::F64;
      _c2oE::P32 = Hp - 7;
      R1 = _c2oE::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2ox:
      _s2hY::P32 = P32[(old + 12)];
      _s2hZ::P32 = P32[(old + 8)];
      goto c2os;
  c2os:
      if (Sp - <highSp> < SpLim) goto c2oF; else goto c2oG;
  c2oF:
      R1 = Main.$ssum_sum'1_closure;
      P32[(old + 12)] = _s2hY::P32;
      P32[(old + 8)] = _s2hZ::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c2oG:
      I32[(young<c2ou> + 4)] = c2ou;
      R1 = _s2hZ::P32;
      if (_s2hZ::P32 & 3 != 0) goto c2ou; else goto c2ov;
  c2ov:
      call (I32[_s2hZ::P32])(R1) returns to c2ou, args: 4, res: 4, upd: 4;
  c2ou:
      _s2i0::P32 = R1;
      _s2i1::F64 = F64[R1 + 3];
      I32[(young<c2oA> + 4)] = c2oA;
      P32[(young<c2oA> + 16)] = _s2hY::P32;
      F64[(young<c2oA> + 12)] = _s2i1::F64;
      call Main.$wsum'1_info() returns to c2oA, args: 16, res: 4, upd: 4;
  c2oA:
      _s2i2::F64 = D1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2oK; else goto c2oJ;
  c2oK:
      HpAlloc = 12;
      goto c2oI;
  c2oI:
      D1 = D1;
      call stg_gc_d1(D1) returns to c2oA, args: 4, res: 4, upd: 4;
  c2oJ:
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = D1;
      _c2oE::P32 = Hp - 7;
      R1 = _c2oE::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2p2:
      _s2i3::P32 = P32[(old + 8)];
      goto c2oY;
  c2oY:
      if (Sp - <highSp> < SpLim) goto c2p6; else goto c2p7;
  c2p6:
      R1 = Main.$ssum_closure;
      P32[(old + 8)] = _s2i3::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2p7:
      I32[(young<c2p0> + 4)] = c2p0;
      P32[(young<c2p0> + 16)] = _s2i3::P32;
      F64[(young<c2p0> + 12)] = 0.0 :: W64;
      call Main.$wsum'1_info() returns to c2p0, args: 16, res: 4, upd: 4;
  c2p0:
      _s2i4::F64 = D1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2pa; else goto c2p9;
  c2pa:
      HpAlloc = 12;
      goto c2p8;
  c2p8:
      D1 = _s2i4::F64;
      call stg_gc_d1(D1) returns to c2p0, args: 4, res: 4, upd: 4;
  c2p9:
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _s2i4::F64;
      _c2p5::P32 = Hp - 7;
      R1 = _c2p5::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2p2:
      _s2i3::P32 = P32[(old + 8)];
      goto c2oY;
  c2oY:
      if (Sp - <highSp> < SpLim) goto c2p6; else goto c2p7;
  c2p6:
      R1 = Main.$ssum_closure;
      P32[(old + 8)] = _s2i3::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2p7:
      I32[(young<c2p0> + 4)] = c2p0;
      P32[(young<c2p0> + 16)] = _s2i3::P32;
      F64[(young<c2p0> + 12)] = 0.0 :: W64;
      call Main.$wsum'1_info() returns to c2p0, args: 16, res: 4, upd: 4;
  c2p0:
      _s2i4::F64 = D1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2pa; else goto c2p9;
  c2pa:
      HpAlloc = 12;
      goto c2p8;
  c2p8:
      D1 = D1;
      call stg_gc_d1(D1) returns to c2p0, args: 4, res: 4, upd: 4;
  c2p9:
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = D1;
      _c2p5::P32 = Hp - 7;
      R1 = _c2p5::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2pt:
      _r2hj::P32 = R1;
      goto c2pn;
  c2pn:
      if (Sp - <highSp> < SpLim) goto c2pu; else goto c2pv;
  c2pv:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2px; else goto c2pw;
  c2px:
      HpAlloc = 8;
      goto c2pu;
  c2pu:
      R1 = _r2hj::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2pw:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2pp::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hj::P32, Hp - 4);
      if (_c2pp::I32 == 0) goto c2pr; else goto c2pq;
  c2pr:
      call (I32[_r2hj::P32])() args: 4, res: 0, upd: 4;
  c2pq:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = c2ps_str;
      call Control.Exception.Base.irrefutPatError_info() args: 16, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2pt:
      _r2hj::P32 = R1;
      goto c2pn;
  c2pn:
      if (Sp - <highSp> < SpLim) goto c2pu; else goto c2pv;
  c2pv:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2px; else goto c2pw;
  c2px:
      HpAlloc = 8;
      goto c2pu;
  c2pu:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2pw:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2pp::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2pp::I32 == 0) goto c2pr; else goto c2pq;
  c2pr:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2pq:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = c2ps_str;
      call Control.Exception.Base.irrefutPatError_info() args: 16, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2pV:
      _r2hr::P32 = R1;
      goto c2pQ;
  c2pQ:
      if (Sp - <highSp> < SpLim) goto c2pW; else goto c2pX;
  c2pX:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2pZ; else goto c2pY;
  c2pZ:
      HpAlloc = 8;
      goto c2pW;
  c2pW:
      R1 = _r2hr::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2pY:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2pS::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hr::P32, Hp - 4);
      if (_c2pS::I32 == 0) goto c2pU; else goto c2pT;
  c2pU:
      call (I32[_r2hr::P32])() args: 4, res: 0, upd: 4;
  c2pT:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToInteger_info() args: 24, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2pV:
      _r2hr::P32 = R1;
      goto c2pQ;
  c2pQ:
      if (Sp - <highSp> < SpLim) goto c2pW; else goto c2pX;
  c2pX:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2pZ; else goto c2pY;
  c2pZ:
      HpAlloc = 8;
      goto c2pW;
  c2pW:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2pY:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2pS::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2pS::I32 == 0) goto c2pU; else goto c2pT;
  c2pU:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2pT:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToInteger_info() args: 24, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2qf:
      _r2hs::P32 = R1;
      goto c2qa;
  c2qa:
      if (Sp - <highSp> < SpLim) goto c2qg; else goto c2qh;
  c2qh:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2qj; else goto c2qi;
  c2qj:
      HpAlloc = 8;
      goto c2qg;
  c2qg:
      R1 = _r2hs::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2qi:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2qc::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hs::P32, Hp - 4);
      if (_c2qc::I32 == 0) goto c2qe; else goto c2qd;
  c2qe:
      call (I32[_r2hs::P32])() args: 4, res: 0, upd: 4;
  c2qd:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToInteger_info() args: 24, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2qf:
      _r2hs::P32 = R1;
      goto c2qa;
  c2qa:
      if (Sp - <highSp> < SpLim) goto c2qg; else goto c2qh;
  c2qh:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2qj; else goto c2qi;
  c2qj:
      HpAlloc = 8;
      goto c2qg;
  c2qg:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2qi:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2qc::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2qc::I32 == 0) goto c2qe; else goto c2qd;
  c2qe:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2qd:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToInteger_info() args: 24, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2qz:
      _r2ht::P32 = R1;
      goto c2qu;
  c2qu:
      if (Sp - <highSp> < SpLim) goto c2qA; else goto c2qB;
  c2qB:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2qD; else goto c2qC;
  c2qD:
      HpAlloc = 8;
      goto c2qA;
  c2qA:
      R1 = _r2ht::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2qC:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2qw::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2ht::P32, Hp - 4);
      if (_c2qw::I32 == 0) goto c2qy; else goto c2qx;
  c2qy:
      call (I32[_r2ht::P32])() args: 4, res: 0, upd: 4;
  c2qx:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToInteger_info() args: 24, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2qz:
      _r2ht::P32 = R1;
      goto c2qu;
  c2qu:
      if (Sp - <highSp> < SpLim) goto c2qA; else goto c2qB;
  c2qB:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2qD; else goto c2qC;
  c2qD:
      HpAlloc = 8;
      goto c2qA;
  c2qA:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2qC:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2qw::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2qw::I32 == 0) goto c2qy; else goto c2qx;
  c2qy:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2qx:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToInteger_info() args: 24, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2qT:
      _r2hu::P32 = R1;
      goto c2qO;
  c2qO:
      if (Sp - <highSp> < SpLim) goto c2qU; else goto c2qV;
  c2qV:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2qX; else goto c2qW;
  c2qX:
      HpAlloc = 8;
      goto c2qU;
  c2qU:
      R1 = _r2hu::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2qW:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2qQ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hu::P32, Hp - 4);
      if (_c2qQ::I32 == 0) goto c2qS; else goto c2qR;
  c2qS:
      call (I32[_r2hu::P32])() args: 4, res: 0, upd: 4;
  c2qR:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToInteger_info() args: 24, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2qT:
      _r2hu::P32 = R1;
      goto c2qO;
  c2qO:
      if (Sp - <highSp> < SpLim) goto c2qU; else goto c2qV;
  c2qV:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2qX; else goto c2qW;
  c2qX:
      HpAlloc = 8;
      goto c2qU;
  c2qU:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2qW:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2qQ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2qQ::I32 == 0) goto c2qS; else goto c2qR;
  c2qS:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2qR:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToInteger_info() args: 24, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2rh:
      _r2hw::P32 = R1;
      goto c2rb;
  c2rb:
      if (Sp - <highSp> < SpLim) goto c2ri; else goto c2rj;
  c2rj:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2rl; else goto c2rk;
  c2rl:
      HpAlloc = 8;
      goto c2ri;
  c2ri:
      R1 = _r2hw::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2rk:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2rd::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hw::P32, Hp - 4);
      if (_c2rd::I32 == 0) goto c2rf; else goto c2re;
  c2rf:
      call (I32[_r2hw::P32])() args: 4, res: 0, upd: 4;
  c2re:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = c2rg_str;
      call GHC.CString.unpackCString#_info() args: 16, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2rh:
      _r2hw::P32 = R1;
      goto c2rb;
  c2rb:
      if (Sp - <highSp> < SpLim) goto c2ri; else goto c2rj;
  c2rj:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2rl; else goto c2rk;
  c2rl:
      HpAlloc = 8;
      goto c2ri;
  c2ri:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2rk:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2rd::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2rd::I32 == 0) goto c2rf; else goto c2re;
  c2rf:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2re:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = c2rg_str;
      call GHC.CString.unpackCString#_info() args: 16, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2rz:
      _s2i5::P32 = P32[(old + 8)];
      goto c2rx;
  c2rx:
      if (Sp - <highSp> < SpLim) goto c2rA; else goto c2rB;
  c2rA:
      R1 = lvl6_r2hx_closure;
      P32[(old + 8)] = _s2i5::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2rB:
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = lvl4_r2hv_closure+1;
      P32[(old + 12)] = _s2i5::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2rz:
      _s2i5::P32 = P32[(old + 8)];
      goto c2rx;
  c2rx:
      if (Sp - <highSp> < SpLim) goto c2rA; else goto c2rB;
  c2rA:
      R1 = lvl6_r2hx_closure;
      P32[(old + 8)] = _s2i5::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2rB:
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = lvl4_r2hv_closure+1;
      P32[(old + 12)] = _s2i5::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2rM:
      _s2i6::P32 = P32[(old + 8)];
      goto c2rK;
  c2rK:
      if (Sp - <highSp> < SpLim) goto c2rN; else goto c2rO;
  c2rN:
      R1 = poly_$w$j_r2hy_closure;
      P32[(old + 8)] = _s2i6::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2rO:
      P32[(old + 8)] = _s2i6::P32;
      call lvl6_r2hx_info() args: 8, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2rM:
      _s2i6::P32 = P32[(old + 8)];
      goto c2rK;
  c2rK:
      if (Sp - <highSp> < SpLim) goto c2rN; else goto c2rO;
  c2rN:
      R1 = poly_$w$j_r2hy_closure;
      P32[(old + 8)] = _s2i6::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2rO:
      P32[(old + 8)] = _s2i6::P32;
      call lvl6_r2hx_info() args: 8, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2rY:
      _s2i9::P32 = P32[(old + 16)];
      _s2ia::P32 = P32[(old + 12)];
      _s2ib::P32 = P32[(old + 8)];
      goto c2rV;
  c2rV:
      if (Sp - <highSp> < SpLim) goto c2rZ; else goto c2s0;
  c2s0:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2s2; else goto c2s1;
  c2s2:
      HpAlloc = 12;
      goto c2rZ;
  c2rZ:
      R1 = lvl7_r2hz_closure;
      P32[(old + 16)] = _s2i9::P32;
      P32[(old + 12)] = _s2ia::P32;
      P32[(old + 8)] = _s2ib::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2s1:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2ia::P32;
      P32[Hp] = _s2ib::P32;
      _c2rX::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2rX::P32;
      P32[(old + 12)] = _s2i9::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2rY:
      _s2i9::P32 = P32[(old + 16)];
      _s2ia::P32 = P32[(old + 12)];
      _s2ib::P32 = P32[(old + 8)];
      goto c2rV;
  c2rV:
      if (Sp - <highSp> < SpLim) goto c2rZ; else goto c2s0;
  c2s0:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2s2; else goto c2s1;
  c2s2:
      HpAlloc = 12;
      goto c2rZ;
  c2rZ:
      R1 = lvl7_r2hz_closure;
      P32[(old + 16)] = _s2i9::P32;
      P32[(old + 12)] = _s2ia::P32;
      P32[(old + 8)] = _s2ib::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2s1:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2ia::P32;
      P32[Hp] = _s2ib::P32;
      _c2rX::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2rX::P32;
      P32[(old + 12)] = _s2i9::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2sf:
      _s2id::P32 = P32[(old + 16)];
      _s2ie::P32 = P32[(old + 12)];
      _s2if::P32 = P32[(old + 8)];
      goto c2sd;
  c2sd:
      if (Sp - <highSp> < SpLim) goto c2sg; else goto c2sh;
  c2sg:
      R1 = poly_$w$j1_r2hA_closure;
      P32[(old + 16)] = _s2id::P32;
      P32[(old + 12)] = _s2ie::P32;
      P32[(old + 8)] = _s2if::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2sh:
      P32[(old + 16)] = _s2id::P32;
      P32[(old + 12)] = _s2ie::P32;
      P32[(old + 8)] = _s2if::P32;
      call lvl7_r2hz_info() args: 16, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2sf:
      _s2id::P32 = P32[(old + 16)];
      _s2ie::P32 = P32[(old + 12)];
      _s2if::P32 = P32[(old + 8)];
      goto c2sd;
  c2sd:
      if (Sp - <highSp> < SpLim) goto c2sg; else goto c2sh;
  c2sg:
      R1 = poly_$w$j1_r2hA_closure;
      P32[(old + 16)] = _s2id::P32;
      P32[(old + 12)] = _s2ie::P32;
      P32[(old + 8)] = _s2if::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2sh:
      P32[(old + 16)] = _s2id::P32;
      P32[(old + 12)] = _s2ie::P32;
      P32[(old + 8)] = _s2if::P32;
      call lvl7_r2hz_info() args: 16, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2st:
      _s2ii::P32 = P32[(old + 8)];
      goto c2sr;
  c2sr:
      if (Sp - <highSp> < SpLim) goto c2su; else goto c2sv;
  c2su:
      R1 = lvl9_r2hC_closure;
      P32[(old + 8)] = _s2ii::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2sv:
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = lvl8_r2hB_closure+1;
      P32[(old + 12)] = _s2ii::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2st:
      _s2ii::P32 = P32[(old + 8)];
      goto c2sr;
  c2sr:
      if (Sp - <highSp> < SpLim) goto c2su; else goto c2sv;
  c2su:
      R1 = lvl9_r2hC_closure;
      P32[(old + 8)] = _s2ii::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2sv:
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = lvl8_r2hB_closure+1;
      P32[(old + 12)] = _s2ii::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2sG:
      _s2ij::P32 = P32[(old + 8)];
      goto c2sE;
  c2sE:
      if (Sp - <highSp> < SpLim) goto c2sH; else goto c2sI;
  c2sH:
      R1 = poly_$w$j2_r2hD_closure;
      P32[(old + 8)] = _s2ij::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2sI:
      P32[(old + 8)] = _s2ij::P32;
      call lvl9_r2hC_info() args: 8, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2sG:
      _s2ij::P32 = P32[(old + 8)];
      goto c2sE;
  c2sE:
      if (Sp - <highSp> < SpLim) goto c2sH; else goto c2sI;
  c2sH:
      R1 = poly_$w$j2_r2hD_closure;
      P32[(old + 8)] = _s2ij::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2sI:
      P32[(old + 8)] = _s2ij::P32;
      call lvl9_r2hC_info() args: 8, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2sS:
      _s2im::P32 = P32[(old + 16)];
      _s2in::P32 = P32[(old + 12)];
      _s2io::P32 = P32[(old + 8)];
      goto c2sP;
  c2sP:
      if (Sp - <highSp> < SpLim) goto c2sT; else goto c2sU;
  c2sU:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2sW; else goto c2sV;
  c2sW:
      HpAlloc = 12;
      goto c2sT;
  c2sT:
      R1 = lvl10_r2hE_closure;
      P32[(old + 16)] = _s2im::P32;
      P32[(old + 12)] = _s2in::P32;
      P32[(old + 8)] = _s2io::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2sV:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2in::P32;
      P32[Hp] = _s2io::P32;
      _c2sR::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2sR::P32;
      P32[(old + 12)] = _s2im::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2sS:
      _s2im::P32 = P32[(old + 16)];
      _s2in::P32 = P32[(old + 12)];
      _s2io::P32 = P32[(old + 8)];
      goto c2sP;
  c2sP:
      if (Sp - <highSp> < SpLim) goto c2sT; else goto c2sU;
  c2sU:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2sW; else goto c2sV;
  c2sW:
      HpAlloc = 12;
      goto c2sT;
  c2sT:
      R1 = lvl10_r2hE_closure;
      P32[(old + 16)] = _s2im::P32;
      P32[(old + 12)] = _s2in::P32;
      P32[(old + 8)] = _s2io::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2sV:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2in::P32;
      P32[Hp] = _s2io::P32;
      _c2sR::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2sR::P32;
      P32[(old + 12)] = _s2im::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2t9:
      _s2iq::P32 = P32[(old + 16)];
      _s2ir::P32 = P32[(old + 12)];
      _s2is::P32 = P32[(old + 8)];
      goto c2t7;
  c2t7:
      if (Sp - <highSp> < SpLim) goto c2ta; else goto c2tb;
  c2ta:
      R1 = poly_$w$j3_r2hF_closure;
      P32[(old + 16)] = _s2iq::P32;
      P32[(old + 12)] = _s2ir::P32;
      P32[(old + 8)] = _s2is::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2tb:
      P32[(old + 16)] = _s2iq::P32;
      P32[(old + 12)] = _s2ir::P32;
      P32[(old + 8)] = _s2is::P32;
      call lvl10_r2hE_info() args: 16, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2t9:
      _s2iq::P32 = P32[(old + 16)];
      _s2ir::P32 = P32[(old + 12)];
      _s2is::P32 = P32[(old + 8)];
      goto c2t7;
  c2t7:
      if (Sp - <highSp> < SpLim) goto c2ta; else goto c2tb;
  c2ta:
      R1 = poly_$w$j3_r2hF_closure;
      P32[(old + 16)] = _s2iq::P32;
      P32[(old + 12)] = _s2ir::P32;
      P32[(old + 8)] = _s2is::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2tb:
      P32[(old + 16)] = _s2iq::P32;
      P32[(old + 12)] = _s2ir::P32;
      P32[(old + 8)] = _s2is::P32;
      call lvl10_r2hE_info() args: 16, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2yK:
      _s2iV::P32 = R1;
      goto c2yI;
  c2yI:
      if (Sp - <highSp> < SpLim) goto c2yL; else goto c2yM;
  c2yL:
      R1 = _s2iV::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2yM:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2iV::P32;
      _s2iT::P32 = P32[_s2iV::P32 + 8];
      P32[(old + 20)] = _s2iT::P32;
      P32[(old + 16)] = Main.main5_closure+1;
      call GHC.Integer.Type.minusInteger_info() args: 20, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2yK:
      _s2iV::P32 = R1;
      goto c2yI;
  c2yI:
      if (Sp - <highSp> < SpLim) goto c2yL; else goto c2yM;
  c2yL:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2yM:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s2iT::P32 = P32[R1 + 8];
      P32[(old + 20)] = _s2iT::P32;
      P32[(old + 16)] = Main.main5_closure+1;
      call GHC.Integer.Type.minusInteger_info() args: 20, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2zz:
      _s2jP::P32 = R1;
      goto c2zu;
  c2zu:
      if (Sp - <highSp> < SpLim) goto c2zQ; else goto c2zR;
  c2zQ:
      R1 = _s2jP::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2zR:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2jP::P32;
      _s2iv::P32 = P32[_s2jP::P32 + 8];
      _s2iT::P32 = P32[_s2jP::P32 + 12];
      _s2j0::P32 = P32[_s2jP::P32 + 16];
      _s2jf::P32 = P32[_s2jP::P32 + 20];
      I32[(young<c2zw> + 4)] = c2zw;
      R1 = _s2jf::P32;
      if (R1 & 3 != 0) goto c2zw; else goto c2zx;
  c2zx:
      call (I32[R1])(R1) returns to c2zw, args: 4, res: 4, upd: 12;
  c2zw:
      _s2jg::P32 = R1;
      _s2jh::F64 = F64[_s2jg::P32 + 3];
      I32[(young<c2zC> + 4)] = c2zC;
      P32[(young<c2zC> + 8)] = _s2iT::P32;
      call GHC.Integer.Type.doubleFromInteger_info() returns to c2zC, args: 8, res: 4, upd: 12;
  c2zC:
      _s2ji::F64 = D1;
      I32[(young<c2zG> + 4)] = c2zG;
      P32[(young<c2zG> + 8)] = _s2j0::P32;
      call GHC.Integer.Type.doubleFromInteger_info() returns to c2zG, args: 8, res: 4, upd: 12;
  c2zG:
      _s2jj::F64 = D1;
      I32[(young<c2zK> + 4)] = c2zK;
      R1 = _s2iv::P32;
      if (R1 & 3 != 0) goto c2zK; else goto c2zL;
  c2zL:
      call (I32[R1])(R1) returns to c2zK, args: 4, res: 4, upd: 12;
  c2zK:
      _s2jk::P32 = R1;
      _s2jl::P32 = P32[_s2jk::P32 + 3];
      _s2jm::P32 = P32[_s2jk::P32 + 7];
      _s2jo::P32 = P32[_s2jk::P32 + 11];
      _s2jn::I32 = I32[_s2jk::P32 + 15];
      I32[(young<c2zP> + 4)] = c2zP;
      P32[(young<c2zP> + 12)] = _s2jl::P32;
      P32[(young<c2zP> + 8)] = _s2j0::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2zP, args: 12, res: 4, upd: 12;
  c2zP:
      _s2jp::I32 = R1;
      if (_s2jp::I32 >= 1) goto c2A6; else goto c2Ad;
  c2A6:
      I32[(young<c2A5> + 4)] = c2A5;
      P32[(young<c2A5> + 12)] = _s2j0::P32;
      P32[(young<c2A5> + 8)] = _s2jm::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2A5, args: 12, res: 4, upd: 12;
  c2A5:
      _s2jr::I32 = R1;
      if (_s2jr::I32 >= 1) goto c2Al; else goto c2Ad;
  c2Al:
      I32[(young<c2Ag> + 4)] = c2Ag;
      P32[(young<c2Ag> + 12)] = _s2j0::P32;
      P32[(young<c2Ag> + 8)] = _s2jl::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2Ag, args: 12, res: 4, upd: 12;
  c2Ag:
      _s2jt::P32 = R1;
      I32[(young<c2Ak> + 4)] = c2Ak;
      P32[(young<c2Ak> + 8)] = _s2jt::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2Ak, args: 8, res: 4, upd: 12;
  c2Ak:
      _s2ju::I32 = R1;
      _c2Ar::I32 = %MO_S_Le_W32(0, _s2ju::I32);
      _s2jv::I32 = _c2Ar::I32;
      if (_s2jv::I32 >= 1) goto c2Bl; else goto c2AE;
  c2Bl:
      _c2Az::I32 = %MO_S_Lt_W32(_s2ju::I32, _s2jn::I32);
      _s2jy::I32 = _c2Az::I32;
      if (_s2jy::I32 >= 1) goto c2Bh; else goto c2AE;
  c2Bh:
      _s2jC::P32 = P32[(_s2jo::P32 + 12) + (_s2ju::I32 << 2)];
      _s2jC::P32 = _s2jC::P32;
      I32[(young<c2AH> + 4)] = c2AH;
      R1 = _s2jC::P32;
      if (R1 & 3 != 0) goto c2AH; else goto c2AI;
  c2AI:
      call (I32[R1])(R1) returns to c2AH, args: 4, res: 4, upd: 12;
  c2AH:
      _s2jD::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Bk; else goto c2Bj;
  c2Bk:
      HpAlloc = 12;
      goto c2Bi;
  c2Bi:
      R1 = _s2jD::P32;
      call stg_gc_unpt_r1(R1) returns to c2AH, args: 4, res: 4, upd: 12;
  c2Bj:
      _s2jE::F64 = F64[_s2jD::P32 + 3];
      _c2AM::F64 = %MO_F_Add_W64(_s2ji::F64, _s2jj::F64);
      _s2jG::F64 = _c2AM::F64;
      _c2AP::F64 = %MO_F_Add_W64(_s2jG::F64, 1.0 :: W64);
      _s2jH::F64 = _c2AP::F64;
      _c2AS::F64 = %MO_F_Add_W64(_s2ji::F64, _s2jj::F64);
      _s2jF::F64 = _c2AS::F64;
      _c2AV::F64 = %MO_F_Mul_W64(_s2jF::F64, _s2jH::F64);
      _s2jI::F64 = _c2AV::F64;
      _c2AY::F64 = %MO_F_Quot_W64(_s2jI::F64, 2.0 :: W64);
      _s2jJ::F64 = _c2AY::F64;
      _c2B1::F64 = %MO_F_Add_W64(_s2jJ::F64, _s2ji::F64);
      _s2jK::F64 = _c2B1::F64;
      _c2B4::F64 = %MO_F_Add_W64(_s2jK::F64, 1.0 :: W64);
      _s2jL::F64 = _c2B4::F64;
      _c2B7::F64 = %MO_F_Quot_W64(1.0 :: W64, _s2jL::F64);
      _s2jM::F64 = _c2B7::F64;
      _c2Ba::F64 = %MO_F_Mul_W64(_s2jM::F64, _s2jE::F64);
      _s2jN::F64 = _c2Ba::F64;
      _c2Bd::F64 = %MO_F_Add_W64(_s2jh::F64, _s2jN::F64);
      _s2jO::F64 = _c2Bd::F64;
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _s2jO::F64;
      _c2Bg::P32 = Hp - 7;
      R1 = _c2Bg::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2AE:
      I32[(old + 20)] = _s2ju::I32;
      I32[(old + 16)] = _s2jn::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2Ad:
      P32[(old + 24)] = _s2j0::P32;
      P32[(old + 20)] = _s2jl::P32;
      P32[(old + 16)] = _s2jm::P32;
      call poly_$w$j1_r2hA_info() args: 24, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2zz:
      _s2jP::P32 = R1;
      goto c2zu;
  c2zu:
      if (Sp - <highSp> < SpLim) goto c2zQ; else goto c2zR;
  c2zQ:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2zR:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s2iv::P32 = P32[R1 + 8];
      _s2iT::P32 = P32[R1 + 12];
      _s2j0::P32 = P32[R1 + 16];
      _s2jf::P32 = P32[R1 + 20];
      I32[(young<c2zw> + 4)] = c2zw;
      R1 = _s2jf::P32;
      if (_s2jf::P32 & 3 != 0) goto c2zw; else goto c2zx;
  c2zx:
      call (I32[_s2jf::P32])(R1) returns to c2zw, args: 4, res: 4, upd: 12;
  c2zw:
      _s2jg::P32 = R1;
      _s2jh::F64 = F64[R1 + 3];
      I32[(young<c2zC> + 4)] = c2zC;
      P32[(young<c2zC> + 8)] = _s2iT::P32;
      call GHC.Integer.Type.doubleFromInteger_info() returns to c2zC, args: 8, res: 4, upd: 12;
  c2zC:
      _s2ji::F64 = D1;
      I32[(young<c2zG> + 4)] = c2zG;
      P32[(young<c2zG> + 8)] = _s2j0::P32;
      call GHC.Integer.Type.doubleFromInteger_info() returns to c2zG, args: 8, res: 4, upd: 12;
  c2zG:
      _s2jj::F64 = D1;
      I32[(young<c2zK> + 4)] = c2zK;
      R1 = _s2iv::P32;
      if (_s2iv::P32 & 3 != 0) goto c2zK; else goto c2zL;
  c2zL:
      call (I32[_s2iv::P32])(R1) returns to c2zK, args: 4, res: 4, upd: 12;
  c2zK:
      _s2jk::P32 = R1;
      _s2jl::P32 = P32[R1 + 3];
      _s2jm::P32 = P32[R1 + 7];
      _s2jo::P32 = P32[R1 + 11];
      _s2jn::I32 = I32[R1 + 15];
      I32[(young<c2zP> + 4)] = c2zP;
      P32[(young<c2zP> + 12)] = _s2jl::P32;
      P32[(young<c2zP> + 8)] = _s2j0::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2zP, args: 12, res: 4, upd: 12;
  c2zP:
      _s2jp::I32 = R1;
      if (R1 >= 1) goto c2A6; else goto c2Ad;
  c2A6:
      I32[(young<c2A5> + 4)] = c2A5;
      P32[(young<c2A5> + 12)] = _s2j0::P32;
      P32[(young<c2A5> + 8)] = _s2jm::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2A5, args: 12, res: 4, upd: 12;
  c2A5:
      _s2jr::I32 = R1;
      if (R1 >= 1) goto c2Al; else goto c2Ad;
  c2Al:
      I32[(young<c2Ag> + 4)] = c2Ag;
      P32[(young<c2Ag> + 12)] = _s2j0::P32;
      P32[(young<c2Ag> + 8)] = _s2jl::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2Ag, args: 12, res: 4, upd: 12;
  c2Ag:
      _s2jt::P32 = R1;
      I32[(young<c2Ak> + 4)] = c2Ak;
      P32[(young<c2Ak> + 8)] = R1;
      call GHC.Integer.Type.integerToInt_info() returns to c2Ak, args: 8, res: 4, upd: 12;
  c2Ak:
      _s2ju::I32 = R1;
      _c2Ar::I32 = %MO_S_Le_W32(0, R1);
      _s2jv::I32 = _c2Ar::I32;
      if (_c2Ar::I32 >= 1) goto c2Bl; else goto c2AE;
  c2Bl:
      _c2Az::I32 = %MO_S_Lt_W32(R1, _s2jn::I32);
      _s2jy::I32 = _c2Az::I32;
      if (_c2Az::I32 >= 1) goto c2Bh; else goto c2AE;
  c2Bh:
      _s2jC::P32 = P32[(_s2jo::P32 + 12) + (R1 << 2)];
      _s2jC::P32 = _s2jC::P32;
      I32[(young<c2AH> + 4)] = c2AH;
      R1 = _s2jC::P32;
      if (_s2jC::P32 & 3 != 0) goto c2AH; else goto c2AI;
  c2AI:
      call (I32[_s2jC::P32])(R1) returns to c2AH, args: 4, res: 4, upd: 12;
  c2AH:
      _s2jD::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Bk; else goto c2Bj;
  c2Bk:
      HpAlloc = 12;
      goto c2Bi;
  c2Bi:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c2AH, args: 4, res: 4, upd: 12;
  c2Bj:
      _s2jE::F64 = F64[R1 + 3];
      _c2AM::F64 = %MO_F_Add_W64(_s2ji::F64, _s2jj::F64);
      _s2jG::F64 = _c2AM::F64;
      _c2AP::F64 = %MO_F_Add_W64(_c2AM::F64, 1.0 :: W64);
      _s2jH::F64 = _c2AP::F64;
      _c2AS::F64 = %MO_F_Add_W64(_s2ji::F64, _s2jj::F64);
      _s2jF::F64 = _c2AS::F64;
      _c2AV::F64 = %MO_F_Mul_W64(_c2AS::F64, _c2AP::F64);
      _s2jI::F64 = _c2AV::F64;
      _c2AY::F64 = %MO_F_Quot_W64(_c2AV::F64, 2.0 :: W64);
      _s2jJ::F64 = _c2AY::F64;
      _c2B1::F64 = %MO_F_Add_W64(_c2AY::F64, _s2ji::F64);
      _s2jK::F64 = _c2B1::F64;
      _c2B4::F64 = %MO_F_Add_W64(_c2B1::F64, 1.0 :: W64);
      _s2jL::F64 = _c2B4::F64;
      _c2B7::F64 = %MO_F_Quot_W64(1.0 :: W64, _c2B4::F64);
      _s2jM::F64 = _c2B7::F64;
      _c2Ba::F64 = %MO_F_Mul_W64(_c2B7::F64, _s2jE::F64);
      _s2jN::F64 = _c2Ba::F64;
      _c2Bd::F64 = %MO_F_Add_W64(_s2jh::F64, _c2Ba::F64);
      _s2jO::F64 = _c2Bd::F64;
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _c2Bd::F64;
      _c2Bg::P32 = Hp - 7;
      R1 = _c2Bg::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2AE:
      I32[(old + 20)] = R1;
      I32[(old + 16)] = _s2jn::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2Ad:
      P32[(old + 24)] = _s2j0::P32;
      P32[(old + 20)] = _s2jl::P32;
      P32[(old + 16)] = _s2jm::P32;
      call poly_$w$j1_r2hA_info() args: 24, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2By:
      _s2jR::P32 = R1;
      goto c2yr;
  c2yr:
      if (Sp - <highSp> < SpLim) goto c2Bz; else goto c2BA;
  c2Bz:
      R1 = _s2jR::P32;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2BA:
      _s2iv::P32 = P32[_s2jR::P32 + 3];
      _s2iE::I32 = I32[_s2jR::P32 + 7];
      I32[(young<c2yt> + 4)] = c2yt;
      R1 = _s2iE::I32;
      P32[(young<c2yt> + 8)] = Main.$ssum1_closure+1;
      call stg_newArray#(R1) returns to c2yt, args: 8, res: 4, upd: 4;
  c2yt:
      _s2iK::P32 = R1;
      _s2iM::P32 = lvl1_r2hs_closure;
      goto c2yy;
  c2yy:
      I32[(young<c2yA> + 4)] = c2yA;
      R1 = _s2iM::P32;
      if (R1 & 3 != 0) goto c2yA; else goto c2yB;
  c2yB:
      call (I32[R1])(R1) returns to c2yA, args: 4, res: 4, upd: 4;
  c2yA:
      _s2iO::P32 = R1;
      _c2Cs::P32 = _s2iO::P32 & 3;
      if (_c2Cs::P32 >= 2) goto c2BK; else goto c2BG;
  c2BK:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2BN; else goto c2BM;
  c2BN:
      HpAlloc = 12;
      goto c2BL;
  c2BM:
      _s2iT::P32 = P32[_s2iO::P32 + 2];
      _s2iU::P32 = P32[_s2iO::P32 + 6];
      I32[Hp - 8] = lvl14_s2iV_info;
      P32[Hp] = _s2iT::P32;
      _c2yG::P32 = Hp - 8;
      _s2iX::P32 = lvl_r2hr_closure;
      goto c2yQ;
  c2yQ:
      I32[(young<c2yS> + 4)] = c2yS;
      R1 = _s2iX::P32;
      if (R1 & 3 != 0) goto c2yS; else goto c2yT;
  c2yT:
      call (I32[R1])(R1) returns to c2yS, args: 4, res: 4, upd: 4;
  c2yS:
      _s2iZ::P32 = R1;
      _c2Co::P32 = _s2iZ::P32 & 3;
      if (_c2Co::P32 >= 2) goto c2BU; else goto c2BS;
  c2BU:
      _s2j0::P32 = P32[_s2iZ::P32 + 2];
      _s2j1::P32 = P32[_s2iZ::P32 + 6];
      I32[(young<c2yY> + 4)] = c2yY;
      P32[(young<c2yY> + 12)] = Main.main5_closure+1;
      P32[(young<c2yY> + 8)] = _s2iT::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2yY, args: 12, res: 4, upd: 4;
  c2yY:
      _s2j2::I32 = R1;
      if (_s2j2::I32 >= 1) goto c2BY; else goto c2C1;
  c2BY:
      I32[(young<c2z5> + 4)] = c2z5;
      P32[(young<c2z5> + 12)] = _s2iT::P32;
      P32[(young<c2z5> + 8)] = Main.main_n_closure+1;
      call GHC.Integer.Type.leInteger#_info() returns to c2z5, args: 12, res: 4, upd: 4;
  c2z5:
      _s2j4::I32 = R1;
      if (_s2j4::I32 >= 1) goto c2C2; else goto c2C1;
  c2C2:
      I32[(young<c2zc> + 4)] = c2zc;
      P32[(young<c2zc> + 8)] = _c2yG::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2zc, args: 8, res: 4, upd: 4;
  c2zc:
      _s2j6::I32 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c2C5; else goto c2C4;
  c2C5:
      HpAlloc = 24;
      goto c2C3;
  c2C3:
      R1 = _s2j6::I32;
      call stg_gc_unbx_r1(R1) returns to c2zc, args: 4, res: 4, upd: 4;
  c2C4:
      _c2zg::I32 = %MO_S_Le_W32(0, _s2j6::I32);
      _s2j7::I32 = _c2zg::I32;
      if (_s2j7::I32 >= 1) goto c2Cb; else goto c2C9;
  c2Cb:
      _c2zm::I32 = %MO_S_Lt_W32(_s2j6::I32, _s2iE::I32);
      _s2ja::I32 = _c2zm::I32;
      if (_s2ja::I32 >= 1) goto c2Ca; else goto c2C9;
  c2Ca:
      _s2jf::P32 = P32[(_s2iK::P32 + 12) + (_s2j6::I32 << 2)];
      _s2jf::P32 = _s2jf::P32;
      I32[Hp - 20] = sat_s2jP_info;
      P32[Hp - 12] = _s2iv::P32;
      P32[Hp - 8] = _s2iT::P32;
      P32[Hp - 4] = _s2j0::P32;
      P32[Hp] = _s2jf::P32;
      _c2zs::P32 = Hp - 20;
      P32[(_s2iK::P32 + 12) + (_s2j6::I32 << 2)] = _c2zs::P32;
      I32[_s2iK::P32] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_s2iK::P32 + 12) + (I32[_s2iK::P32 + 4] << 2) + (_s2j6::I32 >> 7)] = 1 :: W8;
      _s2iX::P32 = _s2j1::P32;
      goto c2yQ;
  c2C9:
      Hp = Hp - 24;
      I32[(old + 12)] = _s2j6::I32;
      I32[(old + 8)] = _s2iE::I32;
      call GHC.Arr.badSafeIndex1_info() args: 12, res: 0, upd: 4;
  c2C1:
      P32[(old + 8)] = _s2iT::P32;
      call poly_$w$j_r2hy_info() args: 8, res: 0, upd: 4;
  c2BS:
      _s2iM::P32 = _s2iU::P32;
      goto c2yy;
  c2BG:
      Hp = Hp + 20;
      if (Hp > HpLim) goto c2BJ; else goto c2BI;
  c2BJ:
      HpAlloc = 20;
      goto c2BL;
  c2BL:
      R1 = _s2iO::P32;
      call stg_gc_unpt_r1(R1) returns to c2yA, args: 4, res: 4, upd: 4;
  c2BI:
      I32[_s2iK::P32] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _s2iR::P32 = _s2iK::P32;
      _s2iR::P32 = _s2iR::P32;
      I32[Hp - 16] = GHC.Arr.Array_con_info;
      P32[Hp - 12] = Main.main5_closure+1;
      P32[Hp - 8] = Main.main_n_closure+1;
      P32[Hp - 4] = _s2iR::P32;
      I32[Hp] = _s2iE::I32;
      _c2BE::P32 = Hp - 15;
      R1 = _c2BE::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2By:
      _s2jR::P32 = R1;
      goto c2yr;
  c2yr:
      if (Sp - <highSp> < SpLim) goto c2Bz; else goto c2BA;
  c2Bz:
      R1 = R1;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2BA:
      _s2iv::P32 = P32[R1 + 3];
      _s2iE::I32 = I32[R1 + 7];
      I32[(young<c2yt> + 4)] = c2yt;
      R1 = _s2iE::I32;
      P32[(young<c2yt> + 8)] = Main.$ssum1_closure+1;
      call stg_newArray#(R1) returns to c2yt, args: 8, res: 4, upd: 4;
  c2yt:
      _s2iK::P32 = R1;
      _s2iM::P32 = lvl1_r2hs_closure;
      goto c2yy;
  c2yy:
      I32[(young<c2yA> + 4)] = c2yA;
      R1 = _s2iM::P32;
      if (_s2iM::P32 & 3 != 0) goto c2yA; else goto c2yB;
  c2yB:
      call (I32[R1])(R1) returns to c2yA, args: 4, res: 4, upd: 4;
  c2yA:
      _s2iO::P32 = R1;
      _c2Cs::P32 = R1 & 3;
      if (_c2Cs::P32 >= 2) goto c2BK; else goto c2BG;
  c2BK:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2BN; else goto c2BM;
  c2BN:
      HpAlloc = 12;
      goto c2BL;
  c2BM:
      _s2iT::P32 = P32[R1 + 2];
      _s2iU::P32 = P32[R1 + 6];
      I32[Hp - 8] = lvl14_s2iV_info;
      P32[Hp] = _s2iT::P32;
      _c2yG::P32 = Hp - 8;
      _s2iX::P32 = lvl_r2hr_closure;
      goto c2yQ;
  c2yQ:
      I32[(young<c2yS> + 4)] = c2yS;
      R1 = _s2iX::P32;
      if (_s2iX::P32 & 3 != 0) goto c2yS; else goto c2yT;
  c2yT:
      call (I32[R1])(R1) returns to c2yS, args: 4, res: 4, upd: 4;
  c2yS:
      _s2iZ::P32 = R1;
      _c2Co::P32 = R1 & 3;
      if (_c2Co::P32 >= 2) goto c2BU; else goto c2BS;
  c2BU:
      _s2j0::P32 = P32[R1 + 2];
      _s2j1::P32 = P32[R1 + 6];
      I32[(young<c2yY> + 4)] = c2yY;
      P32[(young<c2yY> + 12)] = Main.main5_closure+1;
      P32[(young<c2yY> + 8)] = _s2iT::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2yY, args: 12, res: 4, upd: 4;
  c2yY:
      _s2j2::I32 = R1;
      if (R1 >= 1) goto c2BY; else goto c2C1;
  c2BY:
      I32[(young<c2z5> + 4)] = c2z5;
      P32[(young<c2z5> + 12)] = _s2iT::P32;
      P32[(young<c2z5> + 8)] = Main.main_n_closure+1;
      call GHC.Integer.Type.leInteger#_info() returns to c2z5, args: 12, res: 4, upd: 4;
  c2z5:
      _s2j4::I32 = R1;
      if (R1 >= 1) goto c2C2; else goto c2C1;
  c2C2:
      I32[(young<c2zc> + 4)] = c2zc;
      P32[(young<c2zc> + 8)] = _c2yG::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2zc, args: 8, res: 4, upd: 4;
  c2zc:
      _s2j6::I32 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c2C5; else goto c2C4;
  c2C5:
      HpAlloc = 24;
      goto c2C3;
  c2C3:
      R1 = R1;
      call stg_gc_unbx_r1(R1) returns to c2zc, args: 4, res: 4, upd: 4;
  c2C4:
      _c2zg::I32 = %MO_S_Le_W32(0, R1);
      _s2j7::I32 = _c2zg::I32;
      if (_c2zg::I32 >= 1) goto c2Cb; else goto c2C9;
  c2Cb:
      _c2zm::I32 = %MO_S_Lt_W32(R1, _s2iE::I32);
      _s2ja::I32 = _c2zm::I32;
      if (_c2zm::I32 >= 1) goto c2Ca; else goto c2C9;
  c2Ca:
      _s2jf::P32 = P32[(_s2iK::P32 + 12) + (R1 << 2)];
      _s2jf::P32 = _s2jf::P32;
      I32[Hp - 20] = sat_s2jP_info;
      P32[Hp - 12] = _s2iv::P32;
      P32[Hp - 8] = _s2iT::P32;
      P32[Hp - 4] = _s2j0::P32;
      P32[Hp] = _s2jf::P32;
      _c2zs::P32 = Hp - 20;
      P32[(_s2iK::P32 + 12) + (_s2j6::I32 << 2)] = _c2zs::P32;
      I32[_s2iK::P32] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_s2iK::P32 + 12) + (I32[_s2iK::P32 + 4] << 2) + (_s2j6::I32 >> 7)] = 1 :: W8;
      _s2iX::P32 = _s2j1::P32;
      goto c2yQ;
  c2C9:
      Hp = Hp - 24;
      I32[(old + 12)] = R1;
      I32[(old + 8)] = _s2iE::I32;
      call GHC.Arr.badSafeIndex1_info() args: 12, res: 0, upd: 4;
  c2C1:
      P32[(old + 8)] = _s2iT::P32;
      call poly_$w$j_r2hy_info() args: 8, res: 0, upd: 4;
  c2BS:
      _s2iM::P32 = _s2iU::P32;
      goto c2yy;
  c2BG:
      Hp = Hp + 20;
      if (Hp > HpLim) goto c2BJ; else goto c2BI;
  c2BJ:
      HpAlloc = 20;
      goto c2BL;
  c2BL:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c2yA, args: 4, res: 4, upd: 4;
  c2BI:
      I32[_s2iK::P32] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _s2iR::P32 = _s2iK::P32;
      _s2iR::P32 = _s2iK::P32;
      I32[Hp - 16] = GHC.Arr.Array_con_info;
      P32[Hp - 12] = Main.main5_closure+1;
      P32[Hp - 8] = Main.main_n_closure+1;
      P32[Hp - 4] = _s2iK::P32;
      I32[Hp] = _s2iE::I32;
      _c2BE::P32 = Hp - 15;
      R1 = _c2BE::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2Cy:
      _s2iD::P32 = R1;
      goto c2ye;
  c2ye:
      if (Sp - <highSp> < SpLim) goto c2Cz; else goto c2CA;
  c2Cz:
      R1 = _s2iD::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2CA:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2iD::P32;
      _s2iv::P32 = P32[_s2iD::P32 + 8];
      I32[(young<c2yg> + 4)] = c2yg;
      P32[(young<c2yg> + 12)] = Main.main5_closure+1;
      P32[(young<c2yg> + 8)] = Main.main_n_closure+1;
      call GHC.Arr.$w$crangeSize5_info() returns to c2yg, args: 12, res: 4, upd: 12;
  c2yg:
      _s2iE::I32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2CD; else goto c2CC;
  c2CD:
      HpAlloc = 12;
      goto c2CB;
  c2CB:
      R1 = _s2iE::I32;
      call stg_gc_unbx_r1(R1) returns to c2yg, args: 4, res: 4, upd: 12;
  c2CC:
      _c2yk::I32 = %MO_S_Lt_W32(_s2iE::I32, 0);
      _s2iF::I32 = _c2yk::I32;
      if (_s2iF::I32 >= 1) goto c2CG; else goto c2CF;
  c2CG:
      Hp = Hp - 12;
      R1 = GHC.Arr.negRange_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
  c2CF:
      I32[Hp - 8] = sat_s2jR_info;
      P32[Hp - 4] = _s2iv::P32;
      I32[Hp] = _s2iE::I32;
      _c2yp::P32 = Hp - 7;
      P32[(old + 16)] = _c2yp::P32;
      call GHC.ST.runSTRep_info() args: 16, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2Cy:
      _s2iD::P32 = R1;
      goto c2ye;
  c2ye:
      if (Sp - <highSp> < SpLim) goto c2Cz; else goto c2CA;
  c2Cz:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2CA:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s2iv::P32 = P32[R1 + 8];
      I32[(young<c2yg> + 4)] = c2yg;
      P32[(young<c2yg> + 12)] = Main.main5_closure+1;
      P32[(young<c2yg> + 8)] = Main.main_n_closure+1;
      call GHC.Arr.$w$crangeSize5_info() returns to c2yg, args: 12, res: 4, upd: 12;
  c2yg:
      _s2iE::I32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2CD; else goto c2CC;
  c2CD:
      HpAlloc = 12;
      goto c2CB;
  c2CB:
      R1 = R1;
      call stg_gc_unbx_r1(R1) returns to c2yg, args: 4, res: 4, upd: 12;
  c2CC:
      _c2yk::I32 = %MO_S_Lt_W32(R1, 0);
      _s2iF::I32 = _c2yk::I32;
      if (_c2yk::I32 >= 1) goto c2CG; else goto c2CF;
  c2CG:
      Hp = Hp - 12;
      R1 = GHC.Arr.negRange_closure;
      call (I32[GHC.Arr.negRange_closure])(R1) args: 12, res: 0, upd: 12;
  c2CF:
      I32[Hp - 8] = sat_s2jR_info;
      P32[Hp - 4] = _s2iv::P32;
      I32[Hp] = R1;
      _c2yp::P32 = Hp - 7;
      P32[(old + 16)] = _c2yp::P32;
      call GHC.ST.runSTRep_info() args: 16, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2CZ:
      _s2k3::P32 = R1;
      goto c2CX;
  c2CX:
      if (Sp - <highSp> < SpLim) goto c2D0; else goto c2D1;
  c2D0:
      R1 = _s2k3::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2D1:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2k3::P32;
      _s2k1::P32 = P32[_s2k3::P32 + 8];
      P32[(old + 20)] = _s2k1::P32;
      P32[(old + 16)] = Main.main5_closure+1;
      call GHC.Integer.Type.minusInteger_info() args: 20, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2CZ:
      _s2k3::P32 = R1;
      goto c2CX;
  c2CX:
      if (Sp - <highSp> < SpLim) goto c2D0; else goto c2D1;
  c2D0:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2D1:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s2k1::P32 = P32[R1 + 8];
      P32[(old + 20)] = _s2k1::P32;
      P32[(old + 16)] = Main.main5_closure+1;
      call GHC.Integer.Type.minusInteger_info() args: 20, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2DO:
      _s2kX::P32 = R1;
      goto c2DJ;
  c2DJ:
      if (Sp - <highSp> < SpLim) goto c2E5; else goto c2E6;
  c2E5:
      R1 = _s2kX::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2E6:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2kX::P32;
      _s2iD::P32 = P32[_s2kX::P32 + 8];
      _s2k1::P32 = P32[_s2kX::P32 + 12];
      _s2k8::P32 = P32[_s2kX::P32 + 16];
      _s2kn::P32 = P32[_s2kX::P32 + 20];
      I32[(young<c2DL> + 4)] = c2DL;
      R1 = _s2kn::P32;
      if (R1 & 3 != 0) goto c2DL; else goto c2DM;
  c2DM:
      call (I32[R1])(R1) returns to c2DL, args: 4, res: 4, upd: 12;
  c2DL:
      _s2ko::P32 = R1;
      _s2kp::F64 = F64[_s2ko::P32 + 3];
      I32[(young<c2DR> + 4)] = c2DR;
      P32[(young<c2DR> + 8)] = _s2k8::P32;
      call GHC.Integer.Type.doubleFromInteger_info() returns to c2DR, args: 8, res: 4, upd: 12;
  c2DR:
      _s2kq::F64 = D1;
      I32[(young<c2DV> + 4)] = c2DV;
      P32[(young<c2DV> + 8)] = _s2k1::P32;
      call GHC.Integer.Type.doubleFromInteger_info() returns to c2DV, args: 8, res: 4, upd: 12;
  c2DV:
      _s2kr::F64 = D1;
      I32[(young<c2DZ> + 4)] = c2DZ;
      R1 = _s2iD::P32;
      if (R1 & 3 != 0) goto c2DZ; else goto c2E0;
  c2E0:
      call (I32[R1])(R1) returns to c2DZ, args: 4, res: 4, upd: 12;
  c2DZ:
      _s2ks::P32 = R1;
      _s2kt::P32 = P32[_s2ks::P32 + 3];
      _s2ku::P32 = P32[_s2ks::P32 + 7];
      _s2kw::P32 = P32[_s2ks::P32 + 11];
      _s2kv::I32 = I32[_s2ks::P32 + 15];
      I32[(young<c2E4> + 4)] = c2E4;
      P32[(young<c2E4> + 12)] = _s2kt::P32;
      P32[(young<c2E4> + 8)] = _s2k8::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2E4, args: 12, res: 4, upd: 12;
  c2E4:
      _s2kx::I32 = R1;
      if (_s2kx::I32 >= 1) goto c2El; else goto c2Es;
  c2El:
      I32[(young<c2Ek> + 4)] = c2Ek;
      P32[(young<c2Ek> + 12)] = _s2k8::P32;
      P32[(young<c2Ek> + 8)] = _s2ku::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Ek, args: 12, res: 4, upd: 12;
  c2Ek:
      _s2kz::I32 = R1;
      if (_s2kz::I32 >= 1) goto c2EA; else goto c2Es;
  c2EA:
      I32[(young<c2Ev> + 4)] = c2Ev;
      P32[(young<c2Ev> + 12)] = _s2k8::P32;
      P32[(young<c2Ev> + 8)] = _s2kt::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2Ev, args: 12, res: 4, upd: 12;
  c2Ev:
      _s2kB::P32 = R1;
      I32[(young<c2Ez> + 4)] = c2Ez;
      P32[(young<c2Ez> + 8)] = _s2kB::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2Ez, args: 8, res: 4, upd: 12;
  c2Ez:
      _s2kC::I32 = R1;
      _c2EG::I32 = %MO_S_Le_W32(0, _s2kC::I32);
      _s2kD::I32 = _c2EG::I32;
      if (_s2kD::I32 >= 1) goto c2FA; else goto c2ET;
  c2FA:
      _c2EO::I32 = %MO_S_Lt_W32(_s2kC::I32, _s2kv::I32);
      _s2kG::I32 = _c2EO::I32;
      if (_s2kG::I32 >= 1) goto c2Fw; else goto c2ET;
  c2Fw:
      _s2kK::P32 = P32[(_s2kw::P32 + 12) + (_s2kC::I32 << 2)];
      _s2kK::P32 = _s2kK::P32;
      I32[(young<c2EW> + 4)] = c2EW;
      R1 = _s2kK::P32;
      if (R1 & 3 != 0) goto c2EW; else goto c2EX;
  c2EX:
      call (I32[R1])(R1) returns to c2EW, args: 4, res: 4, upd: 12;
  c2EW:
      _s2kL::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Fz; else goto c2Fy;
  c2Fz:
      HpAlloc = 12;
      goto c2Fx;
  c2Fx:
      R1 = _s2kL::P32;
      call stg_gc_unpt_r1(R1) returns to c2EW, args: 4, res: 4, upd: 12;
  c2Fy:
      _s2kM::F64 = F64[_s2kL::P32 + 3];
      _c2F1::F64 = %MO_F_Add_W64(_s2kq::F64, _s2kr::F64);
      _s2kO::F64 = _c2F1::F64;
      _c2F4::F64 = %MO_F_Add_W64(_s2kO::F64, 1.0 :: W64);
      _s2kP::F64 = _c2F4::F64;
      _c2F7::F64 = %MO_F_Add_W64(_s2kq::F64, _s2kr::F64);
      _s2kN::F64 = _c2F7::F64;
      _c2Fa::F64 = %MO_F_Mul_W64(_s2kN::F64, _s2kP::F64);
      _s2kQ::F64 = _c2Fa::F64;
      _c2Fd::F64 = %MO_F_Quot_W64(_s2kQ::F64, 2.0 :: W64);
      _s2kR::F64 = _c2Fd::F64;
      _c2Fg::F64 = %MO_F_Add_W64(_s2kR::F64, _s2kq::F64);
      _s2kS::F64 = _c2Fg::F64;
      _c2Fj::F64 = %MO_F_Add_W64(_s2kS::F64, 1.0 :: W64);
      _s2kT::F64 = _c2Fj::F64;
      _c2Fm::F64 = %MO_F_Quot_W64(1.0 :: W64, _s2kT::F64);
      _s2kU::F64 = _c2Fm::F64;
      _c2Fp::F64 = %MO_F_Mul_W64(_s2kU::F64, _s2kM::F64);
      _s2kV::F64 = _c2Fp::F64;
      _c2Fs::F64 = %MO_F_Add_W64(_s2kp::F64, _s2kV::F64);
      _s2kW::F64 = _c2Fs::F64;
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _s2kW::F64;
      _c2Fv::P32 = Hp - 7;
      R1 = _c2Fv::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2ET:
      I32[(old + 20)] = _s2kC::I32;
      I32[(old + 16)] = _s2kv::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2Es:
      P32[(old + 24)] = _s2k8::P32;
      P32[(old + 20)] = _s2kt::P32;
      P32[(old + 16)] = _s2ku::P32;
      call poly_$w$j3_r2hF_info() args: 24, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2DO:
      _s2kX::P32 = R1;
      goto c2DJ;
  c2DJ:
      if (Sp - <highSp> < SpLim) goto c2E5; else goto c2E6;
  c2E5:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2E6:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s2iD::P32 = P32[R1 + 8];
      _s2k1::P32 = P32[R1 + 12];
      _s2k8::P32 = P32[R1 + 16];
      _s2kn::P32 = P32[R1 + 20];
      I32[(young<c2DL> + 4)] = c2DL;
      R1 = _s2kn::P32;
      if (_s2kn::P32 & 3 != 0) goto c2DL; else goto c2DM;
  c2DM:
      call (I32[_s2kn::P32])(R1) returns to c2DL, args: 4, res: 4, upd: 12;
  c2DL:
      _s2ko::P32 = R1;
      _s2kp::F64 = F64[R1 + 3];
      I32[(young<c2DR> + 4)] = c2DR;
      P32[(young<c2DR> + 8)] = _s2k8::P32;
      call GHC.Integer.Type.doubleFromInteger_info() returns to c2DR, args: 8, res: 4, upd: 12;
  c2DR:
      _s2kq::F64 = D1;
      I32[(young<c2DV> + 4)] = c2DV;
      P32[(young<c2DV> + 8)] = _s2k1::P32;
      call GHC.Integer.Type.doubleFromInteger_info() returns to c2DV, args: 8, res: 4, upd: 12;
  c2DV:
      _s2kr::F64 = D1;
      I32[(young<c2DZ> + 4)] = c2DZ;
      R1 = _s2iD::P32;
      if (_s2iD::P32 & 3 != 0) goto c2DZ; else goto c2E0;
  c2E0:
      call (I32[_s2iD::P32])(R1) returns to c2DZ, args: 4, res: 4, upd: 12;
  c2DZ:
      _s2ks::P32 = R1;
      _s2kt::P32 = P32[R1 + 3];
      _s2ku::P32 = P32[R1 + 7];
      _s2kw::P32 = P32[R1 + 11];
      _s2kv::I32 = I32[R1 + 15];
      I32[(young<c2E4> + 4)] = c2E4;
      P32[(young<c2E4> + 12)] = _s2kt::P32;
      P32[(young<c2E4> + 8)] = _s2k8::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2E4, args: 12, res: 4, upd: 12;
  c2E4:
      _s2kx::I32 = R1;
      if (R1 >= 1) goto c2El; else goto c2Es;
  c2El:
      I32[(young<c2Ek> + 4)] = c2Ek;
      P32[(young<c2Ek> + 12)] = _s2k8::P32;
      P32[(young<c2Ek> + 8)] = _s2ku::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Ek, args: 12, res: 4, upd: 12;
  c2Ek:
      _s2kz::I32 = R1;
      if (R1 >= 1) goto c2EA; else goto c2Es;
  c2EA:
      I32[(young<c2Ev> + 4)] = c2Ev;
      P32[(young<c2Ev> + 12)] = _s2k8::P32;
      P32[(young<c2Ev> + 8)] = _s2kt::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2Ev, args: 12, res: 4, upd: 12;
  c2Ev:
      _s2kB::P32 = R1;
      I32[(young<c2Ez> + 4)] = c2Ez;
      P32[(young<c2Ez> + 8)] = R1;
      call GHC.Integer.Type.integerToInt_info() returns to c2Ez, args: 8, res: 4, upd: 12;
  c2Ez:
      _s2kC::I32 = R1;
      _c2EG::I32 = %MO_S_Le_W32(0, R1);
      _s2kD::I32 = _c2EG::I32;
      if (_c2EG::I32 >= 1) goto c2FA; else goto c2ET;
  c2FA:
      _c2EO::I32 = %MO_S_Lt_W32(R1, _s2kv::I32);
      _s2kG::I32 = _c2EO::I32;
      if (_c2EO::I32 >= 1) goto c2Fw; else goto c2ET;
  c2Fw:
      _s2kK::P32 = P32[(_s2kw::P32 + 12) + (R1 << 2)];
      _s2kK::P32 = _s2kK::P32;
      I32[(young<c2EW> + 4)] = c2EW;
      R1 = _s2kK::P32;
      if (_s2kK::P32 & 3 != 0) goto c2EW; else goto c2EX;
  c2EX:
      call (I32[_s2kK::P32])(R1) returns to c2EW, args: 4, res: 4, upd: 12;
  c2EW:
      _s2kL::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Fz; else goto c2Fy;
  c2Fz:
      HpAlloc = 12;
      goto c2Fx;
  c2Fx:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c2EW, args: 4, res: 4, upd: 12;
  c2Fy:
      _s2kM::F64 = F64[R1 + 3];
      _c2F1::F64 = %MO_F_Add_W64(_s2kq::F64, _s2kr::F64);
      _s2kO::F64 = _c2F1::F64;
      _c2F4::F64 = %MO_F_Add_W64(_c2F1::F64, 1.0 :: W64);
      _s2kP::F64 = _c2F4::F64;
      _c2F7::F64 = %MO_F_Add_W64(_s2kq::F64, _s2kr::F64);
      _s2kN::F64 = _c2F7::F64;
      _c2Fa::F64 = %MO_F_Mul_W64(_c2F7::F64, _c2F4::F64);
      _s2kQ::F64 = _c2Fa::F64;
      _c2Fd::F64 = %MO_F_Quot_W64(_c2Fa::F64, 2.0 :: W64);
      _s2kR::F64 = _c2Fd::F64;
      _c2Fg::F64 = %MO_F_Add_W64(_c2Fd::F64, _s2kq::F64);
      _s2kS::F64 = _c2Fg::F64;
      _c2Fj::F64 = %MO_F_Add_W64(_c2Fg::F64, 1.0 :: W64);
      _s2kT::F64 = _c2Fj::F64;
      _c2Fm::F64 = %MO_F_Quot_W64(1.0 :: W64, _c2Fj::F64);
      _s2kU::F64 = _c2Fm::F64;
      _c2Fp::F64 = %MO_F_Mul_W64(_c2Fm::F64, _s2kM::F64);
      _s2kV::F64 = _c2Fp::F64;
      _c2Fs::F64 = %MO_F_Add_W64(_s2kp::F64, _c2Fp::F64);
      _s2kW::F64 = _c2Fs::F64;
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _c2Fs::F64;
      _c2Fv::P32 = Hp - 7;
      R1 = _c2Fv::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2ET:
      I32[(old + 20)] = R1;
      I32[(old + 16)] = _s2kv::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2Es:
      P32[(old + 24)] = _s2k8::P32;
      P32[(old + 20)] = _s2kt::P32;
      P32[(old + 16)] = _s2ku::P32;
      call poly_$w$j3_r2hF_info() args: 24, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2FN:
      _s2kZ::P32 = R1;
      goto c2y8;
  c2y8:
      if (Sp - <highSp> < SpLim) goto c2FO; else goto c2FP;
  c2FO:
      R1 = _s2kZ::P32;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2FP:
      _s2iv::P32 = P32[_s2kZ::P32 + 3];
      _s2iw::I32 = I32[_s2kZ::P32 + 7];
      I32[(young<c2ya> + 4)] = c2ya;
      R1 = _s2iw::I32;
      P32[(young<c2ya> + 8)] = Main.$ssum1_closure+1;
      call stg_newArray#(R1) returns to c2ya, args: 8, res: 4, upd: 4;
  c2ya:
      _s2iC::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2FS; else goto c2FR;
  c2FS:
      HpAlloc = 12;
      goto c2FQ;
  c2FQ:
      R1 = _s2iC::P32;
      call stg_gc_unpt_r1(R1) returns to c2ya, args: 4, res: 4, upd: 4;
  c2FR:
      I32[Hp - 8] = u2_s2iD_info;
      P32[Hp] = _s2iv::P32;
      _c2yc::P32 = Hp - 8;
      _s2jU::P32 = lvl3_r2hu_closure;
      goto c2CN;
  c2CN:
      I32[(young<c2CP> + 4)] = c2CP;
      R1 = _s2jU::P32;
      if (R1 & 3 != 0) goto c2CP; else goto c2CQ;
  c2CQ:
      call (I32[R1])(R1) returns to c2CP, args: 4, res: 4, upd: 4;
  c2CP:
      _s2jW::P32 = R1;
      _c2GJ::P32 = _s2jW::P32 & 3;
      if (_c2GJ::P32 >= 2) goto c2G1; else goto c2FX;
  c2G1:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2G4; else goto c2G3;
  c2G4:
      HpAlloc = 12;
      goto c2G2;
  c2G3:
      _s2k1::P32 = P32[_s2jW::P32 + 2];
      _s2k2::P32 = P32[_s2jW::P32 + 6];
      I32[Hp - 8] = lvl14_s2k3_info;
      P32[Hp] = _s2k1::P32;
      _c2CV::P32 = Hp - 8;
      _s2k5::P32 = lvl2_r2ht_closure;
      goto c2D5;
  c2D5:
      I32[(young<c2D7> + 4)] = c2D7;
      R1 = _s2k5::P32;
      if (R1 & 3 != 0) goto c2D7; else goto c2D8;
  c2D8:
      call (I32[R1])(R1) returns to c2D7, args: 4, res: 4, upd: 4;
  c2D7:
      _s2k7::P32 = R1;
      _c2GF::P32 = _s2k7::P32 & 3;
      if (_c2GF::P32 >= 2) goto c2Gb; else goto c2G9;
  c2Gb:
      _s2k8::P32 = P32[_s2k7::P32 + 2];
      _s2k9::P32 = P32[_s2k7::P32 + 6];
      I32[(young<c2Dd> + 4)] = c2Dd;
      P32[(young<c2Dd> + 12)] = Main.main5_closure+1;
      P32[(young<c2Dd> + 8)] = _s2k1::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Dd, args: 12, res: 4, upd: 4;
  c2Dd:
      _s2ka::I32 = R1;
      if (_s2ka::I32 >= 1) goto c2Gf; else goto c2Gi;
  c2Gf:
      I32[(young<c2Dk> + 4)] = c2Dk;
      P32[(young<c2Dk> + 12)] = _s2k1::P32;
      P32[(young<c2Dk> + 8)] = Main.main_n_closure+1;
      call GHC.Integer.Type.leInteger#_info() returns to c2Dk, args: 12, res: 4, upd: 4;
  c2Dk:
      _s2kc::I32 = R1;
      if (_s2kc::I32 >= 1) goto c2Gj; else goto c2Gi;
  c2Gj:
      I32[(young<c2Dr> + 4)] = c2Dr;
      P32[(young<c2Dr> + 8)] = _c2CV::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2Dr, args: 8, res: 4, upd: 4;
  c2Dr:
      _s2ke::I32 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c2Gm; else goto c2Gl;
  c2Gm:
      HpAlloc = 24;
      goto c2Gk;
  c2Gk:
      R1 = _s2ke::I32;
      call stg_gc_unbx_r1(R1) returns to c2Dr, args: 4, res: 4, upd: 4;
  c2Gl:
      _c2Dv::I32 = %MO_S_Le_W32(0, _s2ke::I32);
      _s2kf::I32 = _c2Dv::I32;
      if (_s2kf::I32 >= 1) goto c2Gs; else goto c2Gq;
  c2Gs:
      _c2DB::I32 = %MO_S_Lt_W32(_s2ke::I32, _s2iw::I32);
      _s2ki::I32 = _c2DB::I32;
      if (_s2ki::I32 >= 1) goto c2Gr; else goto c2Gq;
  c2Gr:
      _s2kn::P32 = P32[(_s2iC::P32 + 12) + (_s2ke::I32 << 2)];
      _s2kn::P32 = _s2kn::P32;
      I32[Hp - 20] = sat_s2kX_info;
      P32[Hp - 12] = _c2yc::P32;
      P32[Hp - 8] = _s2k1::P32;
      P32[Hp - 4] = _s2k8::P32;
      P32[Hp] = _s2kn::P32;
      _c2DH::P32 = Hp - 20;
      P32[(_s2iC::P32 + 12) + (_s2ke::I32 << 2)] = _c2DH::P32;
      I32[_s2iC::P32] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_s2iC::P32 + 12) + (I32[_s2iC::P32 + 4] << 2) + (_s2ke::I32 >> 7)] = 1 :: W8;
      _s2k5::P32 = _s2k9::P32;
      goto c2D5;
  c2Gq:
      Hp = Hp - 24;
      I32[(old + 12)] = _s2ke::I32;
      I32[(old + 8)] = _s2iw::I32;
      call GHC.Arr.badSafeIndex1_info() args: 12, res: 0, upd: 4;
  c2Gi:
      P32[(old + 8)] = _s2k1::P32;
      call poly_$w$j2_r2hD_info() args: 8, res: 0, upd: 4;
  c2G9:
      _s2jU::P32 = _s2k2::P32;
      goto c2CN;
  c2FX:
      Hp = Hp + 20;
      if (Hp > HpLim) goto c2G0; else goto c2FZ;
  c2G0:
      HpAlloc = 20;
      goto c2G2;
  c2G2:
      R1 = _s2jW::P32;
      call stg_gc_unpt_r1(R1) returns to c2CP, args: 4, res: 4, upd: 4;
  c2FZ:
      I32[_s2iC::P32] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _s2jZ::P32 = _s2iC::P32;
      _s2jZ::P32 = _s2jZ::P32;
      I32[Hp - 16] = GHC.Arr.Array_con_info;
      P32[Hp - 12] = Main.main5_closure+1;
      P32[Hp - 8] = Main.main_n_closure+1;
      P32[Hp - 4] = _s2jZ::P32;
      I32[Hp] = _s2iw::I32;
      _c2FV::P32 = Hp - 15;
      R1 = _c2FV::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2FN:
      _s2kZ::P32 = R1;
      goto c2y8;
  c2y8:
      if (Sp - <highSp> < SpLim) goto c2FO; else goto c2FP;
  c2FO:
      R1 = R1;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2FP:
      _s2iv::P32 = P32[R1 + 3];
      _s2iw::I32 = I32[R1 + 7];
      I32[(young<c2ya> + 4)] = c2ya;
      R1 = _s2iw::I32;
      P32[(young<c2ya> + 8)] = Main.$ssum1_closure+1;
      call stg_newArray#(R1) returns to c2ya, args: 8, res: 4, upd: 4;
  c2ya:
      _s2iC::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2FS; else goto c2FR;
  c2FS:
      HpAlloc = 12;
      goto c2FQ;
  c2FQ:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c2ya, args: 4, res: 4, upd: 4;
  c2FR:
      I32[Hp - 8] = u2_s2iD_info;
      P32[Hp] = _s2iv::P32;
      _c2yc::P32 = Hp - 8;
      _s2jU::P32 = lvl3_r2hu_closure;
      goto c2CN;
  c2CN:
      I32[(young<c2CP> + 4)] = c2CP;
      R1 = _s2jU::P32;
      if (_s2jU::P32 & 3 != 0) goto c2CP; else goto c2CQ;
  c2CQ:
      call (I32[R1])(R1) returns to c2CP, args: 4, res: 4, upd: 4;
  c2CP:
      _s2jW::P32 = R1;
      _c2GJ::P32 = R1 & 3;
      if (_c2GJ::P32 >= 2) goto c2G1; else goto c2FX;
  c2G1:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2G4; else goto c2G3;
  c2G4:
      HpAlloc = 12;
      goto c2G2;
  c2G3:
      _s2k1::P32 = P32[R1 + 2];
      _s2k2::P32 = P32[R1 + 6];
      I32[Hp - 8] = lvl14_s2k3_info;
      P32[Hp] = _s2k1::P32;
      _c2CV::P32 = Hp - 8;
      _s2k5::P32 = lvl2_r2ht_closure;
      goto c2D5;
  c2D5:
      I32[(young<c2D7> + 4)] = c2D7;
      R1 = _s2k5::P32;
      if (_s2k5::P32 & 3 != 0) goto c2D7; else goto c2D8;
  c2D8:
      call (I32[R1])(R1) returns to c2D7, args: 4, res: 4, upd: 4;
  c2D7:
      _s2k7::P32 = R1;
      _c2GF::P32 = R1 & 3;
      if (_c2GF::P32 >= 2) goto c2Gb; else goto c2G9;
  c2Gb:
      _s2k8::P32 = P32[R1 + 2];
      _s2k9::P32 = P32[R1 + 6];
      I32[(young<c2Dd> + 4)] = c2Dd;
      P32[(young<c2Dd> + 12)] = Main.main5_closure+1;
      P32[(young<c2Dd> + 8)] = _s2k1::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Dd, args: 12, res: 4, upd: 4;
  c2Dd:
      _s2ka::I32 = R1;
      if (R1 >= 1) goto c2Gf; else goto c2Gi;
  c2Gf:
      I32[(young<c2Dk> + 4)] = c2Dk;
      P32[(young<c2Dk> + 12)] = _s2k1::P32;
      P32[(young<c2Dk> + 8)] = Main.main_n_closure+1;
      call GHC.Integer.Type.leInteger#_info() returns to c2Dk, args: 12, res: 4, upd: 4;
  c2Dk:
      _s2kc::I32 = R1;
      if (R1 >= 1) goto c2Gj; else goto c2Gi;
  c2Gj:
      I32[(young<c2Dr> + 4)] = c2Dr;
      P32[(young<c2Dr> + 8)] = _c2CV::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2Dr, args: 8, res: 4, upd: 4;
  c2Dr:
      _s2ke::I32 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c2Gm; else goto c2Gl;
  c2Gm:
      HpAlloc = 24;
      goto c2Gk;
  c2Gk:
      R1 = R1;
      call stg_gc_unbx_r1(R1) returns to c2Dr, args: 4, res: 4, upd: 4;
  c2Gl:
      _c2Dv::I32 = %MO_S_Le_W32(0, R1);
      _s2kf::I32 = _c2Dv::I32;
      if (_c2Dv::I32 >= 1) goto c2Gs; else goto c2Gq;
  c2Gs:
      _c2DB::I32 = %MO_S_Lt_W32(R1, _s2iw::I32);
      _s2ki::I32 = _c2DB::I32;
      if (_c2DB::I32 >= 1) goto c2Gr; else goto c2Gq;
  c2Gr:
      _s2kn::P32 = P32[(_s2iC::P32 + 12) + (R1 << 2)];
      _s2kn::P32 = _s2kn::P32;
      I32[Hp - 20] = sat_s2kX_info;
      P32[Hp - 12] = _c2yc::P32;
      P32[Hp - 8] = _s2k1::P32;
      P32[Hp - 4] = _s2k8::P32;
      P32[Hp] = _s2kn::P32;
      _c2DH::P32 = Hp - 20;
      P32[(_s2iC::P32 + 12) + (_s2ke::I32 << 2)] = _c2DH::P32;
      I32[_s2iC::P32] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_s2iC::P32 + 12) + (I32[_s2iC::P32 + 4] << 2) + (_s2ke::I32 >> 7)] = 1 :: W8;
      _s2k5::P32 = _s2k9::P32;
      goto c2D5;
  c2Gq:
      Hp = Hp - 24;
      I32[(old + 12)] = R1;
      I32[(old + 8)] = _s2iw::I32;
      call GHC.Arr.badSafeIndex1_info() args: 12, res: 0, upd: 4;
  c2Gi:
      P32[(old + 8)] = _s2k1::P32;
      call poly_$w$j2_r2hD_info() args: 8, res: 0, upd: 4;
  c2G9:
      _s2jU::P32 = _s2k2::P32;
      goto c2CN;
  c2FX:
      Hp = Hp + 20;
      if (Hp > HpLim) goto c2G0; else goto c2FZ;
  c2G0:
      HpAlloc = 20;
      goto c2G2;
  c2G2:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c2CP, args: 4, res: 4, upd: 4;
  c2FZ:
      I32[_s2iC::P32] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _s2jZ::P32 = _s2iC::P32;
      _s2jZ::P32 = _s2iC::P32;
      I32[Hp - 16] = GHC.Arr.Array_con_info;
      P32[Hp - 12] = Main.main5_closure+1;
      P32[Hp - 8] = Main.main_n_closure+1;
      P32[Hp - 4] = _s2iC::P32;
      I32[Hp] = _s2iw::I32;
      _c2FV::P32 = Hp - 15;
      R1 = _c2FV::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2GP:
      _s2iv::P32 = P32[(old + 8)];
      goto c2xV;
  c2xV:
      if (Sp - <highSp> < SpLim) goto c2GQ; else goto c2GR;
  c2GQ:
      R1 = Main.main12_closure;
      P32[(old + 8)] = _s2iv::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2GR:
      I32[(young<c2xX> + 4)] = c2xX;
      P32[(young<c2xX> + 12)] = Main.main5_closure+1;
      P32[(young<c2xX> + 8)] = Main.main_n_closure+1;
      call GHC.Arr.$w$crangeSize5_info() returns to c2xX, args: 12, res: 4, upd: 4;
  c2xX:
      _s2iw::I32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2GU; else goto c2GT;
  c2GU:
      HpAlloc = 12;
      goto c2GS;
  c2GS:
      R1 = _s2iw::I32;
      call stg_gc_unbx_r1(R1) returns to c2xX, args: 4, res: 4, upd: 4;
  c2GT:
      _c2y1::I32 = %MO_S_Lt_W32(_s2iw::I32, 0);
      _s2ix::I32 = _c2y1::I32;
      if (_s2ix::I32 >= 1) goto c2GX; else goto c2GW;
  c2GX:
      Hp = Hp - 12;
      R1 = GHC.Arr.negRange_closure;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  c2GW:
      I32[Hp - 8] = sat_s2kZ_info;
      P32[Hp - 4] = _s2iv::P32;
      I32[Hp] = _s2iw::I32;
      _c2y6::P32 = Hp - 7;
      P32[(old + 8)] = _c2y6::P32;
      call GHC.ST.runSTRep_info() args: 8, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2GP:
      _s2iv::P32 = P32[(old + 8)];
      goto c2xV;
  c2xV:
      if (Sp - <highSp> < SpLim) goto c2GQ; else goto c2GR;
  c2GQ:
      R1 = Main.main12_closure;
      P32[(old + 8)] = _s2iv::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2GR:
      I32[(young<c2xX> + 4)] = c2xX;
      P32[(young<c2xX> + 12)] = Main.main5_closure+1;
      P32[(young<c2xX> + 8)] = Main.main_n_closure+1;
      call GHC.Arr.$w$crangeSize5_info() returns to c2xX, args: 12, res: 4, upd: 4;
  c2xX:
      _s2iw::I32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2GU; else goto c2GT;
  c2GU:
      HpAlloc = 12;
      goto c2GS;
  c2GS:
      R1 = R1;
      call stg_gc_unbx_r1(R1) returns to c2xX, args: 4, res: 4, upd: 4;
  c2GT:
      _c2y1::I32 = %MO_S_Lt_W32(R1, 0);
      _s2ix::I32 = _c2y1::I32;
      if (_c2y1::I32 >= 1) goto c2GX; else goto c2GW;
  c2GX:
      Hp = Hp - 12;
      R1 = GHC.Arr.negRange_closure;
      call (I32[GHC.Arr.negRange_closure])(R1) args: 4, res: 0, upd: 4;
  c2GW:
      I32[Hp - 8] = sat_s2kZ_info;
      P32[Hp - 4] = _s2iv::P32;
      I32[Hp] = R1;
      _c2y6::P32 = Hp - 7;
      P32[(old + 8)] = _c2y6::P32;
      call GHC.ST.runSTRep_info() args: 8, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2KD:
      _s2l8::P32 = R1;
      _s2l9::I32 = I32[(old + 12)];
      _s2la::P32 = P32[(old + 8)];
      goto c2Kz;
  c2Kz:
      if (Sp - <highSp> < SpLim) goto c2KE; else goto c2L1;
  c2KE:
      R1 = _s2l8::P32;
      I32[(old + 12)] = _s2l9::I32;
      P32[(old + 8)] = _s2la::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c2L1:
      _s2l7::P32 = P32[_s2l8::P32 + 1];
      _s2l2::I32 = I32[_s2l8::P32 + 5];
      _c2KB::I32 = _s2l9::I32 == _s2l2::I32;
      _s2lc::I32 = _c2KB::I32;
      if (_s2lc::I32 >= 1) goto c2L0; else goto c2KK;
  c2KK:
      I32[(young<c2KI> + 4)] = c2KI;
      R1 = _s2la::P32;
      if (R1 & 3 != 0) goto c2KI; else goto c2KL;
  c2KL:
      call (I32[R1])(R1) returns to c2KI, args: 4, res: 4, upd: 4;
  c2KI:
      _s2le::P32 = R1;
      _c2KW::P32 = _s2le::P32 & 3;
      if (_c2KW::P32 >= 2) goto c2KV; else goto c2L0;
  c2KV:
      _s2lf::P32 = P32[_s2le::P32 + 2];
      _s2lg::P32 = P32[_s2le::P32 + 6];
      P32[(_s2l7::P32 + 12) + (_s2l9::I32 << 2)] = _s2lf::P32;
      I32[_s2l7::P32] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_s2l7::P32 + 12) + (I32[_s2l7::P32 + 4] << 2) + (_s2l9::I32 >> 7)] = 1 :: W8;
      _c2L7::I32 = _s2l9::I32 + 1;
      _s2li::I32 = _c2L7::I32;
      R1 = _s2l8::P32;
      I32[(old + 12)] = _s2li::I32;
      P32[(old + 8)] = _s2lg::P32;
      call fillFromList_s2l8_info(R1) args: 12, res: 0, upd: 4;
  c2L0:
      call (P32[(old + 4)])() args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2KD:
      _s2l8::P32 = R1;
      _s2l9::I32 = I32[(old + 12)];
      _s2la::P32 = P32[(old + 8)];
      goto c2Kz;
  c2Kz:
      if (Sp - <highSp> < SpLim) goto c2KE; else goto c2L1;
  c2KE:
      R1 = R1;
      I32[(old + 12)] = _s2l9::I32;
      P32[(old + 8)] = _s2la::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c2L1:
      _s2l7::P32 = P32[R1 + 1];
      _s2l2::I32 = I32[R1 + 5];
      _c2KB::I32 = _s2l9::I32 == _s2l2::I32;
      _s2lc::I32 = _c2KB::I32;
      if (_c2KB::I32 >= 1) goto c2L0; else goto c2KK;
  c2KK:
      I32[(young<c2KI> + 4)] = c2KI;
      R1 = _s2la::P32;
      if (_s2la::P32 & 3 != 0) goto c2KI; else goto c2KL;
  c2KL:
      call (I32[_s2la::P32])(R1) returns to c2KI, args: 4, res: 4, upd: 4;
  c2KI:
      _s2le::P32 = R1;
      _c2KW::P32 = R1 & 3;
      if (_c2KW::P32 >= 2) goto c2KV; else goto c2L0;
  c2KV:
      _s2lf::P32 = P32[R1 + 2];
      _s2lg::P32 = P32[R1 + 6];
      P32[(_s2l7::P32 + 12) + (_s2l9::I32 << 2)] = _s2lf::P32;
      I32[_s2l7::P32] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_s2l7::P32 + 12) + (I32[_s2l7::P32 + 4] << 2) + (_s2l9::I32 >> 7)] = 1 :: W8;
      _c2L7::I32 = _s2l9::I32 + 1;
      _s2li::I32 = _c2L7::I32;
      R1 = _s2l8::P32;
      I32[(old + 12)] = _c2L7::I32;
      P32[(old + 8)] = _s2lg::P32;
      call fillFromList_s2l8_info(R1) args: 12, res: 0, upd: 4;
  c2L0:
      call (P32[(old + 4)])() args: 4, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2Kk:
      if (Sp - <highSp> < SpLim) goto c2La; else goto c2Lb;
  c2La:
      R1 = Main.main11_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2Lb:
      I32[(young<c2Km> + 4)] = c2Km;
      P32[(young<c2Km> + 12)] = Main.main5_closure+1;
      P32[(young<c2Km> + 8)] = Main.main_n_closure+1;
      call GHC.Arr.$w$crangeSize5_info() returns to c2Km, args: 12, res: 4, upd: 4;
  c2Km:
      _s2l2::I32 = R1;
      _c2Kq::I32 = %MO_S_Lt_W32(_s2l2::I32, 0);
      _s2l3::I32 = _c2Kq::I32;
      if (_s2l3::I32 >= 1) goto c2Lq; else goto c2Lj;
  c2Lq:
      R1 = GHC.Arr.negRange_closure;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  c2Lj:
      I32[(young<c2Kv> + 4)] = c2Kv;
      R1 = _s2l2::I32;
      P32[(young<c2Kv> + 8)] = GHC.Arr.arrEleBottom_closure;
      call stg_newArray#(R1) returns to c2Kv, args: 8, res: 4, upd: 4;
  c2Kv:
      _s2l7::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Lm; else goto c2Ll;
  c2Lm:
      HpAlloc = 12;
      goto c2Lk;
  c2Lk:
      R1 = _s2l7::P32;
      call stg_gc_unpt_r1(R1) returns to c2Kv, args: 4, res: 4, upd: 4;
  c2Ll:
      _c2Kx::P32 = Hp - 5;
      I32[Hp - 8] = fillFromList_s2l8_info;
      P32[Hp - 4] = _s2l7::P32;
      I32[Hp] = _s2l2::I32;
      I32[(young<c2Ld> + 4)] = c2Ld;
      R1 = _c2Kx::P32;
      I32[(young<c2Ld> + 12)] = 0;
      P32[(young<c2Ld> + 8)] = Main.main_xs_closure+2;
      call fillFromList_s2l8_info(R1) returns to c2Ld, args: 12, res: 4, upd: 4;
  c2Ld:
      Hp = Hp + 20;
      if (Hp > HpLim) goto c2Lp; else goto c2Lo;
  c2Lp:
      HpAlloc = 20;
      goto c2Ln;
  c2Ln:
      call stg_gc_noregs() returns to c2Ld, args: 4, res: 4, upd: 4;
  c2Lo:
      I32[_s2l7::P32] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _s2lm::P32 = _s2l7::P32;
      _s2lm::P32 = _s2lm::P32;
      I32[Hp - 16] = GHC.Arr.Array_con_info;
      P32[Hp - 12] = Main.main5_closure+1;
      P32[Hp - 8] = Main.main_n_closure+1;
      P32[Hp - 4] = _s2lm::P32;
      I32[Hp] = _s2l2::I32;
      _c2Lh::P32 = Hp - 15;
      R1 = _c2Lh::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2Kk:
      if (Sp - <highSp> < SpLim) goto c2La; else goto c2Lb;
  c2La:
      R1 = Main.main11_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2Lb:
      I32[(young<c2Km> + 4)] = c2Km;
      P32[(young<c2Km> + 12)] = Main.main5_closure+1;
      P32[(young<c2Km> + 8)] = Main.main_n_closure+1;
      call GHC.Arr.$w$crangeSize5_info() returns to c2Km, args: 12, res: 4, upd: 4;
  c2Km:
      _s2l2::I32 = R1;
      _c2Kq::I32 = %MO_S_Lt_W32(R1, 0);
      _s2l3::I32 = _c2Kq::I32;
      if (_c2Kq::I32 >= 1) goto c2Lq; else goto c2Lj;
  c2Lq:
      R1 = GHC.Arr.negRange_closure;
      call (I32[GHC.Arr.negRange_closure])(R1) args: 4, res: 0, upd: 4;
  c2Lj:
      I32[(young<c2Kv> + 4)] = c2Kv;
      R1 = R1;
      P32[(young<c2Kv> + 8)] = GHC.Arr.arrEleBottom_closure;
      call stg_newArray#(R1) returns to c2Kv, args: 8, res: 4, upd: 4;
  c2Kv:
      _s2l7::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Lm; else goto c2Ll;
  c2Lm:
      HpAlloc = 12;
      goto c2Lk;
  c2Lk:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c2Kv, args: 4, res: 4, upd: 4;
  c2Ll:
      _c2Kx::P32 = Hp - 5;
      I32[Hp - 8] = fillFromList_s2l8_info;
      P32[Hp - 4] = R1;
      I32[Hp] = _s2l2::I32;
      I32[(young<c2Ld> + 4)] = c2Ld;
      R1 = _c2Kx::P32;
      I32[(young<c2Ld> + 12)] = 0;
      P32[(young<c2Ld> + 8)] = Main.main_xs_closure+2;
      call fillFromList_s2l8_info(R1) returns to c2Ld, args: 12, res: 4, upd: 4;
  c2Ld:
      Hp = Hp + 20;
      if (Hp > HpLim) goto c2Lp; else goto c2Lo;
  c2Lp:
      HpAlloc = 20;
      goto c2Ln;
  c2Ln:
      call stg_gc_noregs() returns to c2Ld, args: 4, res: 4, upd: 4;
  c2Lo:
      I32[_s2l7::P32] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _s2lm::P32 = _s2l7::P32;
      _s2lm::P32 = _s2l7::P32;
      I32[Hp - 16] = GHC.Arr.Array_con_info;
      P32[Hp - 12] = Main.main5_closure+1;
      P32[Hp - 8] = Main.main_n_closure+1;
      P32[Hp - 4] = _s2l7::P32;
      I32[Hp] = _s2l2::I32;
      _c2Lh::P32 = Hp - 15;
      R1 = _c2Lh::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2LZ:
      _r2hk::P32 = R1;
      goto c2LU;
  c2LU:
      if (Sp - <highSp> < SpLim) goto c2M0; else goto c2M1;
  c2M1:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2M3; else goto c2M2;
  c2M3:
      HpAlloc = 8;
      goto c2M0;
  c2M0:
      R1 = _r2hk::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2M2:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2LW::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hk::P32, Hp - 4);
      if (_c2LW::I32 == 0) goto c2LY; else goto c2LX;
  c2LY:
      call (I32[_r2hk::P32])() args: 4, res: 0, upd: 4;
  c2LX:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 16)] = Main.main11_closure+1;
      call GHC.ST.runSTRep_info() args: 16, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2LZ:
      _r2hk::P32 = R1;
      goto c2LU;
  c2LU:
      if (Sp - <highSp> < SpLim) goto c2M0; else goto c2M1;
  c2M1:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2M3; else goto c2M2;
  c2M3:
      HpAlloc = 8;
      goto c2M0;
  c2M0:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2M2:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2LW::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2LW::I32 == 0) goto c2LY; else goto c2LX;
  c2LY:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2LX:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 16)] = Main.main11_closure+1;
      call GHC.ST.runSTRep_info() args: 16, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2MF:
      _r2hi::P32 = R1;
      goto c2Mo;
  c2Mo:
      if (Sp - <highSp> < SpLim) goto c2MG; else goto c2MH;
  c2MH:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2MJ; else goto c2MI;
  c2MJ:
      HpAlloc = 8;
      goto c2MG;
  c2MG:
      R1 = _r2hi::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2MI:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2Mq::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hi::P32, Hp - 4);
      if (_c2Mq::I32 == 0) goto c2Ms; else goto c2Mr;
  c2Ms:
      call (I32[_r2hi::P32])() args: 4, res: 0, upd: 4;
  c2Mr:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c2Mt> + 4)] = c2Mt;
      P32[(young<c2Mt> + 12)] = Main.main12_closure+1;
      P32[(young<c2Mt> + 8)] = Main.main10_closure;
      call GHC.List.$witerate_info() returns to c2Mt, args: 12, res: 8, upd: 12;
  c2Mt:
      _s2lq::P32 = R1;
      _s2lr::P32 = P32[(young<c2Mt> + 8)];
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2MM; else goto c2ML;
  c2MM:
      HpAlloc = 12;
      goto c2MK;
  c2MK:
      R1 = _s2lq::P32;
      P32[(young<c2Mt> + 8)] = _s2lr::P32;
      call stg_gc_pp(R1) returns to c2Mt, args: 8, res: 8, upd: 12;
  c2ML:
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _s2lq::P32;
      P32[Hp] = _s2lr::P32;
      _c2Mv::P32 = Hp - 6;
      I32[(young<c2Mw> + 4)] = c2Mw;
      I32[(young<c2Mw> + 12)] = 19;
      P32[(young<c2Mw> + 8)] = _c2Mv::P32;
      call GHC.List.drop_drop#_info() returns to c2Mw, args: 12, res: 4, upd: 12;
  c2Mw:
      _s2lt::P32 = R1;
      _c2MB::P32 = _s2lt::P32 & 3;
      if (_c2MB::P32 >= 2) goto c2MA; else goto c2N0;
  c2MA:
      _s2lu::P32 = P32[_s2lt::P32 + 2];
      _s2lv::P32 = P32[_s2lt::P32 + 6];
      I32[(young<c2MS> + 4)] = c2MS;
      R1 = _s2lv::P32;
      if (R1 & 3 != 0) goto c2MS; else goto c2MU;
  c2MU:
      call (I32[R1])(R1) returns to c2MS, args: 4, res: 4, upd: 12;
  c2MS:
      _s2lw::P32 = R1;
      _c2N8::P32 = _s2lw::P32 & 3;
      if (_c2N8::P32 >= 2) goto c2N4; else goto c2N0;
  c2N4:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c2N7; else goto c2N6;
  c2N7:
      HpAlloc = 16;
      goto c2N5;
  c2N5:
      R1 = _s2lw::P32;
      call stg_gc_unpt_r1(R1) returns to c2MS, args: 4, res: 4, upd: 12;
  c2N6:
      _s2lx::P32 = P32[_s2lw::P32 + 2];
      _s2ly::P32 = P32[_s2lw::P32 + 6];
      I32[Hp - 12] = (,,)_con_info;
      P32[Hp - 8] = _s2lu::P32;
      P32[Hp - 4] = _s2lx::P32;
      P32[Hp] = _s2ly::P32;
      _c2N3::P32 = Hp - 11;
      R1 = _c2N3::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2N0:
      R1 = Main.main9_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2MF:
      _r2hi::P32 = R1;
      goto c2Mo;
  c2Mo:
      if (Sp - <highSp> < SpLim) goto c2MG; else goto c2MH;
  c2MH:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2MJ; else goto c2MI;
  c2MJ:
      HpAlloc = 8;
      goto c2MG;
  c2MG:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2MI:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2Mq::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2Mq::I32 == 0) goto c2Ms; else goto c2Mr;
  c2Ms:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2Mr:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c2Mt> + 4)] = c2Mt;
      P32[(young<c2Mt> + 12)] = Main.main12_closure+1;
      P32[(young<c2Mt> + 8)] = Main.main10_closure;
      call GHC.List.$witerate_info() returns to c2Mt, args: 12, res: 8, upd: 12;
  c2Mt:
      _s2lq::P32 = R1;
      _s2lr::P32 = P32[(young<c2Mt> + 8)];
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2MM; else goto c2ML;
  c2MM:
      HpAlloc = 12;
      goto c2MK;
  c2MK:
      R1 = R1;
      P32[(young<c2Mt> + 8)] = _s2lr::P32;
      call stg_gc_pp(R1) returns to c2Mt, args: 8, res: 8, upd: 12;
  c2ML:
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = R1;
      P32[Hp] = _s2lr::P32;
      _c2Mv::P32 = Hp - 6;
      I32[(young<c2Mw> + 4)] = c2Mw;
      I32[(young<c2Mw> + 12)] = 19;
      P32[(young<c2Mw> + 8)] = _c2Mv::P32;
      call GHC.List.drop_drop#_info() returns to c2Mw, args: 12, res: 4, upd: 12;
  c2Mw:
      _s2lt::P32 = R1;
      _c2MB::P32 = R1 & 3;
      if (_c2MB::P32 >= 2) goto c2MA; else goto c2N0;
  c2MA:
      _s2lu::P32 = P32[R1 + 2];
      _s2lv::P32 = P32[R1 + 6];
      I32[(young<c2MS> + 4)] = c2MS;
      R1 = _s2lv::P32;
      if (_s2lv::P32 & 3 != 0) goto c2MS; else goto c2MU;
  c2MU:
      call (I32[_s2lv::P32])(R1) returns to c2MS, args: 4, res: 4, upd: 12;
  c2MS:
      _s2lw::P32 = R1;
      _c2N8::P32 = R1 & 3;
      if (_c2N8::P32 >= 2) goto c2N4; else goto c2N0;
  c2N4:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c2N7; else goto c2N6;
  c2N7:
      HpAlloc = 16;
      goto c2N5;
  c2N5:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c2MS, args: 4, res: 4, upd: 12;
  c2N6:
      _s2lx::P32 = P32[R1 + 2];
      _s2ly::P32 = P32[R1 + 6];
      I32[Hp - 12] = (,,)_con_info;
      P32[Hp - 8] = _s2lu::P32;
      P32[Hp - 4] = _s2lx::P32;
      P32[Hp] = _s2ly::P32;
      _c2N3::P32 = Hp - 11;
      R1 = _c2N3::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2N0:
      R1 = Main.main9_closure;
      call (I32[Main.main9_closure])(R1) args: 12, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2NF:
      _r2hH::P32 = R1;
      goto c2Nx;
  c2Nx:
      if (Sp - <highSp> < SpLim) goto c2NG; else goto c2NH;
  c2NH:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2NJ; else goto c2NI;
  c2NJ:
      HpAlloc = 8;
      goto c2NG;
  c2NG:
      R1 = _r2hH::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2NI:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2Nz::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hH::P32, Hp - 4);
      if (_c2Nz::I32 == 0) goto c2NB; else goto c2NA;
  c2NB:
      call (I32[_r2hH::P32])() args: 4, res: 0, upd: 4;
  c2NA:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c2NC> + 4)] = c2NC;
      R1 = Main.main8_closure;
      if (R1 & 3 != 0) goto c2NC; else goto c2ND;
  c2ND:
      call (I32[R1])(R1) returns to c2NC, args: 4, res: 4, upd: 12;
  c2NC:
      _s2lz::P32 = R1;
      _s2lA::P32 = P32[_s2lz::P32 + 3];
      _s2lB::P32 = P32[_s2lz::P32 + 7];
      _s2lC::P32 = P32[_s2lz::P32 + 11];
      R1 = _s2lB::P32 & (-4);
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2NF:
      _r2hH::P32 = R1;
      goto c2Nx;
  c2Nx:
      if (Sp - <highSp> < SpLim) goto c2NG; else goto c2NH;
  c2NH:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2NJ; else goto c2NI;
  c2NJ:
      HpAlloc = 8;
      goto c2NG;
  c2NG:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2NI:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2Nz::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2Nz::I32 == 0) goto c2NB; else goto c2NA;
  c2NB:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2NA:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c2NC> + 4)] = c2NC;
      R1 = Main.main8_closure;
      if (Main.main8_closure & 3 != 0) goto c2NC; else goto c2ND;
  c2ND:
      call (I32[Main.main8_closure])(R1) returns to c2NC, args: 4, res: 4, upd: 12;
  c2NC:
      _s2lz::P32 = R1;
      _s2lA::P32 = P32[R1 + 3];
      _s2lB::P32 = P32[R1 + 7];
      _s2lC::P32 = P32[R1 + 11];
      R1 = _s2lB::P32 & (-4);
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2Oa:
      _r2hh::P32 = R1;
      goto c2O2;
  c2O2:
      if (Sp - <highSp> < SpLim) goto c2Ob; else goto c2Oc;
  c2Oc:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2Oe; else goto c2Od;
  c2Oe:
      HpAlloc = 8;
      goto c2Ob;
  c2Ob:
      R1 = _r2hh::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2Od:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2O4::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hh::P32, Hp - 4);
      if (_c2O4::I32 == 0) goto c2O6; else goto c2O5;
  c2O6:
      call (I32[_r2hh::P32])() args: 4, res: 0, upd: 4;
  c2O5:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c2O7> + 4)] = c2O7;
      R1 = Main.main8_closure;
      if (R1 & 3 != 0) goto c2O7; else goto c2O8;
  c2O8:
      call (I32[R1])(R1) returns to c2O7, args: 4, res: 4, upd: 12;
  c2O7:
      _s2lD::P32 = R1;
      _s2lE::P32 = P32[_s2lD::P32 + 3];
      _s2lF::P32 = P32[_s2lD::P32 + 7];
      _s2lG::P32 = P32[_s2lD::P32 + 11];
      R1 = _s2lE::P32 & (-4);
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2Oa:
      _r2hh::P32 = R1;
      goto c2O2;
  c2O2:
      if (Sp - <highSp> < SpLim) goto c2Ob; else goto c2Oc;
  c2Oc:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2Oe; else goto c2Od;
  c2Oe:
      HpAlloc = 8;
      goto c2Ob;
  c2Ob:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2Od:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2O4::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2O4::I32 == 0) goto c2O6; else goto c2O5;
  c2O6:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2O5:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c2O7> + 4)] = c2O7;
      R1 = Main.main8_closure;
      if (Main.main8_closure & 3 != 0) goto c2O7; else goto c2O8;
  c2O8:
      call (I32[Main.main8_closure])(R1) returns to c2O7, args: 4, res: 4, upd: 12;
  c2O7:
      _s2lD::P32 = R1;
      _s2lE::P32 = P32[R1 + 3];
      _s2lF::P32 = P32[R1 + 7];
      _s2lG::P32 = P32[R1 + 11];
      R1 = _s2lE::P32 & (-4);
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2Ox:
      _s2lH::P32 = P32[(old + 16)];
      _s2lI::P32 = P32[(old + 12)];
      _s2lJ::P32 = P32[(old + 8)];
      goto c2Ou;
  c2Ou:
      if (Sp - <highSp> < SpLim) goto c2Oy; else goto c2Oz;
  c2Oz:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2OB; else goto c2OA;
  c2OB:
      HpAlloc = 12;
      goto c2Oy;
  c2Oy:
      R1 = lvl11_r2hI_closure;
      P32[(old + 16)] = _s2lH::P32;
      P32[(old + 12)] = _s2lI::P32;
      P32[(old + 8)] = _s2lJ::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2OA:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2lH::P32;
      P32[Hp] = _s2lI::P32;
      _c2Ow::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2Ow::P32;
      P32[(old + 12)] = _s2lJ::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2Ox:
      _s2lH::P32 = P32[(old + 16)];
      _s2lI::P32 = P32[(old + 12)];
      _s2lJ::P32 = P32[(old + 8)];
      goto c2Ou;
  c2Ou:
      if (Sp - <highSp> < SpLim) goto c2Oy; else goto c2Oz;
  c2Oz:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2OB; else goto c2OA;
  c2OB:
      HpAlloc = 12;
      goto c2Oy;
  c2Oy:
      R1 = lvl11_r2hI_closure;
      P32[(old + 16)] = _s2lH::P32;
      P32[(old + 12)] = _s2lI::P32;
      P32[(old + 8)] = _s2lJ::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2OA:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2lH::P32;
      P32[Hp] = _s2lI::P32;
      _c2Ow::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2Ow::P32;
      P32[(old + 12)] = _s2lJ::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2OP:
      _s2lL::P32 = P32[(old + 16)];
      _s2lM::P32 = P32[(old + 12)];
      _s2lN::P32 = P32[(old + 8)];
      goto c2ON;
  c2ON:
      if (Sp - <highSp> < SpLim) goto c2OQ; else goto c2OR;
  c2OQ:
      R1 = Main.main7_closure;
      P32[(old + 16)] = _s2lL::P32;
      P32[(old + 12)] = _s2lM::P32;
      P32[(old + 8)] = _s2lN::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2OR:
      P32[(old + 16)] = _s2lL::P32;
      P32[(old + 12)] = _s2lM::P32;
      P32[(old + 8)] = _s2lN::P32;
      call lvl11_r2hI_info() args: 16, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2OP:
      _s2lL::P32 = P32[(old + 16)];
      _s2lM::P32 = P32[(old + 12)];
      _s2lN::P32 = P32[(old + 8)];
      goto c2ON;
  c2ON:
      if (Sp - <highSp> < SpLim) goto c2OQ; else goto c2OR;
  c2OQ:
      R1 = Main.main7_closure;
      P32[(old + 16)] = _s2lL::P32;
      P32[(old + 12)] = _s2lM::P32;
      P32[(old + 8)] = _s2lN::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2OR:
      P32[(old + 16)] = _s2lL::P32;
      P32[(old + 12)] = _s2lM::P32;
      P32[(old + 8)] = _s2lN::P32;
      call lvl11_r2hI_info() args: 16, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2PQ:
      _s2me::P32 = R1;
      goto c2PL;
  c2PL:
      if (Sp - <highSp> < SpLim) goto c2PU; else goto c2PV;
  c2PU:
      R1 = _s2me::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2PV:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2me::P32;
      _s2lQ::P32 = P32[_s2me::P32 + 8];
      I32[(young<c2PN> + 4)] = c2PN;
      R1 = Main.main_v_closure;
      if (R1 & 3 != 0) goto c2PN; else goto c2PO;
  c2PO:
      call (I32[R1])(R1) returns to c2PN, args: 4, res: 4, upd: 12;
  c2PN:
      _s2lS::P32 = R1;
      _s2lT::P32 = P32[_s2lS::P32 + 3];
      _s2lU::P32 = P32[_s2lS::P32 + 7];
      _s2lW::P32 = P32[_s2lS::P32 + 11];
      _s2lV::I32 = I32[_s2lS::P32 + 15];
      I32[(young<c2PT> + 4)] = c2PT;
      P32[(young<c2PT> + 12)] = _s2lT::P32;
      P32[(young<c2PT> + 8)] = _s2lQ::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2PT, args: 12, res: 4, upd: 12;
  c2PT:
      _s2lX::I32 = R1;
      if (_s2lX::I32 >= 1) goto c2Q7; else goto c2Qe;
  c2Q7:
      I32[(young<c2Q6> + 4)] = c2Q6;
      P32[(young<c2Q6> + 12)] = _s2lQ::P32;
      P32[(young<c2Q6> + 8)] = _s2lU::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Q6, args: 12, res: 4, upd: 12;
  c2Q6:
      _s2lZ::I32 = R1;
      if (_s2lZ::I32 >= 1) goto c2Qm; else goto c2Qe;
  c2Qm:
      I32[(young<c2Qh> + 4)] = c2Qh;
      P32[(young<c2Qh> + 12)] = _s2lQ::P32;
      P32[(young<c2Qh> + 8)] = _s2lT::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2Qh, args: 12, res: 4, upd: 12;
  c2Qh:
      _s2m1::P32 = R1;
      I32[(young<c2Ql> + 4)] = c2Ql;
      P32[(young<c2Ql> + 8)] = _s2m1::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2Ql, args: 8, res: 4, upd: 12;
  c2Ql:
      _s2m2::I32 = R1;
      _c2Qs::I32 = %MO_S_Le_W32(0, _s2m2::I32);
      _s2m3::I32 = _c2Qs::I32;
      if (_s2m3::I32 >= 1) goto c2QV; else goto c2QF;
  c2QV:
      _c2QA::I32 = %MO_S_Lt_W32(_s2m2::I32, _s2lV::I32);
      _s2m6::I32 = _c2QA::I32;
      if (_s2m6::I32 >= 1) goto c2QR; else goto c2QF;
  c2QR:
      _s2ma::P32 = P32[(_s2lW::P32 + 12) + (_s2m2::I32 << 2)];
      _s2ma::P32 = _s2ma::P32;
      I32[(young<c2QI> + 4)] = c2QI;
      R1 = _s2ma::P32;
      if (R1 & 3 != 0) goto c2QI; else goto c2QJ;
  c2QJ:
      call (I32[R1])(R1) returns to c2QI, args: 4, res: 4, upd: 12;
  c2QI:
      _s2mb::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2QU; else goto c2QT;
  c2QU:
      HpAlloc = 12;
      goto c2QS;
  c2QS:
      R1 = _s2mb::P32;
      call stg_gc_unpt_r1(R1) returns to c2QI, args: 4, res: 4, upd: 12;
  c2QT:
      _s2mc::F64 = F64[_s2mb::P32 + 3];
      _c2QN::F64 = %MO_F_Mul_W64(_s2mc::F64, _s2mc::F64);
      _s2md::F64 = _c2QN::F64;
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _s2md::F64;
      _c2QQ::P32 = Hp - 7;
      R1 = _c2QQ::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2QF:
      I32[(old + 20)] = _s2m2::I32;
      I32[(old + 16)] = _s2lV::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2Qe:
      P32[(old + 24)] = _s2lT::P32;
      P32[(old + 20)] = _s2lU::P32;
      P32[(old + 16)] = _s2lQ::P32;
      call Main.main7_info() args: 24, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2PQ:
      _s2me::P32 = R1;
      goto c2PL;
  c2PL:
      if (Sp - <highSp> < SpLim) goto c2PU; else goto c2PV;
  c2PU:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2PV:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s2lQ::P32 = P32[R1 + 8];
      I32[(young<c2PN> + 4)] = c2PN;
      R1 = Main.main_v_closure;
      if (Main.main_v_closure & 3 != 0) goto c2PN; else goto c2PO;
  c2PO:
      call (I32[Main.main_v_closure])(R1) returns to c2PN, args: 4, res: 4, upd: 12;
  c2PN:
      _s2lS::P32 = R1;
      _s2lT::P32 = P32[R1 + 3];
      _s2lU::P32 = P32[R1 + 7];
      _s2lW::P32 = P32[R1 + 11];
      _s2lV::I32 = I32[R1 + 15];
      I32[(young<c2PT> + 4)] = c2PT;
      P32[(young<c2PT> + 12)] = _s2lT::P32;
      P32[(young<c2PT> + 8)] = _s2lQ::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2PT, args: 12, res: 4, upd: 12;
  c2PT:
      _s2lX::I32 = R1;
      if (R1 >= 1) goto c2Q7; else goto c2Qe;
  c2Q7:
      I32[(young<c2Q6> + 4)] = c2Q6;
      P32[(young<c2Q6> + 12)] = _s2lQ::P32;
      P32[(young<c2Q6> + 8)] = _s2lU::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Q6, args: 12, res: 4, upd: 12;
  c2Q6:
      _s2lZ::I32 = R1;
      if (R1 >= 1) goto c2Qm; else goto c2Qe;
  c2Qm:
      I32[(young<c2Qh> + 4)] = c2Qh;
      P32[(young<c2Qh> + 12)] = _s2lQ::P32;
      P32[(young<c2Qh> + 8)] = _s2lT::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2Qh, args: 12, res: 4, upd: 12;
  c2Qh:
      _s2m1::P32 = R1;
      I32[(young<c2Ql> + 4)] = c2Ql;
      P32[(young<c2Ql> + 8)] = R1;
      call GHC.Integer.Type.integerToInt_info() returns to c2Ql, args: 8, res: 4, upd: 12;
  c2Ql:
      _s2m2::I32 = R1;
      _c2Qs::I32 = %MO_S_Le_W32(0, R1);
      _s2m3::I32 = _c2Qs::I32;
      if (_c2Qs::I32 >= 1) goto c2QV; else goto c2QF;
  c2QV:
      _c2QA::I32 = %MO_S_Lt_W32(R1, _s2lV::I32);
      _s2m6::I32 = _c2QA::I32;
      if (_c2QA::I32 >= 1) goto c2QR; else goto c2QF;
  c2QR:
      _s2ma::P32 = P32[(_s2lW::P32 + 12) + (R1 << 2)];
      _s2ma::P32 = _s2ma::P32;
      I32[(young<c2QI> + 4)] = c2QI;
      R1 = _s2ma::P32;
      if (_s2ma::P32 & 3 != 0) goto c2QI; else goto c2QJ;
  c2QJ:
      call (I32[_s2ma::P32])(R1) returns to c2QI, args: 4, res: 4, upd: 12;
  c2QI:
      _s2mb::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2QU; else goto c2QT;
  c2QU:
      HpAlloc = 12;
      goto c2QS;
  c2QS:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c2QI, args: 4, res: 4, upd: 12;
  c2QT:
      _s2mc::F64 = F64[R1 + 3];
      _c2QN::F64 = %MO_F_Mul_W64(_s2mc::F64, _s2mc::F64);
      _s2md::F64 = _c2QN::F64;
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _c2QN::F64;
      _c2QQ::P32 = Hp - 7;
      R1 = _c2QQ::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2QF:
      I32[(old + 20)] = R1;
      I32[(old + 16)] = _s2lV::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2Qe:
      P32[(old + 24)] = _s2lT::P32;
      P32[(old + 20)] = _s2lU::P32;
      P32[(old + 16)] = _s2lQ::P32;
      call Main.main7_info() args: 24, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2R9:
      _s2lQ::P32 = P32[(old + 12)];
      _s2lR::P32 = P32[(old + 8)];
      goto c2PH;
  c2PH:
      if (Sp - <highSp> < SpLim) goto c2Ra; else goto c2Rb;
  c2Rb:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c2Rd; else goto c2Rc;
  c2Rd:
      HpAlloc = 24;
      goto c2Ra;
  c2Ra:
      R1 = Main.main6_closure;
      P32[(old + 12)] = _s2lQ::P32;
      P32[(old + 8)] = _s2lR::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c2Rc:
      I32[Hp - 20] = sat_s2me_info;
      P32[Hp - 12] = _s2lQ::P32;
      _c2PJ::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c2PJ::P32;
      P32[Hp] = _s2lR::P32;
      _c2R8::P32 = Hp - 6;
      R1 = _c2R8::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2R9:
      _s2lQ::P32 = P32[(old + 12)];
      _s2lR::P32 = P32[(old + 8)];
      goto c2PH;
  c2PH:
      if (Sp - <highSp> < SpLim) goto c2Ra; else goto c2Rb;
  c2Rb:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c2Rd; else goto c2Rc;
  c2Rd:
      HpAlloc = 24;
      goto c2Ra;
  c2Ra:
      R1 = Main.main6_closure;
      P32[(old + 12)] = _s2lQ::P32;
      P32[(old + 8)] = _s2lR::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c2Rc:
      I32[Hp - 20] = sat_s2me_info;
      P32[Hp - 12] = _s2lQ::P32;
      _c2PJ::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c2PJ::P32;
      P32[Hp] = _s2lR::P32;
      _c2R8::P32 = Hp - 6;
      R1 = _c2R8::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2RE:
      _r2hb::P32 = R1;
      goto c2Rz;
  c2Rz:
      if (Sp - <highSp> < SpLim) goto c2RF; else goto c2RG;
  c2RG:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2RI; else goto c2RH;
  c2RI:
      HpAlloc = 8;
      goto c2RF;
  c2RF:
      R1 = _r2hb::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2RH:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2RB::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hb::P32, Hp - 4);
      if (_c2RB::I32 == 0) goto c2RD; else goto c2RC;
  c2RD:
      call (I32[_r2hb::P32])() args: 4, res: 0, upd: 4;
  c2RC:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 32)] = Main.main6_closure+2;
      P32[(old + 28)] = GHC.Types.[]_closure+1;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToIntegerFB_info() args: 32, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2RE:
      _r2hb::P32 = R1;
      goto c2Rz;
  c2Rz:
      if (Sp - <highSp> < SpLim) goto c2RF; else goto c2RG;
  c2RG:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2RI; else goto c2RH;
  c2RI:
      HpAlloc = 8;
      goto c2RF;
  c2RF:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2RH:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2RB::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2RB::I32 == 0) goto c2RD; else goto c2RC;
  c2RD:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2RC:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 32)] = Main.main6_closure+2;
      P32[(old + 28)] = GHC.Types.[]_closure+1;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToIntegerFB_info() args: 32, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2RY:
      _s2mf::P32 = P32[(old + 16)];
      _s2mg::P32 = P32[(old + 12)];
      _s2mh::P32 = P32[(old + 8)];
      goto c2RV;
  c2RV:
      if (Sp - <highSp> < SpLim) goto c2RZ; else goto c2S0;
  c2S0:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2S2; else goto c2S1;
  c2S2:
      HpAlloc = 12;
      goto c2RZ;
  c2RZ:
      R1 = lvl12_r2hJ_closure;
      P32[(old + 16)] = _s2mf::P32;
      P32[(old + 12)] = _s2mg::P32;
      P32[(old + 8)] = _s2mh::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2S1:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2mf::P32;
      P32[Hp] = _s2mg::P32;
      _c2RX::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2RX::P32;
      P32[(old + 12)] = _s2mh::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2RY:
      _s2mf::P32 = P32[(old + 16)];
      _s2mg::P32 = P32[(old + 12)];
      _s2mh::P32 = P32[(old + 8)];
      goto c2RV;
  c2RV:
      if (Sp - <highSp> < SpLim) goto c2RZ; else goto c2S0;
  c2S0:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2S2; else goto c2S1;
  c2S2:
      HpAlloc = 12;
      goto c2RZ;
  c2RZ:
      R1 = lvl12_r2hJ_closure;
      P32[(old + 16)] = _s2mf::P32;
      P32[(old + 12)] = _s2mg::P32;
      P32[(old + 8)] = _s2mh::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2S1:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2mf::P32;
      P32[Hp] = _s2mg::P32;
      _c2RX::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2RX::P32;
      P32[(old + 12)] = _s2mh::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2Sg:
      _s2mj::P32 = P32[(old + 16)];
      _s2mk::P32 = P32[(old + 12)];
      _s2ml::P32 = P32[(old + 8)];
      goto c2Se;
  c2Se:
      if (Sp - <highSp> < SpLim) goto c2Sh; else goto c2Si;
  c2Sh:
      R1 = poly_$w$j4_r2hK_closure;
      P32[(old + 16)] = _s2mj::P32;
      P32[(old + 12)] = _s2mk::P32;
      P32[(old + 8)] = _s2ml::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2Si:
      P32[(old + 16)] = _s2mj::P32;
      P32[(old + 12)] = _s2mk::P32;
      P32[(old + 8)] = _s2ml::P32;
      call lvl12_r2hJ_info() args: 16, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2Sg:
      _s2mj::P32 = P32[(old + 16)];
      _s2mk::P32 = P32[(old + 12)];
      _s2ml::P32 = P32[(old + 8)];
      goto c2Se;
  c2Se:
      if (Sp - <highSp> < SpLim) goto c2Sh; else goto c2Si;
  c2Sh:
      R1 = poly_$w$j4_r2hK_closure;
      P32[(old + 16)] = _s2mj::P32;
      P32[(old + 12)] = _s2mk::P32;
      P32[(old + 8)] = _s2ml::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2Si:
      P32[(old + 16)] = _s2mj::P32;
      P32[(old + 12)] = _s2mk::P32;
      P32[(old + 8)] = _s2ml::P32;
      call lvl12_r2hJ_info() args: 16, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2Ss:
      _s2mo::P32 = P32[(old + 16)];
      _s2mp::P32 = P32[(old + 12)];
      _s2mq::P32 = P32[(old + 8)];
      goto c2Sp;
  c2Sp:
      if (Sp - <highSp> < SpLim) goto c2St; else goto c2Su;
  c2Su:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Sw; else goto c2Sv;
  c2Sw:
      HpAlloc = 12;
      goto c2St;
  c2St:
      R1 = lvl13_r2hL_closure;
      P32[(old + 16)] = _s2mo::P32;
      P32[(old + 12)] = _s2mp::P32;
      P32[(old + 8)] = _s2mq::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2Sv:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2mo::P32;
      P32[Hp] = _s2mp::P32;
      _c2Sr::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2Sr::P32;
      P32[(old + 12)] = _s2mq::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2Ss:
      _s2mo::P32 = P32[(old + 16)];
      _s2mp::P32 = P32[(old + 12)];
      _s2mq::P32 = P32[(old + 8)];
      goto c2Sp;
  c2Sp:
      if (Sp - <highSp> < SpLim) goto c2St; else goto c2Su;
  c2Su:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Sw; else goto c2Sv;
  c2Sw:
      HpAlloc = 12;
      goto c2St;
  c2St:
      R1 = lvl13_r2hL_closure;
      P32[(old + 16)] = _s2mo::P32;
      P32[(old + 12)] = _s2mp::P32;
      P32[(old + 8)] = _s2mq::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2Sv:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2mo::P32;
      P32[Hp] = _s2mp::P32;
      _c2Sr::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2Sr::P32;
      P32[(old + 12)] = _s2mq::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2SK:
      _s2ms::P32 = P32[(old + 16)];
      _s2mt::P32 = P32[(old + 12)];
      _s2mu::P32 = P32[(old + 8)];
      goto c2SI;
  c2SI:
      if (Sp - <highSp> < SpLim) goto c2SL; else goto c2SM;
  c2SL:
      R1 = poly_$w$j5_r2hM_closure;
      P32[(old + 16)] = _s2ms::P32;
      P32[(old + 12)] = _s2mt::P32;
      P32[(old + 8)] = _s2mu::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2SM:
      P32[(old + 16)] = _s2ms::P32;
      P32[(old + 12)] = _s2mt::P32;
      P32[(old + 8)] = _s2mu::P32;
      call lvl13_r2hL_info() args: 16, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2SK:
      _s2ms::P32 = P32[(old + 16)];
      _s2mt::P32 = P32[(old + 12)];
      _s2mu::P32 = P32[(old + 8)];
      goto c2SI;
  c2SI:
      if (Sp - <highSp> < SpLim) goto c2SL; else goto c2SM;
  c2SL:
      R1 = poly_$w$j5_r2hM_closure;
      P32[(old + 16)] = _s2ms::P32;
      P32[(old + 12)] = _s2mt::P32;
      P32[(old + 8)] = _s2mu::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2SM:
      P32[(old + 16)] = _s2ms::P32;
      P32[(old + 12)] = _s2mt::P32;
      P32[(old + 8)] = _s2mu::P32;
      call lvl13_r2hL_info() args: 16, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2Uq:
      _s2ng::P32 = R1;
      goto c2Ul;
  c2Ul:
      if (Sp - <highSp> < SpLim) goto c2Uu; else goto c2Uv;
  c2Uu:
      R1 = _s2ng::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2Uv:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2ng::P32;
      _s2mx::P32 = P32[_s2ng::P32 + 8];
      I32[(young<c2Un> + 4)] = c2Un;
      R1 = u_r2hH_closure;
      if (R1 & 3 != 0) goto c2Un; else goto c2Uo;
  c2Uo:
      call (I32[R1])(R1) returns to c2Un, args: 4, res: 4, upd: 12;
  c2Un:
      _s2mz::P32 = R1;
      _s2mA::P32 = P32[_s2mz::P32 + 3];
      _s2mB::P32 = P32[_s2mz::P32 + 7];
      _s2mD::P32 = P32[_s2mz::P32 + 11];
      _s2mC::I32 = I32[_s2mz::P32 + 15];
      I32[(young<c2Ut> + 4)] = c2Ut;
      P32[(young<c2Ut> + 12)] = _s2mA::P32;
      P32[(young<c2Ut> + 8)] = _s2mx::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Ut, args: 12, res: 4, upd: 12;
  c2Ut:
      _s2mE::I32 = R1;
      if (_s2mE::I32 >= 1) goto c2UH; else goto c2UO;
  c2UH:
      I32[(young<c2UG> + 4)] = c2UG;
      P32[(young<c2UG> + 12)] = _s2mx::P32;
      P32[(young<c2UG> + 8)] = _s2mB::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2UG, args: 12, res: 4, upd: 12;
  c2UG:
      _s2mG::I32 = R1;
      if (_s2mG::I32 >= 1) goto c2UW; else goto c2UO;
  c2UW:
      I32[(young<c2UR> + 4)] = c2UR;
      P32[(young<c2UR> + 12)] = _s2mx::P32;
      P32[(young<c2UR> + 8)] = _s2mA::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2UR, args: 12, res: 4, upd: 12;
  c2UR:
      _s2mI::P32 = R1;
      I32[(young<c2UV> + 4)] = c2UV;
      P32[(young<c2UV> + 8)] = _s2mI::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2UV, args: 8, res: 4, upd: 12;
  c2UV:
      _s2mJ::I32 = R1;
      _c2V2::I32 = %MO_S_Le_W32(0, _s2mJ::I32);
      _s2mK::I32 = _c2V2::I32;
      if (_s2mK::I32 >= 1) goto c2WH; else goto c2Vf;
  c2WH:
      _c2Va::I32 = %MO_S_Lt_W32(_s2mJ::I32, _s2mC::I32);
      _s2mN::I32 = _c2Va::I32;
      if (_s2mN::I32 >= 1) goto c2Vt; else goto c2Vf;
  c2Vt:
      _s2mR::P32 = P32[(_s2mD::P32 + 12) + (_s2mJ::I32 << 2)];
      _s2mR::P32 = _s2mR::P32;
      I32[(young<c2Vi> + 4)] = c2Vi;
      R1 = _s2mR::P32;
      if (R1 & 3 != 0) goto c2Vi; else goto c2Vj;
  c2Vj:
      call (I32[R1])(R1) returns to c2Vi, args: 4, res: 4, upd: 12;
  c2Vi:
      _s2mS::P32 = R1;
      _s2mT::F64 = F64[_s2mS::P32 + 3];
      I32[(young<c2Vn> + 4)] = c2Vn;
      R1 = Main.main_v_closure;
      if (R1 & 3 != 0) goto c2Vn; else goto c2Vo;
  c2Vo:
      call (I32[R1])(R1) returns to c2Vn, args: 4, res: 4, upd: 12;
  c2Vn:
      _s2mU::P32 = R1;
      _s2mV::P32 = P32[_s2mU::P32 + 3];
      _s2mW::P32 = P32[_s2mU::P32 + 7];
      _s2mY::P32 = P32[_s2mU::P32 + 11];
      _s2mX::I32 = I32[_s2mU::P32 + 15];
      I32[(young<c2Vs> + 4)] = c2Vs;
      P32[(young<c2Vs> + 12)] = _s2mV::P32;
      P32[(young<c2Vs> + 8)] = _s2mx::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Vs, args: 12, res: 4, upd: 12;
  c2Vs:
      _s2mZ::I32 = R1;
      if (_s2mZ::I32 >= 1) goto c2VG; else goto c2VN;
  c2VG:
      I32[(young<c2VF> + 4)] = c2VF;
      P32[(young<c2VF> + 12)] = _s2mx::P32;
      P32[(young<c2VF> + 8)] = _s2mW::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2VF, args: 12, res: 4, upd: 12;
  c2VF:
      _s2n1::I32 = R1;
      if (_s2n1::I32 >= 1) goto c2VV; else goto c2VN;
  c2VV:
      I32[(young<c2VQ> + 4)] = c2VQ;
      P32[(young<c2VQ> + 12)] = _s2mx::P32;
      P32[(young<c2VQ> + 8)] = _s2mV::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2VQ, args: 12, res: 4, upd: 12;
  c2VQ:
      _s2n3::P32 = R1;
      I32[(young<c2VU> + 4)] = c2VU;
      P32[(young<c2VU> + 8)] = _s2n3::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2VU, args: 8, res: 4, upd: 12;
  c2VU:
      _s2n4::I32 = R1;
      _c2W1::I32 = %MO_S_Le_W32(0, _s2n4::I32);
      _s2n5::I32 = _c2W1::I32;
      if (_s2n5::I32 >= 1) goto c2Wu; else goto c2We;
  c2Wu:
      _c2W9::I32 = %MO_S_Lt_W32(_s2n4::I32, _s2mX::I32);
      _s2n8::I32 = _c2W9::I32;
      if (_s2n8::I32 >= 1) goto c2Wq; else goto c2We;
  c2Wq:
      _s2nc::P32 = P32[(_s2mY::P32 + 12) + (_s2n4::I32 << 2)];
      _s2nc::P32 = _s2nc::P32;
      I32[(young<c2Wh> + 4)] = c2Wh;
      R1 = _s2nc::P32;
      if (R1 & 3 != 0) goto c2Wh; else goto c2Wi;
  c2Wi:
      call (I32[R1])(R1) returns to c2Wh, args: 4, res: 4, upd: 12;
  c2Wh:
      _s2nd::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Wt; else goto c2Ws;
  c2Wt:
      HpAlloc = 12;
      goto c2Wr;
  c2Wr:
      R1 = _s2nd::P32;
      call stg_gc_unpt_r1(R1) returns to c2Wh, args: 4, res: 4, upd: 12;
  c2Ws:
      _s2ne::F64 = F64[_s2nd::P32 + 3];
      _c2Wm::F64 = %MO_F_Mul_W64(_s2mT::F64, _s2ne::F64);
      _s2nf::F64 = _c2Wm::F64;
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _s2nf::F64;
      _c2Wp::P32 = Hp - 7;
      R1 = _c2Wp::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2We:
      I32[(old + 20)] = _s2n4::I32;
      I32[(old + 16)] = _s2mX::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2VN:
      P32[(old + 24)] = _s2mV::P32;
      P32[(old + 20)] = _s2mW::P32;
      P32[(old + 16)] = _s2mx::P32;
      call poly_$w$j5_r2hM_info() args: 24, res: 0, upd: 12;
  c2Vf:
      I32[(old + 20)] = _s2mJ::I32;
      I32[(old + 16)] = _s2mC::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2UO:
      P32[(old + 24)] = _s2mA::P32;
      P32[(old + 20)] = _s2mB::P32;
      P32[(old + 16)] = _s2mx::P32;
      call poly_$w$j4_r2hK_info() args: 24, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2Uq:
      _s2ng::P32 = R1;
      goto c2Ul;
  c2Ul:
      if (Sp - <highSp> < SpLim) goto c2Uu; else goto c2Uv;
  c2Uu:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2Uv:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = R1;
      _s2mx::P32 = P32[R1 + 8];
      I32[(young<c2Un> + 4)] = c2Un;
      R1 = u_r2hH_closure;
      if (u_r2hH_closure & 3 != 0) goto c2Un; else goto c2Uo;
  c2Uo:
      call (I32[u_r2hH_closure])(R1) returns to c2Un, args: 4, res: 4, upd: 12;
  c2Un:
      _s2mz::P32 = R1;
      _s2mA::P32 = P32[R1 + 3];
      _s2mB::P32 = P32[R1 + 7];
      _s2mD::P32 = P32[R1 + 11];
      _s2mC::I32 = I32[R1 + 15];
      I32[(young<c2Ut> + 4)] = c2Ut;
      P32[(young<c2Ut> + 12)] = _s2mA::P32;
      P32[(young<c2Ut> + 8)] = _s2mx::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Ut, args: 12, res: 4, upd: 12;
  c2Ut:
      _s2mE::I32 = R1;
      if (R1 >= 1) goto c2UH; else goto c2UO;
  c2UH:
      I32[(young<c2UG> + 4)] = c2UG;
      P32[(young<c2UG> + 12)] = _s2mx::P32;
      P32[(young<c2UG> + 8)] = _s2mB::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2UG, args: 12, res: 4, upd: 12;
  c2UG:
      _s2mG::I32 = R1;
      if (R1 >= 1) goto c2UW; else goto c2UO;
  c2UW:
      I32[(young<c2UR> + 4)] = c2UR;
      P32[(young<c2UR> + 12)] = _s2mx::P32;
      P32[(young<c2UR> + 8)] = _s2mA::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2UR, args: 12, res: 4, upd: 12;
  c2UR:
      _s2mI::P32 = R1;
      I32[(young<c2UV> + 4)] = c2UV;
      P32[(young<c2UV> + 8)] = R1;
      call GHC.Integer.Type.integerToInt_info() returns to c2UV, args: 8, res: 4, upd: 12;
  c2UV:
      _s2mJ::I32 = R1;
      _c2V2::I32 = %MO_S_Le_W32(0, R1);
      _s2mK::I32 = _c2V2::I32;
      if (_c2V2::I32 >= 1) goto c2WH; else goto c2Vf;
  c2WH:
      _c2Va::I32 = %MO_S_Lt_W32(R1, _s2mC::I32);
      _s2mN::I32 = _c2Va::I32;
      if (_c2Va::I32 >= 1) goto c2Vt; else goto c2Vf;
  c2Vt:
      _s2mR::P32 = P32[(_s2mD::P32 + 12) + (R1 << 2)];
      _s2mR::P32 = _s2mR::P32;
      I32[(young<c2Vi> + 4)] = c2Vi;
      R1 = _s2mR::P32;
      if (_s2mR::P32 & 3 != 0) goto c2Vi; else goto c2Vj;
  c2Vj:
      call (I32[_s2mR::P32])(R1) returns to c2Vi, args: 4, res: 4, upd: 12;
  c2Vi:
      _s2mS::P32 = R1;
      _s2mT::F64 = F64[R1 + 3];
      I32[(young<c2Vn> + 4)] = c2Vn;
      R1 = Main.main_v_closure;
      if (Main.main_v_closure & 3 != 0) goto c2Vn; else goto c2Vo;
  c2Vo:
      call (I32[Main.main_v_closure])(R1) returns to c2Vn, args: 4, res: 4, upd: 12;
  c2Vn:
      _s2mU::P32 = R1;
      _s2mV::P32 = P32[R1 + 3];
      _s2mW::P32 = P32[R1 + 7];
      _s2mY::P32 = P32[R1 + 11];
      _s2mX::I32 = I32[R1 + 15];
      I32[(young<c2Vs> + 4)] = c2Vs;
      P32[(young<c2Vs> + 12)] = _s2mV::P32;
      P32[(young<c2Vs> + 8)] = _s2mx::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Vs, args: 12, res: 4, upd: 12;
  c2Vs:
      _s2mZ::I32 = R1;
      if (R1 >= 1) goto c2VG; else goto c2VN;
  c2VG:
      I32[(young<c2VF> + 4)] = c2VF;
      P32[(young<c2VF> + 12)] = _s2mx::P32;
      P32[(young<c2VF> + 8)] = _s2mW::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2VF, args: 12, res: 4, upd: 12;
  c2VF:
      _s2n1::I32 = R1;
      if (R1 >= 1) goto c2VV; else goto c2VN;
  c2VV:
      I32[(young<c2VQ> + 4)] = c2VQ;
      P32[(young<c2VQ> + 12)] = _s2mx::P32;
      P32[(young<c2VQ> + 8)] = _s2mV::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2VQ, args: 12, res: 4, upd: 12;
  c2VQ:
      _s2n3::P32 = R1;
      I32[(young<c2VU> + 4)] = c2VU;
      P32[(young<c2VU> + 8)] = R1;
      call GHC.Integer.Type.integerToInt_info() returns to c2VU, args: 8, res: 4, upd: 12;
  c2VU:
      _s2n4::I32 = R1;
      _c2W1::I32 = %MO_S_Le_W32(0, R1);
      _s2n5::I32 = _c2W1::I32;
      if (_c2W1::I32 >= 1) goto c2Wu; else goto c2We;
  c2Wu:
      _c2W9::I32 = %MO_S_Lt_W32(R1, _s2mX::I32);
      _s2n8::I32 = _c2W9::I32;
      if (_c2W9::I32 >= 1) goto c2Wq; else goto c2We;
  c2Wq:
      _s2nc::P32 = P32[(_s2mY::P32 + 12) + (R1 << 2)];
      _s2nc::P32 = _s2nc::P32;
      I32[(young<c2Wh> + 4)] = c2Wh;
      R1 = _s2nc::P32;
      if (_s2nc::P32 & 3 != 0) goto c2Wh; else goto c2Wi;
  c2Wi:
      call (I32[_s2nc::P32])(R1) returns to c2Wh, args: 4, res: 4, upd: 12;
  c2Wh:
      _s2nd::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Wt; else goto c2Ws;
  c2Wt:
      HpAlloc = 12;
      goto c2Wr;
  c2Wr:
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c2Wh, args: 4, res: 4, upd: 12;
  c2Ws:
      _s2ne::F64 = F64[R1 + 3];
      _c2Wm::F64 = %MO_F_Mul_W64(_s2mT::F64, _s2ne::F64);
      _s2nf::F64 = _c2Wm::F64;
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _c2Wm::F64;
      _c2Wp::P32 = Hp - 7;
      R1 = _c2Wp::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2We:
      I32[(old + 20)] = R1;
      I32[(old + 16)] = _s2mX::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2VN:
      P32[(old + 24)] = _s2mV::P32;
      P32[(old + 20)] = _s2mW::P32;
      P32[(old + 16)] = _s2mx::P32;
      call poly_$w$j5_r2hM_info() args: 24, res: 0, upd: 12;
  c2Vf:
      I32[(old + 20)] = R1;
      I32[(old + 16)] = _s2mC::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2UO:
      P32[(old + 24)] = _s2mA::P32;
      P32[(old + 20)] = _s2mB::P32;
      P32[(old + 16)] = _s2mx::P32;
      call poly_$w$j4_r2hK_info() args: 24, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2WV:
      _s2mx::P32 = P32[(old + 12)];
      _s2my::P32 = P32[(old + 8)];
      goto c2Uh;
  c2Uh:
      if (Sp - <highSp> < SpLim) goto c2WW; else goto c2WX;
  c2WX:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c2WZ; else goto c2WY;
  c2WZ:
      HpAlloc = 24;
      goto c2WW;
  c2WW:
      R1 = Main.main14_closure;
      P32[(old + 12)] = _s2mx::P32;
      P32[(old + 8)] = _s2my::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c2WY:
      I32[Hp - 20] = sat_s2ng_info;
      P32[Hp - 12] = _s2mx::P32;
      _c2Uj::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c2Uj::P32;
      P32[Hp] = _s2my::P32;
      _c2WU::P32 = Hp - 6;
      R1 = _c2WU::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2WV:
      _s2mx::P32 = P32[(old + 12)];
      _s2my::P32 = P32[(old + 8)];
      goto c2Uh;
  c2Uh:
      if (Sp - <highSp> < SpLim) goto c2WW; else goto c2WX;
  c2WX:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c2WZ; else goto c2WY;
  c2WZ:
      HpAlloc = 24;
      goto c2WW;
  c2WW:
      R1 = Main.main14_closure;
      P32[(old + 12)] = _s2mx::P32;
      P32[(old + 8)] = _s2my::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c2WY:
      I32[Hp - 20] = sat_s2ng_info;
      P32[Hp - 12] = _s2mx::P32;
      _c2Uj::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c2Uj::P32;
      P32[Hp] = _s2my::P32;
      _c2WU::P32 = Hp - 6;
      R1 = _c2WU::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2Xz:
      _r2ho::P32 = R1;
      goto c2Xu;
  c2Xu:
      if (Sp - <highSp> < SpLim) goto c2XA; else goto c2XB;
  c2XB:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2XD; else goto c2XC;
  c2XD:
      HpAlloc = 8;
      goto c2XA;
  c2XA:
      R1 = _r2ho::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2XC:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2Xw::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2ho::P32, Hp - 4);
      if (_c2Xw::I32 == 0) goto c2Xy; else goto c2Xx;
  c2Xy:
      call (I32[_r2ho::P32])() args: 4, res: 0, upd: 4;
  c2Xx:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 32)] = Main.main14_closure+2;
      P32[(old + 28)] = GHC.Types.[]_closure+1;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToIntegerFB_info() args: 32, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2Xz:
      _r2ho::P32 = R1;
      goto c2Xu;
  c2Xu:
      if (Sp - <highSp> < SpLim) goto c2XA; else goto c2XB;
  c2XB:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2XD; else goto c2XC;
  c2XD:
      HpAlloc = 8;
      goto c2XA;
  c2XA:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2XC:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2Xw::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2Xw::I32 == 0) goto c2Xy; else goto c2Xx;
  c2Xy:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2Xx:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 32)] = Main.main14_closure+2;
      P32[(old + 28)] = GHC.Types.[]_closure+1;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToIntegerFB_info() args: 32, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2Y9:
      _r2ha::P32 = R1;
      goto c2Y2;
  c2Y2:
      if (Sp - <highSp> < SpLim) goto c2Yd; else goto c2Ye;
  c2Ye:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2Yg; else goto c2Yf;
  c2Yg:
      HpAlloc = 8;
      goto c2Yd;
  c2Yd:
      R1 = _r2ha::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2Yf:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2Y4::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2ha::P32, Hp - 4);
      if (_c2Y4::I32 == 0) goto c2Y6; else goto c2Y5;
  c2Y6:
      call (I32[_r2ha::P32])() args: 4, res: 0, upd: 4;
  c2Y5:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c2Y7> + 4)] = c2Y7;
      P32[(young<c2Y7> + 16)] = Main.main13_closure;
      F64[(young<c2Y7> + 12)] = 0.0 :: W64;
      call Main.$wsum'1_info() returns to c2Y7, args: 16, res: 4, upd: 12;
  c2Y7:
      _s2nh::F64 = D1;
      I32[(young<c2Yc> + 4)] = c2Yc;
      P32[(young<c2Yc> + 16)] = Main.main3_closure;
      F64[(young<c2Yc> + 12)] = 0.0 :: W64;
      call Main.$wsum'1_info() returns to c2Yc, args: 16, res: 4, upd: 12;
  c2Yc:
      _s2ni::F64 = D1;
      _c2Ym::F64 = %MO_F_Quot_W64(_s2nh::F64, _s2ni::F64);
      _s2nj::F64 = _c2Ym::F64;
      _c2Yq::F64 = _s2nj::F64;
      (_c2Yp::F64) = call MO_F64_Sqrt(_c2Yq::F64);
      _s2nk::F64 = _c2Yp::F64;
      P32[(old + 36)] = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      P32[(old + 32)] = GHC.Show.shows25_closure;
      F64[(old + 28)] = _s2nk::F64;
      I32[(old + 20)] = stg_ap_p_info;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call GHC.Float.$w$sshowSignedFloat_info() args: 36, res: 0, upd: 12;
}



==================== Copy propagation ====================
{offset
  c2Y9:
      _r2ha::P32 = R1;
      goto c2Y2;
  c2Y2:
      if (Sp - <highSp> < SpLim) goto c2Yd; else goto c2Ye;
  c2Ye:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2Yg; else goto c2Yf;
  c2Yg:
      HpAlloc = 8;
      goto c2Yd;
  c2Yd:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2Yf:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2Y4::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, R1, Hp - 4);
      if (_c2Y4::I32 == 0) goto c2Y6; else goto c2Y5;
  c2Y6:
      call (I32[R1])() args: 4, res: 0, upd: 4;
  c2Y5:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c2Y7> + 4)] = c2Y7;
      P32[(young<c2Y7> + 16)] = Main.main13_closure;
      F64[(young<c2Y7> + 12)] = 0.0 :: W64;
      call Main.$wsum'1_info() returns to c2Y7, args: 16, res: 4, upd: 12;
  c2Y7:
      _s2nh::F64 = D1;
      I32[(young<c2Yc> + 4)] = c2Yc;
      P32[(young<c2Yc> + 16)] = Main.main3_closure;
      F64[(young<c2Yc> + 12)] = 0.0 :: W64;
      call Main.$wsum'1_info() returns to c2Yc, args: 16, res: 4, upd: 12;
  c2Yc:
      _s2ni::F64 = D1;
      _c2Ym::F64 = %MO_F_Quot_W64(_s2nh::F64, D1);
      _s2nj::F64 = _c2Ym::F64;
      _c2Yq::F64 = _c2Ym::F64;
      (_c2Yp::F64) = call MO_F64_Sqrt(_c2Ym::F64);
      _s2nk::F64 = _c2Yp::F64;
      P32[(old + 36)] = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      P32[(old + 32)] = GHC.Show.shows25_closure;
      F64[(old + 28)] = _c2Yp::F64;
      I32[(old + 20)] = stg_ap_p_info;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call GHC.Float.$w$sshowSignedFloat_info() args: 36, res: 0, upd: 12;
}



==================== Before copy propagation ====================
{offset
  c2YJ:
      if (Sp - <highSp> < SpLim) goto c2YM; else goto c2YN;
  c2YM:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2YN:
      P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
      P32[(old + 12)] = Main.main2_closure;
      P32[(old + 8)] = GHC.Types.True_closure+2;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2YJ:
      if (Sp - <highSp> < SpLim) goto c2YM; else goto c2YN;
  c2YM:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2YN:
      P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
      P32[(old + 12)] = Main.main2_closure;
      P32[(old + 8)] = GHC.Types.True_closure+2;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2YV:
      if (Sp - <highSp> < SpLim) goto c2YY; else goto c2YZ;
  c2YY:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2YZ:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2YV:
      if (Sp - <highSp> < SpLim) goto c2YY; else goto c2YZ;
  c2YY:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2YZ:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2Z6:
      if (Sp - <highSp> < SpLim) goto c2Z9; else goto c2Za;
  c2Z9:
      R1 = Main.main15_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2Za:
      P32[(old + 8)] = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2Z6:
      if (Sp - <highSp> < SpLim) goto c2Z9; else goto c2Za;
  c2Z9:
      R1 = Main.main15_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2Za:
      P32[(old + 8)] = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}



==================== Before copy propagation ====================
{offset
  c2Zi:
      if (Sp - <highSp> < SpLim) goto c2Zl; else goto c2Zm;
  c2Zl:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2Zm:
      call Main.main15_info() args: 4, res: 0, upd: 4;
}



==================== Copy propagation ====================
{offset
  c2Zi:
      if (Sp - <highSp> < SpLim) goto c2Zl; else goto c2Zm;
  c2Zl:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2Zm:
      call Main.main15_info() args: 4, res: 0, upd: 4;
}


Linking arr017 ...
