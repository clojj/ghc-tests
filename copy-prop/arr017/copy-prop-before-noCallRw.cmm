==================== Before copy propagation ====================
{offset
  c2nE:
      _r2h8::P32 = R1;
      _s2hQ::P32 = P32[(old + 16)];
      _s2hR::F64 = F64[(old + 12)];
      R1 = _r2h8::P32;
      P32[(old + 16)] = _s2hQ::P32;
      F64[(old + 12)] = _s2hR::F64;
      call Main.$wsum'1_info(R1) args: 16, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2nR:
      _s2hQ::P32 = P32[(old + 16)];
      _s2hR::F64 = F64[(old + 12)];
      goto c2nF;
  c2nF:
      if (Sp - <highSp> < SpLim) goto c2nS; else goto c2nT;
  c2nS:
      R1 = Main.$wsum'1_closure;
      P32[(old + 16)] = _s2hQ::P32;
      F64[(old + 12)] = _s2hR::F64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2nT:
      I32[(young<c2nH> + 4)] = c2nH;
      R1 = _s2hQ::P32;
      if (R1 & 3 != 0) goto c2nH; else goto c2nI;
  c2nI:
      call (I32[R1])(R1) returns to c2nH, args: 4, res: 4, upd: 4;
  c2nH:
      _s2hS::P32 = R1;
      _c2nN::P32 = _s2hS::P32 & 3;
      if (_c2nN::P32 >= 2) goto c2nM; else goto c2nL;
  c2nM:
      _s2hT::P32 = P32[_s2hS::P32 + 2];
      _s2hU::P32 = P32[_s2hS::P32 + 6];
      I32[(young<c2nZ> + 4)] = c2nZ;
      R1 = _s2hT::P32;
      if (R1 & 3 != 0) goto c2nZ; else goto c2o1;
  c2o1:
      call (I32[R1])(R1) returns to c2nZ, args: 4, res: 4, upd: 4;
  c2nZ:
      _s2hV::P32 = R1;
      _s2hW::F64 = F64[_s2hV::P32 + 3];
      _c2o6::F64 = %MO_F_Add_W64(_s2hR::F64, _s2hW::F64);
      _s2hX::F64 = _c2o6::F64;
      P32[(old + 16)] = _s2hU::P32;
      F64[(old + 12)] = _s2hX::F64;
      call Main.$wsum'1_info() args: 16, res: 0, upd: 4;
  c2nL:
      D1 = _s2hR::F64;
      call (P32[(old + 4)])(D1) args: 4, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2ox:
      _s2hY::P32 = P32[(old + 12)];
      _s2hZ::P32 = P32[(old + 8)];
      goto c2os;
  c2os:
      if (Sp - <highSp> < SpLim) goto c2oF; else goto c2oG;
  c2oF:
      R1 = Main.$ssum_sum'1_closure;
      P32[(old + 12)] = _s2hY::P32;
      P32[(old + 8)] = _s2hZ::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c2oG:
      I32[(young<c2ou> + 4)] = c2ou;
      R1 = _s2hZ::P32;
      if (R1 & 3 != 0) goto c2ou; else goto c2ov;
  c2ov:
      call (I32[R1])(R1) returns to c2ou, args: 4, res: 4, upd: 4;
  c2ou:
      _s2i0::P32 = R1;
      _s2i1::F64 = F64[_s2i0::P32 + 3];
      I32[(young<c2oA> + 4)] = c2oA;
      P32[(young<c2oA> + 16)] = _s2hY::P32;
      F64[(young<c2oA> + 12)] = _s2i1::F64;
      call Main.$wsum'1_info() returns to c2oA, args: 16, res: 4, upd: 4;
  c2oA:
      _s2i2::F64 = D1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2oK; else goto c2oJ;
  c2oK:
      HpAlloc = 12;
      goto c2oI;
  c2oI:
      D1 = _s2i2::F64;
      call stg_gc_d1(D1) returns to c2oA, args: 4, res: 4, upd: 4;
  c2oJ:
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _s2i2::F64;
      _c2oE::P32 = Hp - 7;
      R1 = _c2oE::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2p2:
      _s2i3::P32 = P32[(old + 8)];
      goto c2oY;
  c2oY:
      if (Sp - <highSp> < SpLim) goto c2p6; else goto c2p7;
  c2p6:
      R1 = Main.$ssum_closure;
      P32[(old + 8)] = _s2i3::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2p7:
      I32[(young<c2p0> + 4)] = c2p0;
      P32[(young<c2p0> + 16)] = _s2i3::P32;
      F64[(young<c2p0> + 12)] = 0.0 :: W64;
      call Main.$wsum'1_info() returns to c2p0, args: 16, res: 4, upd: 4;
  c2p0:
      _s2i4::F64 = D1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2pa; else goto c2p9;
  c2pa:
      HpAlloc = 12;
      goto c2p8;
  c2p8:
      D1 = _s2i4::F64;
      call stg_gc_d1(D1) returns to c2p0, args: 4, res: 4, upd: 4;
  c2p9:
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _s2i4::F64;
      _c2p5::P32 = Hp - 7;
      R1 = _c2p5::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2pt:
      _r2hj::P32 = R1;
      goto c2pn;
  c2pn:
      if (Sp - <highSp> < SpLim) goto c2pu; else goto c2pv;
  c2pv:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2px; else goto c2pw;
  c2px:
      HpAlloc = 8;
      goto c2pu;
  c2pu:
      R1 = _r2hj::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2pw:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2pp::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hj::P32, Hp - 4);
      if (_c2pp::I32 == 0) goto c2pr; else goto c2pq;
  c2pr:
      call (I32[_r2hj::P32])() args: 4, res: 0, upd: 4;
  c2pq:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = c2ps_str;
      call Control.Exception.Base.irrefutPatError_info() args: 16, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2pV:
      _r2hr::P32 = R1;
      goto c2pQ;
  c2pQ:
      if (Sp - <highSp> < SpLim) goto c2pW; else goto c2pX;
  c2pX:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2pZ; else goto c2pY;
  c2pZ:
      HpAlloc = 8;
      goto c2pW;
  c2pW:
      R1 = _r2hr::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2pY:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2pS::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hr::P32, Hp - 4);
      if (_c2pS::I32 == 0) goto c2pU; else goto c2pT;
  c2pU:
      call (I32[_r2hr::P32])() args: 4, res: 0, upd: 4;
  c2pT:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToInteger_info() args: 24, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2qf:
      _r2hs::P32 = R1;
      goto c2qa;
  c2qa:
      if (Sp - <highSp> < SpLim) goto c2qg; else goto c2qh;
  c2qh:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2qj; else goto c2qi;
  c2qj:
      HpAlloc = 8;
      goto c2qg;
  c2qg:
      R1 = _r2hs::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2qi:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2qc::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hs::P32, Hp - 4);
      if (_c2qc::I32 == 0) goto c2qe; else goto c2qd;
  c2qe:
      call (I32[_r2hs::P32])() args: 4, res: 0, upd: 4;
  c2qd:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToInteger_info() args: 24, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2qz:
      _r2ht::P32 = R1;
      goto c2qu;
  c2qu:
      if (Sp - <highSp> < SpLim) goto c2qA; else goto c2qB;
  c2qB:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2qD; else goto c2qC;
  c2qD:
      HpAlloc = 8;
      goto c2qA;
  c2qA:
      R1 = _r2ht::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2qC:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2qw::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2ht::P32, Hp - 4);
      if (_c2qw::I32 == 0) goto c2qy; else goto c2qx;
  c2qy:
      call (I32[_r2ht::P32])() args: 4, res: 0, upd: 4;
  c2qx:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToInteger_info() args: 24, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2qT:
      _r2hu::P32 = R1;
      goto c2qO;
  c2qO:
      if (Sp - <highSp> < SpLim) goto c2qU; else goto c2qV;
  c2qV:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2qX; else goto c2qW;
  c2qX:
      HpAlloc = 8;
      goto c2qU;
  c2qU:
      R1 = _r2hu::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2qW:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2qQ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hu::P32, Hp - 4);
      if (_c2qQ::I32 == 0) goto c2qS; else goto c2qR;
  c2qS:
      call (I32[_r2hu::P32])() args: 4, res: 0, upd: 4;
  c2qR:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToInteger_info() args: 24, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2rh:
      _r2hw::P32 = R1;
      goto c2rb;
  c2rb:
      if (Sp - <highSp> < SpLim) goto c2ri; else goto c2rj;
  c2rj:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2rl; else goto c2rk;
  c2rl:
      HpAlloc = 8;
      goto c2ri;
  c2ri:
      R1 = _r2hw::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2rk:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2rd::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hw::P32, Hp - 4);
      if (_c2rd::I32 == 0) goto c2rf; else goto c2re;
  c2rf:
      call (I32[_r2hw::P32])() args: 4, res: 0, upd: 4;
  c2re:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(old + 16)] = c2rg_str;
      call GHC.CString.unpackCString#_info() args: 16, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2rz:
      _s2i5::P32 = P32[(old + 8)];
      goto c2rx;
  c2rx:
      if (Sp - <highSp> < SpLim) goto c2rA; else goto c2rB;
  c2rA:
      R1 = lvl6_r2hx_closure;
      P32[(old + 8)] = _s2i5::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2rB:
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = lvl4_r2hv_closure+1;
      P32[(old + 12)] = _s2i5::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2rM:
      _s2i6::P32 = P32[(old + 8)];
      goto c2rK;
  c2rK:
      if (Sp - <highSp> < SpLim) goto c2rN; else goto c2rO;
  c2rN:
      R1 = poly_$w$j_r2hy_closure;
      P32[(old + 8)] = _s2i6::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2rO:
      P32[(old + 8)] = _s2i6::P32;
      call lvl6_r2hx_info() args: 8, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2rY:
      _s2i9::P32 = P32[(old + 16)];
      _s2ia::P32 = P32[(old + 12)];
      _s2ib::P32 = P32[(old + 8)];
      goto c2rV;
  c2rV:
      if (Sp - <highSp> < SpLim) goto c2rZ; else goto c2s0;
  c2s0:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2s2; else goto c2s1;
  c2s2:
      HpAlloc = 12;
      goto c2rZ;
  c2rZ:
      R1 = lvl7_r2hz_closure;
      P32[(old + 16)] = _s2i9::P32;
      P32[(old + 12)] = _s2ia::P32;
      P32[(old + 8)] = _s2ib::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2s1:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2ia::P32;
      P32[Hp] = _s2ib::P32;
      _c2rX::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2rX::P32;
      P32[(old + 12)] = _s2i9::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2sf:
      _s2id::P32 = P32[(old + 16)];
      _s2ie::P32 = P32[(old + 12)];
      _s2if::P32 = P32[(old + 8)];
      goto c2sd;
  c2sd:
      if (Sp - <highSp> < SpLim) goto c2sg; else goto c2sh;
  c2sg:
      R1 = poly_$w$j1_r2hA_closure;
      P32[(old + 16)] = _s2id::P32;
      P32[(old + 12)] = _s2ie::P32;
      P32[(old + 8)] = _s2if::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2sh:
      P32[(old + 16)] = _s2id::P32;
      P32[(old + 12)] = _s2ie::P32;
      P32[(old + 8)] = _s2if::P32;
      call lvl7_r2hz_info() args: 16, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2st:
      _s2ii::P32 = P32[(old + 8)];
      goto c2sr;
  c2sr:
      if (Sp - <highSp> < SpLim) goto c2su; else goto c2sv;
  c2su:
      R1 = lvl9_r2hC_closure;
      P32[(old + 8)] = _s2ii::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2sv:
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = lvl8_r2hB_closure+1;
      P32[(old + 12)] = _s2ii::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2sG:
      _s2ij::P32 = P32[(old + 8)];
      goto c2sE;
  c2sE:
      if (Sp - <highSp> < SpLim) goto c2sH; else goto c2sI;
  c2sH:
      R1 = poly_$w$j2_r2hD_closure;
      P32[(old + 8)] = _s2ij::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2sI:
      P32[(old + 8)] = _s2ij::P32;
      call lvl9_r2hC_info() args: 8, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2sS:
      _s2im::P32 = P32[(old + 16)];
      _s2in::P32 = P32[(old + 12)];
      _s2io::P32 = P32[(old + 8)];
      goto c2sP;
  c2sP:
      if (Sp - <highSp> < SpLim) goto c2sT; else goto c2sU;
  c2sU:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2sW; else goto c2sV;
  c2sW:
      HpAlloc = 12;
      goto c2sT;
  c2sT:
      R1 = lvl10_r2hE_closure;
      P32[(old + 16)] = _s2im::P32;
      P32[(old + 12)] = _s2in::P32;
      P32[(old + 8)] = _s2io::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2sV:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2in::P32;
      P32[Hp] = _s2io::P32;
      _c2sR::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2sR::P32;
      P32[(old + 12)] = _s2im::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2t9:
      _s2iq::P32 = P32[(old + 16)];
      _s2ir::P32 = P32[(old + 12)];
      _s2is::P32 = P32[(old + 8)];
      goto c2t7;
  c2t7:
      if (Sp - <highSp> < SpLim) goto c2ta; else goto c2tb;
  c2ta:
      R1 = poly_$w$j3_r2hF_closure;
      P32[(old + 16)] = _s2iq::P32;
      P32[(old + 12)] = _s2ir::P32;
      P32[(old + 8)] = _s2is::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2tb:
      P32[(old + 16)] = _s2iq::P32;
      P32[(old + 12)] = _s2ir::P32;
      P32[(old + 8)] = _s2is::P32;
      call lvl10_r2hE_info() args: 16, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2yK:
      _s2iV::P32 = R1;
      goto c2yI;
  c2yI:
      if (Sp - <highSp> < SpLim) goto c2yL; else goto c2yM;
  c2yL:
      R1 = _s2iV::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2yM:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2iV::P32;
      _s2iT::P32 = P32[_s2iV::P32 + 8];
      P32[(old + 20)] = _s2iT::P32;
      P32[(old + 16)] = Main.main5_closure+1;
      call GHC.Integer.Type.minusInteger_info() args: 20, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2zz:
      _s2jP::P32 = R1;
      goto c2zu;
  c2zu:
      if (Sp - <highSp> < SpLim) goto c2zQ; else goto c2zR;
  c2zQ:
      R1 = _s2jP::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2zR:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2jP::P32;
      _s2iv::P32 = P32[_s2jP::P32 + 8];
      _s2iT::P32 = P32[_s2jP::P32 + 12];
      _s2j0::P32 = P32[_s2jP::P32 + 16];
      _s2jf::P32 = P32[_s2jP::P32 + 20];
      I32[(young<c2zw> + 4)] = c2zw;
      R1 = _s2jf::P32;
      if (R1 & 3 != 0) goto c2zw; else goto c2zx;
  c2zx:
      call (I32[R1])(R1) returns to c2zw, args: 4, res: 4, upd: 12;
  c2zw:
      _s2jg::P32 = R1;
      _s2jh::F64 = F64[_s2jg::P32 + 3];
      I32[(young<c2zC> + 4)] = c2zC;
      P32[(young<c2zC> + 8)] = _s2iT::P32;
      call GHC.Integer.Type.doubleFromInteger_info() returns to c2zC, args: 8, res: 4, upd: 12;
  c2zC:
      _s2ji::F64 = D1;
      I32[(young<c2zG> + 4)] = c2zG;
      P32[(young<c2zG> + 8)] = _s2j0::P32;
      call GHC.Integer.Type.doubleFromInteger_info() returns to c2zG, args: 8, res: 4, upd: 12;
  c2zG:
      _s2jj::F64 = D1;
      I32[(young<c2zK> + 4)] = c2zK;
      R1 = _s2iv::P32;
      if (R1 & 3 != 0) goto c2zK; else goto c2zL;
  c2zL:
      call (I32[R1])(R1) returns to c2zK, args: 4, res: 4, upd: 12;
  c2zK:
      _s2jk::P32 = R1;
      _s2jl::P32 = P32[_s2jk::P32 + 3];
      _s2jm::P32 = P32[_s2jk::P32 + 7];
      _s2jo::P32 = P32[_s2jk::P32 + 11];
      _s2jn::I32 = I32[_s2jk::P32 + 15];
      I32[(young<c2zP> + 4)] = c2zP;
      P32[(young<c2zP> + 12)] = _s2jl::P32;
      P32[(young<c2zP> + 8)] = _s2j0::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2zP, args: 12, res: 4, upd: 12;
  c2zP:
      _s2jp::I32 = R1;
      if (_s2jp::I32 >= 1) goto c2A6; else goto c2Ad;
  c2A6:
      I32[(young<c2A5> + 4)] = c2A5;
      P32[(young<c2A5> + 12)] = _s2j0::P32;
      P32[(young<c2A5> + 8)] = _s2jm::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2A5, args: 12, res: 4, upd: 12;
  c2A5:
      _s2jr::I32 = R1;
      if (_s2jr::I32 >= 1) goto c2Al; else goto c2Ad;
  c2Al:
      I32[(young<c2Ag> + 4)] = c2Ag;
      P32[(young<c2Ag> + 12)] = _s2j0::P32;
      P32[(young<c2Ag> + 8)] = _s2jl::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2Ag, args: 12, res: 4, upd: 12;
  c2Ag:
      _s2jt::P32 = R1;
      I32[(young<c2Ak> + 4)] = c2Ak;
      P32[(young<c2Ak> + 8)] = _s2jt::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2Ak, args: 8, res: 4, upd: 12;
  c2Ak:
      _s2ju::I32 = R1;
      _c2Ar::I32 = %MO_S_Le_W32(0, _s2ju::I32);
      _s2jv::I32 = _c2Ar::I32;
      if (_s2jv::I32 >= 1) goto c2Bl; else goto c2AE;
  c2Bl:
      _c2Az::I32 = %MO_S_Lt_W32(_s2ju::I32, _s2jn::I32);
      _s2jy::I32 = _c2Az::I32;
      if (_s2jy::I32 >= 1) goto c2Bh; else goto c2AE;
  c2Bh:
      _s2jC::P32 = P32[(_s2jo::P32 + 12) + (_s2ju::I32 << 2)];
      _s2jC::P32 = _s2jC::P32;
      I32[(young<c2AH> + 4)] = c2AH;
      R1 = _s2jC::P32;
      if (R1 & 3 != 0) goto c2AH; else goto c2AI;
  c2AI:
      call (I32[R1])(R1) returns to c2AH, args: 4, res: 4, upd: 12;
  c2AH:
      _s2jD::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Bk; else goto c2Bj;
  c2Bk:
      HpAlloc = 12;
      goto c2Bi;
  c2Bi:
      R1 = _s2jD::P32;
      call stg_gc_unpt_r1(R1) returns to c2AH, args: 4, res: 4, upd: 12;
  c2Bj:
      _s2jE::F64 = F64[_s2jD::P32 + 3];
      _c2AM::F64 = %MO_F_Add_W64(_s2ji::F64, _s2jj::F64);
      _s2jG::F64 = _c2AM::F64;
      _c2AP::F64 = %MO_F_Add_W64(_s2jG::F64, 1.0 :: W64);
      _s2jH::F64 = _c2AP::F64;
      _c2AS::F64 = %MO_F_Add_W64(_s2ji::F64, _s2jj::F64);
      _s2jF::F64 = _c2AS::F64;
      _c2AV::F64 = %MO_F_Mul_W64(_s2jF::F64, _s2jH::F64);
      _s2jI::F64 = _c2AV::F64;
      _c2AY::F64 = %MO_F_Quot_W64(_s2jI::F64, 2.0 :: W64);
      _s2jJ::F64 = _c2AY::F64;
      _c2B1::F64 = %MO_F_Add_W64(_s2jJ::F64, _s2ji::F64);
      _s2jK::F64 = _c2B1::F64;
      _c2B4::F64 = %MO_F_Add_W64(_s2jK::F64, 1.0 :: W64);
      _s2jL::F64 = _c2B4::F64;
      _c2B7::F64 = %MO_F_Quot_W64(1.0 :: W64, _s2jL::F64);
      _s2jM::F64 = _c2B7::F64;
      _c2Ba::F64 = %MO_F_Mul_W64(_s2jM::F64, _s2jE::F64);
      _s2jN::F64 = _c2Ba::F64;
      _c2Bd::F64 = %MO_F_Add_W64(_s2jh::F64, _s2jN::F64);
      _s2jO::F64 = _c2Bd::F64;
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _s2jO::F64;
      _c2Bg::P32 = Hp - 7;
      R1 = _c2Bg::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2AE:
      I32[(old + 20)] = _s2ju::I32;
      I32[(old + 16)] = _s2jn::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2Ad:
      P32[(old + 24)] = _s2j0::P32;
      P32[(old + 20)] = _s2jl::P32;
      P32[(old + 16)] = _s2jm::P32;
      call poly_$w$j1_r2hA_info() args: 24, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2By:
      _s2jR::P32 = R1;
      goto c2yr;
  c2yr:
      if (Sp - <highSp> < SpLim) goto c2Bz; else goto c2BA;
  c2Bz:
      R1 = _s2jR::P32;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2BA:
      _s2iv::P32 = P32[_s2jR::P32 + 3];
      _s2iE::I32 = I32[_s2jR::P32 + 7];
      I32[(young<c2yt> + 4)] = c2yt;
      R1 = _s2iE::I32;
      P32[(young<c2yt> + 8)] = Main.$ssum1_closure+1;
      call stg_newArray#(R1) returns to c2yt, args: 8, res: 4, upd: 4;
  c2yt:
      _s2iK::P32 = R1;
      _s2iM::P32 = lvl1_r2hs_closure;
      goto c2yy;
  c2yy:
      I32[(young<c2yA> + 4)] = c2yA;
      R1 = _s2iM::P32;
      if (R1 & 3 != 0) goto c2yA; else goto c2yB;
  c2yB:
      call (I32[R1])(R1) returns to c2yA, args: 4, res: 4, upd: 4;
  c2yA:
      _s2iO::P32 = R1;
      _c2Cs::P32 = _s2iO::P32 & 3;
      if (_c2Cs::P32 >= 2) goto c2BK; else goto c2BG;
  c2BK:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2BN; else goto c2BM;
  c2BN:
      HpAlloc = 12;
      goto c2BL;
  c2BM:
      _s2iT::P32 = P32[_s2iO::P32 + 2];
      _s2iU::P32 = P32[_s2iO::P32 + 6];
      I32[Hp - 8] = lvl14_s2iV_info;
      P32[Hp] = _s2iT::P32;
      _c2yG::P32 = Hp - 8;
      _s2iX::P32 = lvl_r2hr_closure;
      goto c2yQ;
  c2yQ:
      I32[(young<c2yS> + 4)] = c2yS;
      R1 = _s2iX::P32;
      if (R1 & 3 != 0) goto c2yS; else goto c2yT;
  c2yT:
      call (I32[R1])(R1) returns to c2yS, args: 4, res: 4, upd: 4;
  c2yS:
      _s2iZ::P32 = R1;
      _c2Co::P32 = _s2iZ::P32 & 3;
      if (_c2Co::P32 >= 2) goto c2BU; else goto c2BS;
  c2BU:
      _s2j0::P32 = P32[_s2iZ::P32 + 2];
      _s2j1::P32 = P32[_s2iZ::P32 + 6];
      I32[(young<c2yY> + 4)] = c2yY;
      P32[(young<c2yY> + 12)] = Main.main5_closure+1;
      P32[(young<c2yY> + 8)] = _s2iT::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2yY, args: 12, res: 4, upd: 4;
  c2yY:
      _s2j2::I32 = R1;
      if (_s2j2::I32 >= 1) goto c2BY; else goto c2C1;
  c2BY:
      I32[(young<c2z5> + 4)] = c2z5;
      P32[(young<c2z5> + 12)] = _s2iT::P32;
      P32[(young<c2z5> + 8)] = Main.main_n_closure+1;
      call GHC.Integer.Type.leInteger#_info() returns to c2z5, args: 12, res: 4, upd: 4;
  c2z5:
      _s2j4::I32 = R1;
      if (_s2j4::I32 >= 1) goto c2C2; else goto c2C1;
  c2C2:
      I32[(young<c2zc> + 4)] = c2zc;
      P32[(young<c2zc> + 8)] = _c2yG::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2zc, args: 8, res: 4, upd: 4;
  c2zc:
      _s2j6::I32 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c2C5; else goto c2C4;
  c2C5:
      HpAlloc = 24;
      goto c2C3;
  c2C3:
      R1 = _s2j6::I32;
      call stg_gc_unbx_r1(R1) returns to c2zc, args: 4, res: 4, upd: 4;
  c2C4:
      _c2zg::I32 = %MO_S_Le_W32(0, _s2j6::I32);
      _s2j7::I32 = _c2zg::I32;
      if (_s2j7::I32 >= 1) goto c2Cb; else goto c2C9;
  c2Cb:
      _c2zm::I32 = %MO_S_Lt_W32(_s2j6::I32, _s2iE::I32);
      _s2ja::I32 = _c2zm::I32;
      if (_s2ja::I32 >= 1) goto c2Ca; else goto c2C9;
  c2Ca:
      _s2jf::P32 = P32[(_s2iK::P32 + 12) + (_s2j6::I32 << 2)];
      _s2jf::P32 = _s2jf::P32;
      I32[Hp - 20] = sat_s2jP_info;
      P32[Hp - 12] = _s2iv::P32;
      P32[Hp - 8] = _s2iT::P32;
      P32[Hp - 4] = _s2j0::P32;
      P32[Hp] = _s2jf::P32;
      _c2zs::P32 = Hp - 20;
      P32[(_s2iK::P32 + 12) + (_s2j6::I32 << 2)] = _c2zs::P32;
      I32[_s2iK::P32] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_s2iK::P32 + 12) + (I32[_s2iK::P32 + 4] << 2) + (_s2j6::I32 >> 7)] = 1 :: W8;
      _s2iX::P32 = _s2j1::P32;
      goto c2yQ;
  c2C9:
      Hp = Hp - 24;
      I32[(old + 12)] = _s2j6::I32;
      I32[(old + 8)] = _s2iE::I32;
      call GHC.Arr.badSafeIndex1_info() args: 12, res: 0, upd: 4;
  c2C1:
      P32[(old + 8)] = _s2iT::P32;
      call poly_$w$j_r2hy_info() args: 8, res: 0, upd: 4;
  c2BS:
      _s2iM::P32 = _s2iU::P32;
      goto c2yy;
  c2BG:
      Hp = Hp + 20;
      if (Hp > HpLim) goto c2BJ; else goto c2BI;
  c2BJ:
      HpAlloc = 20;
      goto c2BL;
  c2BL:
      R1 = _s2iO::P32;
      call stg_gc_unpt_r1(R1) returns to c2yA, args: 4, res: 4, upd: 4;
  c2BI:
      I32[_s2iK::P32] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _s2iR::P32 = _s2iK::P32;
      _s2iR::P32 = _s2iR::P32;
      I32[Hp - 16] = GHC.Arr.Array_con_info;
      P32[Hp - 12] = Main.main5_closure+1;
      P32[Hp - 8] = Main.main_n_closure+1;
      P32[Hp - 4] = _s2iR::P32;
      I32[Hp] = _s2iE::I32;
      _c2BE::P32 = Hp - 15;
      R1 = _c2BE::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2Cy:
      _s2iD::P32 = R1;
      goto c2ye;
  c2ye:
      if (Sp - <highSp> < SpLim) goto c2Cz; else goto c2CA;
  c2Cz:
      R1 = _s2iD::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2CA:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2iD::P32;
      _s2iv::P32 = P32[_s2iD::P32 + 8];
      I32[(young<c2yg> + 4)] = c2yg;
      P32[(young<c2yg> + 12)] = Main.main5_closure+1;
      P32[(young<c2yg> + 8)] = Main.main_n_closure+1;
      call GHC.Arr.$w$crangeSize5_info() returns to c2yg, args: 12, res: 4, upd: 12;
  c2yg:
      _s2iE::I32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2CD; else goto c2CC;
  c2CD:
      HpAlloc = 12;
      goto c2CB;
  c2CB:
      R1 = _s2iE::I32;
      call stg_gc_unbx_r1(R1) returns to c2yg, args: 4, res: 4, upd: 12;
  c2CC:
      _c2yk::I32 = %MO_S_Lt_W32(_s2iE::I32, 0);
      _s2iF::I32 = _c2yk::I32;
      if (_s2iF::I32 >= 1) goto c2CG; else goto c2CF;
  c2CG:
      Hp = Hp - 12;
      R1 = GHC.Arr.negRange_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
  c2CF:
      I32[Hp - 8] = sat_s2jR_info;
      P32[Hp - 4] = _s2iv::P32;
      I32[Hp] = _s2iE::I32;
      _c2yp::P32 = Hp - 7;
      P32[(old + 16)] = _c2yp::P32;
      call GHC.ST.runSTRep_info() args: 16, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2CZ:
      _s2k3::P32 = R1;
      goto c2CX;
  c2CX:
      if (Sp - <highSp> < SpLim) goto c2D0; else goto c2D1;
  c2D0:
      R1 = _s2k3::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2D1:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2k3::P32;
      _s2k1::P32 = P32[_s2k3::P32 + 8];
      P32[(old + 20)] = _s2k1::P32;
      P32[(old + 16)] = Main.main5_closure+1;
      call GHC.Integer.Type.minusInteger_info() args: 20, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2DO:
      _s2kX::P32 = R1;
      goto c2DJ;
  c2DJ:
      if (Sp - <highSp> < SpLim) goto c2E5; else goto c2E6;
  c2E5:
      R1 = _s2kX::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2E6:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2kX::P32;
      _s2iD::P32 = P32[_s2kX::P32 + 8];
      _s2k1::P32 = P32[_s2kX::P32 + 12];
      _s2k8::P32 = P32[_s2kX::P32 + 16];
      _s2kn::P32 = P32[_s2kX::P32 + 20];
      I32[(young<c2DL> + 4)] = c2DL;
      R1 = _s2kn::P32;
      if (R1 & 3 != 0) goto c2DL; else goto c2DM;
  c2DM:
      call (I32[R1])(R1) returns to c2DL, args: 4, res: 4, upd: 12;
  c2DL:
      _s2ko::P32 = R1;
      _s2kp::F64 = F64[_s2ko::P32 + 3];
      I32[(young<c2DR> + 4)] = c2DR;
      P32[(young<c2DR> + 8)] = _s2k8::P32;
      call GHC.Integer.Type.doubleFromInteger_info() returns to c2DR, args: 8, res: 4, upd: 12;
  c2DR:
      _s2kq::F64 = D1;
      I32[(young<c2DV> + 4)] = c2DV;
      P32[(young<c2DV> + 8)] = _s2k1::P32;
      call GHC.Integer.Type.doubleFromInteger_info() returns to c2DV, args: 8, res: 4, upd: 12;
  c2DV:
      _s2kr::F64 = D1;
      I32[(young<c2DZ> + 4)] = c2DZ;
      R1 = _s2iD::P32;
      if (R1 & 3 != 0) goto c2DZ; else goto c2E0;
  c2E0:
      call (I32[R1])(R1) returns to c2DZ, args: 4, res: 4, upd: 12;
  c2DZ:
      _s2ks::P32 = R1;
      _s2kt::P32 = P32[_s2ks::P32 + 3];
      _s2ku::P32 = P32[_s2ks::P32 + 7];
      _s2kw::P32 = P32[_s2ks::P32 + 11];
      _s2kv::I32 = I32[_s2ks::P32 + 15];
      I32[(young<c2E4> + 4)] = c2E4;
      P32[(young<c2E4> + 12)] = _s2kt::P32;
      P32[(young<c2E4> + 8)] = _s2k8::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2E4, args: 12, res: 4, upd: 12;
  c2E4:
      _s2kx::I32 = R1;
      if (_s2kx::I32 >= 1) goto c2El; else goto c2Es;
  c2El:
      I32[(young<c2Ek> + 4)] = c2Ek;
      P32[(young<c2Ek> + 12)] = _s2k8::P32;
      P32[(young<c2Ek> + 8)] = _s2ku::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Ek, args: 12, res: 4, upd: 12;
  c2Ek:
      _s2kz::I32 = R1;
      if (_s2kz::I32 >= 1) goto c2EA; else goto c2Es;
  c2EA:
      I32[(young<c2Ev> + 4)] = c2Ev;
      P32[(young<c2Ev> + 12)] = _s2k8::P32;
      P32[(young<c2Ev> + 8)] = _s2kt::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2Ev, args: 12, res: 4, upd: 12;
  c2Ev:
      _s2kB::P32 = R1;
      I32[(young<c2Ez> + 4)] = c2Ez;
      P32[(young<c2Ez> + 8)] = _s2kB::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2Ez, args: 8, res: 4, upd: 12;
  c2Ez:
      _s2kC::I32 = R1;
      _c2EG::I32 = %MO_S_Le_W32(0, _s2kC::I32);
      _s2kD::I32 = _c2EG::I32;
      if (_s2kD::I32 >= 1) goto c2FA; else goto c2ET;
  c2FA:
      _c2EO::I32 = %MO_S_Lt_W32(_s2kC::I32, _s2kv::I32);
      _s2kG::I32 = _c2EO::I32;
      if (_s2kG::I32 >= 1) goto c2Fw; else goto c2ET;
  c2Fw:
      _s2kK::P32 = P32[(_s2kw::P32 + 12) + (_s2kC::I32 << 2)];
      _s2kK::P32 = _s2kK::P32;
      I32[(young<c2EW> + 4)] = c2EW;
      R1 = _s2kK::P32;
      if (R1 & 3 != 0) goto c2EW; else goto c2EX;
  c2EX:
      call (I32[R1])(R1) returns to c2EW, args: 4, res: 4, upd: 12;
  c2EW:
      _s2kL::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Fz; else goto c2Fy;
  c2Fz:
      HpAlloc = 12;
      goto c2Fx;
  c2Fx:
      R1 = _s2kL::P32;
      call stg_gc_unpt_r1(R1) returns to c2EW, args: 4, res: 4, upd: 12;
  c2Fy:
      _s2kM::F64 = F64[_s2kL::P32 + 3];
      _c2F1::F64 = %MO_F_Add_W64(_s2kq::F64, _s2kr::F64);
      _s2kO::F64 = _c2F1::F64;
      _c2F4::F64 = %MO_F_Add_W64(_s2kO::F64, 1.0 :: W64);
      _s2kP::F64 = _c2F4::F64;
      _c2F7::F64 = %MO_F_Add_W64(_s2kq::F64, _s2kr::F64);
      _s2kN::F64 = _c2F7::F64;
      _c2Fa::F64 = %MO_F_Mul_W64(_s2kN::F64, _s2kP::F64);
      _s2kQ::F64 = _c2Fa::F64;
      _c2Fd::F64 = %MO_F_Quot_W64(_s2kQ::F64, 2.0 :: W64);
      _s2kR::F64 = _c2Fd::F64;
      _c2Fg::F64 = %MO_F_Add_W64(_s2kR::F64, _s2kq::F64);
      _s2kS::F64 = _c2Fg::F64;
      _c2Fj::F64 = %MO_F_Add_W64(_s2kS::F64, 1.0 :: W64);
      _s2kT::F64 = _c2Fj::F64;
      _c2Fm::F64 = %MO_F_Quot_W64(1.0 :: W64, _s2kT::F64);
      _s2kU::F64 = _c2Fm::F64;
      _c2Fp::F64 = %MO_F_Mul_W64(_s2kU::F64, _s2kM::F64);
      _s2kV::F64 = _c2Fp::F64;
      _c2Fs::F64 = %MO_F_Add_W64(_s2kp::F64, _s2kV::F64);
      _s2kW::F64 = _c2Fs::F64;
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _s2kW::F64;
      _c2Fv::P32 = Hp - 7;
      R1 = _c2Fv::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2ET:
      I32[(old + 20)] = _s2kC::I32;
      I32[(old + 16)] = _s2kv::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2Es:
      P32[(old + 24)] = _s2k8::P32;
      P32[(old + 20)] = _s2kt::P32;
      P32[(old + 16)] = _s2ku::P32;
      call poly_$w$j3_r2hF_info() args: 24, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2FN:
      _s2kZ::P32 = R1;
      goto c2y8;
  c2y8:
      if (Sp - <highSp> < SpLim) goto c2FO; else goto c2FP;
  c2FO:
      R1 = _s2kZ::P32;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2FP:
      _s2iv::P32 = P32[_s2kZ::P32 + 3];
      _s2iw::I32 = I32[_s2kZ::P32 + 7];
      I32[(young<c2ya> + 4)] = c2ya;
      R1 = _s2iw::I32;
      P32[(young<c2ya> + 8)] = Main.$ssum1_closure+1;
      call stg_newArray#(R1) returns to c2ya, args: 8, res: 4, upd: 4;
  c2ya:
      _s2iC::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2FS; else goto c2FR;
  c2FS:
      HpAlloc = 12;
      goto c2FQ;
  c2FQ:
      R1 = _s2iC::P32;
      call stg_gc_unpt_r1(R1) returns to c2ya, args: 4, res: 4, upd: 4;
  c2FR:
      I32[Hp - 8] = u2_s2iD_info;
      P32[Hp] = _s2iv::P32;
      _c2yc::P32 = Hp - 8;
      _s2jU::P32 = lvl3_r2hu_closure;
      goto c2CN;
  c2CN:
      I32[(young<c2CP> + 4)] = c2CP;
      R1 = _s2jU::P32;
      if (R1 & 3 != 0) goto c2CP; else goto c2CQ;
  c2CQ:
      call (I32[R1])(R1) returns to c2CP, args: 4, res: 4, upd: 4;
  c2CP:
      _s2jW::P32 = R1;
      _c2GJ::P32 = _s2jW::P32 & 3;
      if (_c2GJ::P32 >= 2) goto c2G1; else goto c2FX;
  c2G1:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2G4; else goto c2G3;
  c2G4:
      HpAlloc = 12;
      goto c2G2;
  c2G3:
      _s2k1::P32 = P32[_s2jW::P32 + 2];
      _s2k2::P32 = P32[_s2jW::P32 + 6];
      I32[Hp - 8] = lvl14_s2k3_info;
      P32[Hp] = _s2k1::P32;
      _c2CV::P32 = Hp - 8;
      _s2k5::P32 = lvl2_r2ht_closure;
      goto c2D5;
  c2D5:
      I32[(young<c2D7> + 4)] = c2D7;
      R1 = _s2k5::P32;
      if (R1 & 3 != 0) goto c2D7; else goto c2D8;
  c2D8:
      call (I32[R1])(R1) returns to c2D7, args: 4, res: 4, upd: 4;
  c2D7:
      _s2k7::P32 = R1;
      _c2GF::P32 = _s2k7::P32 & 3;
      if (_c2GF::P32 >= 2) goto c2Gb; else goto c2G9;
  c2Gb:
      _s2k8::P32 = P32[_s2k7::P32 + 2];
      _s2k9::P32 = P32[_s2k7::P32 + 6];
      I32[(young<c2Dd> + 4)] = c2Dd;
      P32[(young<c2Dd> + 12)] = Main.main5_closure+1;
      P32[(young<c2Dd> + 8)] = _s2k1::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Dd, args: 12, res: 4, upd: 4;
  c2Dd:
      _s2ka::I32 = R1;
      if (_s2ka::I32 >= 1) goto c2Gf; else goto c2Gi;
  c2Gf:
      I32[(young<c2Dk> + 4)] = c2Dk;
      P32[(young<c2Dk> + 12)] = _s2k1::P32;
      P32[(young<c2Dk> + 8)] = Main.main_n_closure+1;
      call GHC.Integer.Type.leInteger#_info() returns to c2Dk, args: 12, res: 4, upd: 4;
  c2Dk:
      _s2kc::I32 = R1;
      if (_s2kc::I32 >= 1) goto c2Gj; else goto c2Gi;
  c2Gj:
      I32[(young<c2Dr> + 4)] = c2Dr;
      P32[(young<c2Dr> + 8)] = _c2CV::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2Dr, args: 8, res: 4, upd: 4;
  c2Dr:
      _s2ke::I32 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c2Gm; else goto c2Gl;
  c2Gm:
      HpAlloc = 24;
      goto c2Gk;
  c2Gk:
      R1 = _s2ke::I32;
      call stg_gc_unbx_r1(R1) returns to c2Dr, args: 4, res: 4, upd: 4;
  c2Gl:
      _c2Dv::I32 = %MO_S_Le_W32(0, _s2ke::I32);
      _s2kf::I32 = _c2Dv::I32;
      if (_s2kf::I32 >= 1) goto c2Gs; else goto c2Gq;
  c2Gs:
      _c2DB::I32 = %MO_S_Lt_W32(_s2ke::I32, _s2iw::I32);
      _s2ki::I32 = _c2DB::I32;
      if (_s2ki::I32 >= 1) goto c2Gr; else goto c2Gq;
  c2Gr:
      _s2kn::P32 = P32[(_s2iC::P32 + 12) + (_s2ke::I32 << 2)];
      _s2kn::P32 = _s2kn::P32;
      I32[Hp - 20] = sat_s2kX_info;
      P32[Hp - 12] = _c2yc::P32;
      P32[Hp - 8] = _s2k1::P32;
      P32[Hp - 4] = _s2k8::P32;
      P32[Hp] = _s2kn::P32;
      _c2DH::P32 = Hp - 20;
      P32[(_s2iC::P32 + 12) + (_s2ke::I32 << 2)] = _c2DH::P32;
      I32[_s2iC::P32] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_s2iC::P32 + 12) + (I32[_s2iC::P32 + 4] << 2) + (_s2ke::I32 >> 7)] = 1 :: W8;
      _s2k5::P32 = _s2k9::P32;
      goto c2D5;
  c2Gq:
      Hp = Hp - 24;
      I32[(old + 12)] = _s2ke::I32;
      I32[(old + 8)] = _s2iw::I32;
      call GHC.Arr.badSafeIndex1_info() args: 12, res: 0, upd: 4;
  c2Gi:
      P32[(old + 8)] = _s2k1::P32;
      call poly_$w$j2_r2hD_info() args: 8, res: 0, upd: 4;
  c2G9:
      _s2jU::P32 = _s2k2::P32;
      goto c2CN;
  c2FX:
      Hp = Hp + 20;
      if (Hp > HpLim) goto c2G0; else goto c2FZ;
  c2G0:
      HpAlloc = 20;
      goto c2G2;
  c2G2:
      R1 = _s2jW::P32;
      call stg_gc_unpt_r1(R1) returns to c2CP, args: 4, res: 4, upd: 4;
  c2FZ:
      I32[_s2iC::P32] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _s2jZ::P32 = _s2iC::P32;
      _s2jZ::P32 = _s2jZ::P32;
      I32[Hp - 16] = GHC.Arr.Array_con_info;
      P32[Hp - 12] = Main.main5_closure+1;
      P32[Hp - 8] = Main.main_n_closure+1;
      P32[Hp - 4] = _s2jZ::P32;
      I32[Hp] = _s2iw::I32;
      _c2FV::P32 = Hp - 15;
      R1 = _c2FV::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2GP:
      _s2iv::P32 = P32[(old + 8)];
      goto c2xV;
  c2xV:
      if (Sp - <highSp> < SpLim) goto c2GQ; else goto c2GR;
  c2GQ:
      R1 = Main.main12_closure;
      P32[(old + 8)] = _s2iv::P32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c2GR:
      I32[(young<c2xX> + 4)] = c2xX;
      P32[(young<c2xX> + 12)] = Main.main5_closure+1;
      P32[(young<c2xX> + 8)] = Main.main_n_closure+1;
      call GHC.Arr.$w$crangeSize5_info() returns to c2xX, args: 12, res: 4, upd: 4;
  c2xX:
      _s2iw::I32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2GU; else goto c2GT;
  c2GU:
      HpAlloc = 12;
      goto c2GS;
  c2GS:
      R1 = _s2iw::I32;
      call stg_gc_unbx_r1(R1) returns to c2xX, args: 4, res: 4, upd: 4;
  c2GT:
      _c2y1::I32 = %MO_S_Lt_W32(_s2iw::I32, 0);
      _s2ix::I32 = _c2y1::I32;
      if (_s2ix::I32 >= 1) goto c2GX; else goto c2GW;
  c2GX:
      Hp = Hp - 12;
      R1 = GHC.Arr.negRange_closure;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  c2GW:
      I32[Hp - 8] = sat_s2kZ_info;
      P32[Hp - 4] = _s2iv::P32;
      I32[Hp] = _s2iw::I32;
      _c2y6::P32 = Hp - 7;
      P32[(old + 8)] = _c2y6::P32;
      call GHC.ST.runSTRep_info() args: 8, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2KL:
      _s2l8::P32 = R1;
      _s2l9::I32 = I32[(old + 12)];
      _s2la::P32 = P32[(old + 8)];
      goto c2KH;
  c2KH:
      if (Sp - <highSp> < SpLim) goto c2KM; else goto c2L9;
  c2KM:
      R1 = _s2l8::P32;
      I32[(old + 12)] = _s2l9::I32;
      P32[(old + 8)] = _s2la::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c2L9:
      _s2l7::P32 = P32[_s2l8::P32 + 1];
      _s2l2::I32 = I32[_s2l8::P32 + 5];
      _c2KJ::I32 = _s2l9::I32 == _s2l2::I32;
      _s2lc::I32 = _c2KJ::I32;
      if (_s2lc::I32 >= 1) goto c2L8; else goto c2KS;
  c2KS:
      I32[(young<c2KQ> + 4)] = c2KQ;
      R1 = _s2la::P32;
      if (R1 & 3 != 0) goto c2KQ; else goto c2KT;
  c2KT:
      call (I32[R1])(R1) returns to c2KQ, args: 4, res: 4, upd: 4;
  c2KQ:
      _s2le::P32 = R1;
      _c2L4::P32 = _s2le::P32 & 3;
      if (_c2L4::P32 >= 2) goto c2L3; else goto c2L8;
  c2L3:
      _s2lf::P32 = P32[_s2le::P32 + 2];
      _s2lg::P32 = P32[_s2le::P32 + 6];
      P32[(_s2l7::P32 + 12) + (_s2l9::I32 << 2)] = _s2lf::P32;
      I32[_s2l7::P32] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_s2l7::P32 + 12) + (I32[_s2l7::P32 + 4] << 2) + (_s2l9::I32 >> 7)] = 1 :: W8;
      _c2Lf::I32 = _s2l9::I32 + 1;
      _s2li::I32 = _c2Lf::I32;
      R1 = _s2l8::P32;
      I32[(old + 12)] = _s2li::I32;
      P32[(old + 8)] = _s2lg::P32;
      call fillFromList_s2l8_info(R1) args: 12, res: 0, upd: 4;
  c2L8:
      call (P32[(old + 4)])() args: 4, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2Ks:
      if (Sp - <highSp> < SpLim) goto c2Li; else goto c2Lj;
  c2Li:
      R1 = Main.main11_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2Lj:
      I32[(young<c2Ku> + 4)] = c2Ku;
      P32[(young<c2Ku> + 12)] = Main.main5_closure+1;
      P32[(young<c2Ku> + 8)] = Main.main_n_closure+1;
      call GHC.Arr.$w$crangeSize5_info() returns to c2Ku, args: 12, res: 4, upd: 4;
  c2Ku:
      _s2l2::I32 = R1;
      _c2Ky::I32 = %MO_S_Lt_W32(_s2l2::I32, 0);
      _s2l3::I32 = _c2Ky::I32;
      if (_s2l3::I32 >= 1) goto c2Ly; else goto c2Lr;
  c2Ly:
      R1 = GHC.Arr.negRange_closure;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  c2Lr:
      I32[(young<c2KD> + 4)] = c2KD;
      R1 = _s2l2::I32;
      P32[(young<c2KD> + 8)] = GHC.Arr.arrEleBottom_closure;
      call stg_newArray#(R1) returns to c2KD, args: 8, res: 4, upd: 4;
  c2KD:
      _s2l7::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Lu; else goto c2Lt;
  c2Lu:
      HpAlloc = 12;
      goto c2Ls;
  c2Ls:
      R1 = _s2l7::P32;
      call stg_gc_unpt_r1(R1) returns to c2KD, args: 4, res: 4, upd: 4;
  c2Lt:
      _c2KF::P32 = Hp - 5;
      I32[Hp - 8] = fillFromList_s2l8_info;
      P32[Hp - 4] = _s2l7::P32;
      I32[Hp] = _s2l2::I32;
      I32[(young<c2Ll> + 4)] = c2Ll;
      R1 = _c2KF::P32;
      I32[(young<c2Ll> + 12)] = 0;
      P32[(young<c2Ll> + 8)] = Main.main_xs_closure+2;
      call fillFromList_s2l8_info(R1) returns to c2Ll, args: 12, res: 4, upd: 4;
  c2Ll:
      Hp = Hp + 20;
      if (Hp > HpLim) goto c2Lx; else goto c2Lw;
  c2Lx:
      HpAlloc = 20;
      goto c2Lv;
  c2Lv:
      call stg_gc_noregs() returns to c2Ll, args: 4, res: 4, upd: 4;
  c2Lw:
      I32[_s2l7::P32] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _s2lm::P32 = _s2l7::P32;
      _s2lm::P32 = _s2lm::P32;
      I32[Hp - 16] = GHC.Arr.Array_con_info;
      P32[Hp - 12] = Main.main5_closure+1;
      P32[Hp - 8] = Main.main_n_closure+1;
      P32[Hp - 4] = _s2lm::P32;
      I32[Hp] = _s2l2::I32;
      _c2Lp::P32 = Hp - 15;
      R1 = _c2Lp::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2M7:
      _r2hk::P32 = R1;
      goto c2M2;
  c2M2:
      if (Sp - <highSp> < SpLim) goto c2M8; else goto c2M9;
  c2M9:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2Mb; else goto c2Ma;
  c2Mb:
      HpAlloc = 8;
      goto c2M8;
  c2M8:
      R1 = _r2hk::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2Ma:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2M4::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hk::P32, Hp - 4);
      if (_c2M4::I32 == 0) goto c2M6; else goto c2M5;
  c2M6:
      call (I32[_r2hk::P32])() args: 4, res: 0, upd: 4;
  c2M5:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 16)] = Main.main11_closure+1;
      call GHC.ST.runSTRep_info() args: 16, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2MN:
      _r2hi::P32 = R1;
      goto c2Mw;
  c2Mw:
      if (Sp - <highSp> < SpLim) goto c2MO; else goto c2MP;
  c2MP:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2MR; else goto c2MQ;
  c2MR:
      HpAlloc = 8;
      goto c2MO;
  c2MO:
      R1 = _r2hi::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2MQ:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2My::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hi::P32, Hp - 4);
      if (_c2My::I32 == 0) goto c2MA; else goto c2Mz;
  c2MA:
      call (I32[_r2hi::P32])() args: 4, res: 0, upd: 4;
  c2Mz:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c2MB> + 4)] = c2MB;
      P32[(young<c2MB> + 12)] = Main.main12_closure+1;
      P32[(young<c2MB> + 8)] = Main.main10_closure;
      call GHC.List.$witerate_info() returns to c2MB, args: 12, res: 8, upd: 12;
  c2MB:
      _s2lq::P32 = R1;
      _s2lr::P32 = P32[(young<c2MB> + 8)];
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2MU; else goto c2MT;
  c2MU:
      HpAlloc = 12;
      goto c2MS;
  c2MS:
      R1 = _s2lq::P32;
      P32[(young<c2MB> + 8)] = _s2lr::P32;
      call stg_gc_pp(R1) returns to c2MB, args: 8, res: 8, upd: 12;
  c2MT:
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _s2lq::P32;
      P32[Hp] = _s2lr::P32;
      _c2MD::P32 = Hp - 6;
      I32[(young<c2ME> + 4)] = c2ME;
      I32[(young<c2ME> + 12)] = 19;
      P32[(young<c2ME> + 8)] = _c2MD::P32;
      call GHC.List.drop_drop#_info() returns to c2ME, args: 12, res: 4, upd: 12;
  c2ME:
      _s2lt::P32 = R1;
      _c2MJ::P32 = _s2lt::P32 & 3;
      if (_c2MJ::P32 >= 2) goto c2MI; else goto c2N8;
  c2MI:
      _s2lu::P32 = P32[_s2lt::P32 + 2];
      _s2lv::P32 = P32[_s2lt::P32 + 6];
      I32[(young<c2N0> + 4)] = c2N0;
      R1 = _s2lv::P32;
      if (R1 & 3 != 0) goto c2N0; else goto c2N2;
  c2N2:
      call (I32[R1])(R1) returns to c2N0, args: 4, res: 4, upd: 12;
  c2N0:
      _s2lw::P32 = R1;
      _c2Ng::P32 = _s2lw::P32 & 3;
      if (_c2Ng::P32 >= 2) goto c2Nc; else goto c2N8;
  c2Nc:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c2Nf; else goto c2Ne;
  c2Nf:
      HpAlloc = 16;
      goto c2Nd;
  c2Nd:
      R1 = _s2lw::P32;
      call stg_gc_unpt_r1(R1) returns to c2N0, args: 4, res: 4, upd: 12;
  c2Ne:
      _s2lx::P32 = P32[_s2lw::P32 + 2];
      _s2ly::P32 = P32[_s2lw::P32 + 6];
      I32[Hp - 12] = (,,)_con_info;
      P32[Hp - 8] = _s2lu::P32;
      P32[Hp - 4] = _s2lx::P32;
      P32[Hp] = _s2ly::P32;
      _c2Nb::P32 = Hp - 11;
      R1 = _c2Nb::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2N8:
      R1 = Main.main9_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2NN:
      _r2hH::P32 = R1;
      goto c2NF;
  c2NF:
      if (Sp - <highSp> < SpLim) goto c2NO; else goto c2NP;
  c2NP:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2NR; else goto c2NQ;
  c2NR:
      HpAlloc = 8;
      goto c2NO;
  c2NO:
      R1 = _r2hH::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2NQ:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2NH::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hH::P32, Hp - 4);
      if (_c2NH::I32 == 0) goto c2NJ; else goto c2NI;
  c2NJ:
      call (I32[_r2hH::P32])() args: 4, res: 0, upd: 4;
  c2NI:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c2NK> + 4)] = c2NK;
      R1 = Main.main8_closure;
      if (R1 & 3 != 0) goto c2NK; else goto c2NL;
  c2NL:
      call (I32[R1])(R1) returns to c2NK, args: 4, res: 4, upd: 12;
  c2NK:
      _s2lz::P32 = R1;
      _s2lA::P32 = P32[_s2lz::P32 + 3];
      _s2lB::P32 = P32[_s2lz::P32 + 7];
      _s2lC::P32 = P32[_s2lz::P32 + 11];
      R1 = _s2lB::P32 & (-4);
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2Oi:
      _r2hh::P32 = R1;
      goto c2Oa;
  c2Oa:
      if (Sp - <highSp> < SpLim) goto c2Oj; else goto c2Ok;
  c2Ok:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2Om; else goto c2Ol;
  c2Om:
      HpAlloc = 8;
      goto c2Oj;
  c2Oj:
      R1 = _r2hh::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2Ol:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2Oc::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hh::P32, Hp - 4);
      if (_c2Oc::I32 == 0) goto c2Oe; else goto c2Od;
  c2Oe:
      call (I32[_r2hh::P32])() args: 4, res: 0, upd: 4;
  c2Od:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c2Of> + 4)] = c2Of;
      R1 = Main.main8_closure;
      if (R1 & 3 != 0) goto c2Of; else goto c2Og;
  c2Og:
      call (I32[R1])(R1) returns to c2Of, args: 4, res: 4, upd: 12;
  c2Of:
      _s2lD::P32 = R1;
      _s2lE::P32 = P32[_s2lD::P32 + 3];
      _s2lF::P32 = P32[_s2lD::P32 + 7];
      _s2lG::P32 = P32[_s2lD::P32 + 11];
      R1 = _s2lE::P32 & (-4);
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2OF:
      _s2lH::P32 = P32[(old + 16)];
      _s2lI::P32 = P32[(old + 12)];
      _s2lJ::P32 = P32[(old + 8)];
      goto c2OC;
  c2OC:
      if (Sp - <highSp> < SpLim) goto c2OG; else goto c2OH;
  c2OH:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2OJ; else goto c2OI;
  c2OJ:
      HpAlloc = 12;
      goto c2OG;
  c2OG:
      R1 = lvl11_r2hI_closure;
      P32[(old + 16)] = _s2lH::P32;
      P32[(old + 12)] = _s2lI::P32;
      P32[(old + 8)] = _s2lJ::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2OI:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2lH::P32;
      P32[Hp] = _s2lI::P32;
      _c2OE::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2OE::P32;
      P32[(old + 12)] = _s2lJ::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2OX:
      _s2lL::P32 = P32[(old + 16)];
      _s2lM::P32 = P32[(old + 12)];
      _s2lN::P32 = P32[(old + 8)];
      goto c2OV;
  c2OV:
      if (Sp - <highSp> < SpLim) goto c2OY; else goto c2OZ;
  c2OY:
      R1 = Main.main7_closure;
      P32[(old + 16)] = _s2lL::P32;
      P32[(old + 12)] = _s2lM::P32;
      P32[(old + 8)] = _s2lN::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2OZ:
      P32[(old + 16)] = _s2lL::P32;
      P32[(old + 12)] = _s2lM::P32;
      P32[(old + 8)] = _s2lN::P32;
      call lvl11_r2hI_info() args: 16, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2PY:
      _s2me::P32 = R1;
      goto c2PT;
  c2PT:
      if (Sp - <highSp> < SpLim) goto c2Q2; else goto c2Q3;
  c2Q2:
      R1 = _s2me::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2Q3:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2me::P32;
      _s2lQ::P32 = P32[_s2me::P32 + 8];
      I32[(young<c2PV> + 4)] = c2PV;
      R1 = Main.main_v_closure;
      if (R1 & 3 != 0) goto c2PV; else goto c2PW;
  c2PW:
      call (I32[R1])(R1) returns to c2PV, args: 4, res: 4, upd: 12;
  c2PV:
      _s2lS::P32 = R1;
      _s2lT::P32 = P32[_s2lS::P32 + 3];
      _s2lU::P32 = P32[_s2lS::P32 + 7];
      _s2lW::P32 = P32[_s2lS::P32 + 11];
      _s2lV::I32 = I32[_s2lS::P32 + 15];
      I32[(young<c2Q1> + 4)] = c2Q1;
      P32[(young<c2Q1> + 12)] = _s2lT::P32;
      P32[(young<c2Q1> + 8)] = _s2lQ::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Q1, args: 12, res: 4, upd: 12;
  c2Q1:
      _s2lX::I32 = R1;
      if (_s2lX::I32 >= 1) goto c2Qf; else goto c2Qm;
  c2Qf:
      I32[(young<c2Qe> + 4)] = c2Qe;
      P32[(young<c2Qe> + 12)] = _s2lQ::P32;
      P32[(young<c2Qe> + 8)] = _s2lU::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2Qe, args: 12, res: 4, upd: 12;
  c2Qe:
      _s2lZ::I32 = R1;
      if (_s2lZ::I32 >= 1) goto c2Qu; else goto c2Qm;
  c2Qu:
      I32[(young<c2Qp> + 4)] = c2Qp;
      P32[(young<c2Qp> + 12)] = _s2lQ::P32;
      P32[(young<c2Qp> + 8)] = _s2lT::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2Qp, args: 12, res: 4, upd: 12;
  c2Qp:
      _s2m1::P32 = R1;
      I32[(young<c2Qt> + 4)] = c2Qt;
      P32[(young<c2Qt> + 8)] = _s2m1::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2Qt, args: 8, res: 4, upd: 12;
  c2Qt:
      _s2m2::I32 = R1;
      _c2QA::I32 = %MO_S_Le_W32(0, _s2m2::I32);
      _s2m3::I32 = _c2QA::I32;
      if (_s2m3::I32 >= 1) goto c2R3; else goto c2QN;
  c2R3:
      _c2QI::I32 = %MO_S_Lt_W32(_s2m2::I32, _s2lV::I32);
      _s2m6::I32 = _c2QI::I32;
      if (_s2m6::I32 >= 1) goto c2QZ; else goto c2QN;
  c2QZ:
      _s2ma::P32 = P32[(_s2lW::P32 + 12) + (_s2m2::I32 << 2)];
      _s2ma::P32 = _s2ma::P32;
      I32[(young<c2QQ> + 4)] = c2QQ;
      R1 = _s2ma::P32;
      if (R1 & 3 != 0) goto c2QQ; else goto c2QR;
  c2QR:
      call (I32[R1])(R1) returns to c2QQ, args: 4, res: 4, upd: 12;
  c2QQ:
      _s2mb::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2R2; else goto c2R1;
  c2R2:
      HpAlloc = 12;
      goto c2R0;
  c2R0:
      R1 = _s2mb::P32;
      call stg_gc_unpt_r1(R1) returns to c2QQ, args: 4, res: 4, upd: 12;
  c2R1:
      _s2mc::F64 = F64[_s2mb::P32 + 3];
      _c2QV::F64 = %MO_F_Mul_W64(_s2mc::F64, _s2mc::F64);
      _s2md::F64 = _c2QV::F64;
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _s2md::F64;
      _c2QY::P32 = Hp - 7;
      R1 = _c2QY::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2QN:
      I32[(old + 20)] = _s2m2::I32;
      I32[(old + 16)] = _s2lV::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2Qm:
      P32[(old + 24)] = _s2lT::P32;
      P32[(old + 20)] = _s2lU::P32;
      P32[(old + 16)] = _s2lQ::P32;
      call Main.main7_info() args: 24, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2Rh:
      _s2lQ::P32 = P32[(old + 12)];
      _s2lR::P32 = P32[(old + 8)];
      goto c2PP;
  c2PP:
      if (Sp - <highSp> < SpLim) goto c2Ri; else goto c2Rj;
  c2Rj:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c2Rl; else goto c2Rk;
  c2Rl:
      HpAlloc = 24;
      goto c2Ri;
  c2Ri:
      R1 = Main.main6_closure;
      P32[(old + 12)] = _s2lQ::P32;
      P32[(old + 8)] = _s2lR::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c2Rk:
      I32[Hp - 20] = sat_s2me_info;
      P32[Hp - 12] = _s2lQ::P32;
      _c2PR::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c2PR::P32;
      P32[Hp] = _s2lR::P32;
      _c2Rg::P32 = Hp - 6;
      R1 = _c2Rg::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2RM:
      _r2hb::P32 = R1;
      goto c2RH;
  c2RH:
      if (Sp - <highSp> < SpLim) goto c2RN; else goto c2RO;
  c2RO:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2RQ; else goto c2RP;
  c2RQ:
      HpAlloc = 8;
      goto c2RN;
  c2RN:
      R1 = _r2hb::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2RP:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2RJ::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2hb::P32, Hp - 4);
      if (_c2RJ::I32 == 0) goto c2RL; else goto c2RK;
  c2RL:
      call (I32[_r2hb::P32])() args: 4, res: 0, upd: 4;
  c2RK:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 32)] = Main.main6_closure+2;
      P32[(old + 28)] = GHC.Types.[]_closure+1;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToIntegerFB_info() args: 32, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2S6:
      _s2mf::P32 = P32[(old + 16)];
      _s2mg::P32 = P32[(old + 12)];
      _s2mh::P32 = P32[(old + 8)];
      goto c2S3;
  c2S3:
      if (Sp - <highSp> < SpLim) goto c2S7; else goto c2S8;
  c2S8:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2Sa; else goto c2S9;
  c2Sa:
      HpAlloc = 12;
      goto c2S7;
  c2S7:
      R1 = lvl12_r2hJ_closure;
      P32[(old + 16)] = _s2mf::P32;
      P32[(old + 12)] = _s2mg::P32;
      P32[(old + 8)] = _s2mh::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2S9:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2mf::P32;
      P32[Hp] = _s2mg::P32;
      _c2S5::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2S5::P32;
      P32[(old + 12)] = _s2mh::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2So:
      _s2mj::P32 = P32[(old + 16)];
      _s2mk::P32 = P32[(old + 12)];
      _s2ml::P32 = P32[(old + 8)];
      goto c2Sm;
  c2Sm:
      if (Sp - <highSp> < SpLim) goto c2Sp; else goto c2Sq;
  c2Sp:
      R1 = poly_$w$j4_r2hK_closure;
      P32[(old + 16)] = _s2mj::P32;
      P32[(old + 12)] = _s2mk::P32;
      P32[(old + 8)] = _s2ml::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2Sq:
      P32[(old + 16)] = _s2mj::P32;
      P32[(old + 12)] = _s2mk::P32;
      P32[(old + 8)] = _s2ml::P32;
      call lvl12_r2hJ_info() args: 16, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2SA:
      _s2mo::P32 = P32[(old + 16)];
      _s2mp::P32 = P32[(old + 12)];
      _s2mq::P32 = P32[(old + 8)];
      goto c2Sx;
  c2Sx:
      if (Sp - <highSp> < SpLim) goto c2SB; else goto c2SC;
  c2SC:
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2SE; else goto c2SD;
  c2SE:
      HpAlloc = 12;
      goto c2SB;
  c2SB:
      R1 = lvl13_r2hL_closure;
      P32[(old + 16)] = _s2mo::P32;
      P32[(old + 12)] = _s2mp::P32;
      P32[(old + 8)] = _s2mq::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2SD:
      I32[Hp - 8] = (,)_con_info;
      P32[Hp - 4] = _s2mo::P32;
      P32[Hp] = _s2mp::P32;
      _c2Sz::P32 = Hp - 7;
      P32[(old + 20)] = GHC.Show.$fShowInteger_closure;
      P32[(old + 16)] = _c2Sz::P32;
      P32[(old + 12)] = _s2mq::P32;
      P32[(old + 8)] = lvl5_r2hw_closure;
      call GHC.Arr.indexError_info() args: 20, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2SS:
      _s2ms::P32 = P32[(old + 16)];
      _s2mt::P32 = P32[(old + 12)];
      _s2mu::P32 = P32[(old + 8)];
      goto c2SQ;
  c2SQ:
      if (Sp - <highSp> < SpLim) goto c2ST; else goto c2SU;
  c2ST:
      R1 = poly_$w$j5_r2hM_closure;
      P32[(old + 16)] = _s2ms::P32;
      P32[(old + 12)] = _s2mt::P32;
      P32[(old + 8)] = _s2mu::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c2SU:
      P32[(old + 16)] = _s2ms::P32;
      P32[(old + 12)] = _s2mt::P32;
      P32[(old + 8)] = _s2mu::P32;
      call lvl13_r2hL_info() args: 16, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2Uy:
      _s2ng::P32 = R1;
      goto c2Ut;
  c2Ut:
      if (Sp - <highSp> < SpLim) goto c2UC; else goto c2UD;
  c2UC:
      R1 = _s2ng::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2UD:
      I32[(old + 12)] = stg_upd_frame_info;
      P32[(old + 8)] = _s2ng::P32;
      _s2mx::P32 = P32[_s2ng::P32 + 8];
      I32[(young<c2Uv> + 4)] = c2Uv;
      R1 = u_r2hH_closure;
      if (R1 & 3 != 0) goto c2Uv; else goto c2Uw;
  c2Uw:
      call (I32[R1])(R1) returns to c2Uv, args: 4, res: 4, upd: 12;
  c2Uv:
      _s2mz::P32 = R1;
      _s2mA::P32 = P32[_s2mz::P32 + 3];
      _s2mB::P32 = P32[_s2mz::P32 + 7];
      _s2mD::P32 = P32[_s2mz::P32 + 11];
      _s2mC::I32 = I32[_s2mz::P32 + 15];
      I32[(young<c2UB> + 4)] = c2UB;
      P32[(young<c2UB> + 12)] = _s2mA::P32;
      P32[(young<c2UB> + 8)] = _s2mx::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2UB, args: 12, res: 4, upd: 12;
  c2UB:
      _s2mE::I32 = R1;
      if (_s2mE::I32 >= 1) goto c2UP; else goto c2UW;
  c2UP:
      I32[(young<c2UO> + 4)] = c2UO;
      P32[(young<c2UO> + 12)] = _s2mx::P32;
      P32[(young<c2UO> + 8)] = _s2mB::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2UO, args: 12, res: 4, upd: 12;
  c2UO:
      _s2mG::I32 = R1;
      if (_s2mG::I32 >= 1) goto c2V4; else goto c2UW;
  c2V4:
      I32[(young<c2UZ> + 4)] = c2UZ;
      P32[(young<c2UZ> + 12)] = _s2mx::P32;
      P32[(young<c2UZ> + 8)] = _s2mA::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2UZ, args: 12, res: 4, upd: 12;
  c2UZ:
      _s2mI::P32 = R1;
      I32[(young<c2V3> + 4)] = c2V3;
      P32[(young<c2V3> + 8)] = _s2mI::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2V3, args: 8, res: 4, upd: 12;
  c2V3:
      _s2mJ::I32 = R1;
      _c2Va::I32 = %MO_S_Le_W32(0, _s2mJ::I32);
      _s2mK::I32 = _c2Va::I32;
      if (_s2mK::I32 >= 1) goto c2WP; else goto c2Vn;
  c2WP:
      _c2Vi::I32 = %MO_S_Lt_W32(_s2mJ::I32, _s2mC::I32);
      _s2mN::I32 = _c2Vi::I32;
      if (_s2mN::I32 >= 1) goto c2VB; else goto c2Vn;
  c2VB:
      _s2mR::P32 = P32[(_s2mD::P32 + 12) + (_s2mJ::I32 << 2)];
      _s2mR::P32 = _s2mR::P32;
      I32[(young<c2Vq> + 4)] = c2Vq;
      R1 = _s2mR::P32;
      if (R1 & 3 != 0) goto c2Vq; else goto c2Vr;
  c2Vr:
      call (I32[R1])(R1) returns to c2Vq, args: 4, res: 4, upd: 12;
  c2Vq:
      _s2mS::P32 = R1;
      _s2mT::F64 = F64[_s2mS::P32 + 3];
      I32[(young<c2Vv> + 4)] = c2Vv;
      R1 = Main.main_v_closure;
      if (R1 & 3 != 0) goto c2Vv; else goto c2Vw;
  c2Vw:
      call (I32[R1])(R1) returns to c2Vv, args: 4, res: 4, upd: 12;
  c2Vv:
      _s2mU::P32 = R1;
      _s2mV::P32 = P32[_s2mU::P32 + 3];
      _s2mW::P32 = P32[_s2mU::P32 + 7];
      _s2mY::P32 = P32[_s2mU::P32 + 11];
      _s2mX::I32 = I32[_s2mU::P32 + 15];
      I32[(young<c2VA> + 4)] = c2VA;
      P32[(young<c2VA> + 12)] = _s2mV::P32;
      P32[(young<c2VA> + 8)] = _s2mx::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2VA, args: 12, res: 4, upd: 12;
  c2VA:
      _s2mZ::I32 = R1;
      if (_s2mZ::I32 >= 1) goto c2VO; else goto c2VV;
  c2VO:
      I32[(young<c2VN> + 4)] = c2VN;
      P32[(young<c2VN> + 12)] = _s2mx::P32;
      P32[(young<c2VN> + 8)] = _s2mW::P32;
      call GHC.Integer.Type.leInteger#_info() returns to c2VN, args: 12, res: 4, upd: 12;
  c2VN:
      _s2n1::I32 = R1;
      if (_s2n1::I32 >= 1) goto c2W3; else goto c2VV;
  c2W3:
      I32[(young<c2VY> + 4)] = c2VY;
      P32[(young<c2VY> + 12)] = _s2mx::P32;
      P32[(young<c2VY> + 8)] = _s2mV::P32;
      call GHC.Integer.Type.minusInteger_info() returns to c2VY, args: 12, res: 4, upd: 12;
  c2VY:
      _s2n3::P32 = R1;
      I32[(young<c2W2> + 4)] = c2W2;
      P32[(young<c2W2> + 8)] = _s2n3::P32;
      call GHC.Integer.Type.integerToInt_info() returns to c2W2, args: 8, res: 4, upd: 12;
  c2W2:
      _s2n4::I32 = R1;
      _c2W9::I32 = %MO_S_Le_W32(0, _s2n4::I32);
      _s2n5::I32 = _c2W9::I32;
      if (_s2n5::I32 >= 1) goto c2WC; else goto c2Wm;
  c2WC:
      _c2Wh::I32 = %MO_S_Lt_W32(_s2n4::I32, _s2mX::I32);
      _s2n8::I32 = _c2Wh::I32;
      if (_s2n8::I32 >= 1) goto c2Wy; else goto c2Wm;
  c2Wy:
      _s2nc::P32 = P32[(_s2mY::P32 + 12) + (_s2n4::I32 << 2)];
      _s2nc::P32 = _s2nc::P32;
      I32[(young<c2Wp> + 4)] = c2Wp;
      R1 = _s2nc::P32;
      if (R1 & 3 != 0) goto c2Wp; else goto c2Wq;
  c2Wq:
      call (I32[R1])(R1) returns to c2Wp, args: 4, res: 4, upd: 12;
  c2Wp:
      _s2nd::P32 = R1;
      Hp = Hp + 12;
      if (Hp > HpLim) goto c2WB; else goto c2WA;
  c2WB:
      HpAlloc = 12;
      goto c2Wz;
  c2Wz:
      R1 = _s2nd::P32;
      call stg_gc_unpt_r1(R1) returns to c2Wp, args: 4, res: 4, upd: 12;
  c2WA:
      _s2ne::F64 = F64[_s2nd::P32 + 3];
      _c2Wu::F64 = %MO_F_Mul_W64(_s2mT::F64, _s2ne::F64);
      _s2nf::F64 = _c2Wu::F64;
      I32[Hp - 8] = GHC.Types.D#_con_info;
      F64[Hp - 4] = _s2nf::F64;
      _c2Wx::P32 = Hp - 7;
      R1 = _c2Wx::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c2Wm:
      I32[(old + 20)] = _s2n4::I32;
      I32[(old + 16)] = _s2mX::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2VV:
      P32[(old + 24)] = _s2mV::P32;
      P32[(old + 20)] = _s2mW::P32;
      P32[(old + 16)] = _s2mx::P32;
      call poly_$w$j5_r2hM_info() args: 24, res: 0, upd: 12;
  c2Vn:
      I32[(old + 20)] = _s2mJ::I32;
      I32[(old + 16)] = _s2mC::I32;
      call GHC.Arr.badSafeIndex1_info() args: 20, res: 0, upd: 12;
  c2UW:
      P32[(old + 24)] = _s2mA::P32;
      P32[(old + 20)] = _s2mB::P32;
      P32[(old + 16)] = _s2mx::P32;
      call poly_$w$j4_r2hK_info() args: 24, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2X3:
      _s2mx::P32 = P32[(old + 12)];
      _s2my::P32 = P32[(old + 8)];
      goto c2Up;
  c2Up:
      if (Sp - <highSp> < SpLim) goto c2X4; else goto c2X5;
  c2X5:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c2X7; else goto c2X6;
  c2X7:
      HpAlloc = 24;
      goto c2X4;
  c2X4:
      R1 = Main.main14_closure;
      P32[(old + 12)] = _s2mx::P32;
      P32[(old + 8)] = _s2my::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c2X6:
      I32[Hp - 20] = sat_s2ng_info;
      P32[Hp - 12] = _s2mx::P32;
      _c2Ur::P32 = Hp - 20;
      I32[Hp - 8] = :_con_info;
      P32[Hp - 4] = _c2Ur::P32;
      P32[Hp] = _s2my::P32;
      _c2X2::P32 = Hp - 6;
      R1 = _c2X2::P32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2XH:
      _r2ho::P32 = R1;
      goto c2XC;
  c2XC:
      if (Sp - <highSp> < SpLim) goto c2XI; else goto c2XJ;
  c2XJ:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2XL; else goto c2XK;
  c2XL:
      HpAlloc = 8;
      goto c2XI;
  c2XI:
      R1 = _r2ho::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2XK:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2XE::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2ho::P32, Hp - 4);
      if (_c2XE::I32 == 0) goto c2XG; else goto c2XF;
  c2XG:
      call (I32[_r2ho::P32])() args: 4, res: 0, upd: 4;
  c2XF:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 32)] = Main.main14_closure+2;
      P32[(old + 28)] = GHC.Types.[]_closure+1;
      P32[(old + 24)] = Main.main5_closure+1;
      P32[(old + 20)] = Main.main4_closure+1;
      P32[(old + 16)] = Main.main_n_closure+1;
      call GHC.Enum.enumDeltaToIntegerFB_info() args: 32, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2Yh:
      _r2ha::P32 = R1;
      goto c2Ya;
  c2Ya:
      if (Sp - <highSp> < SpLim) goto c2Yl; else goto c2Ym;
  c2Ym:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c2Yo; else goto c2Yn;
  c2Yo:
      HpAlloc = 8;
      goto c2Yl;
  c2Yl:
      R1 = _r2ha::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c2Yn:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c2Yc::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r2ha::P32, Hp - 4);
      if (_c2Yc::I32 == 0) goto c2Ye; else goto c2Yd;
  c2Ye:
      call (I32[_r2ha::P32])() args: 4, res: 0, upd: 4;
  c2Yd:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c2Yf> + 4)] = c2Yf;
      P32[(young<c2Yf> + 16)] = Main.main13_closure;
      F64[(young<c2Yf> + 12)] = 0.0 :: W64;
      call Main.$wsum'1_info() returns to c2Yf, args: 16, res: 4, upd: 12;
  c2Yf:
      _s2nh::F64 = D1;
      I32[(young<c2Yk> + 4)] = c2Yk;
      P32[(young<c2Yk> + 16)] = Main.main3_closure;
      F64[(young<c2Yk> + 12)] = 0.0 :: W64;
      call Main.$wsum'1_info() returns to c2Yk, args: 16, res: 4, upd: 12;
  c2Yk:
      _s2ni::F64 = D1;
      _c2Yu::F64 = %MO_F_Quot_W64(_s2nh::F64, _s2ni::F64);
      _s2nj::F64 = _c2Yu::F64;
      _c2Yy::F64 = _s2nj::F64;
      (_c2Yx::F64) = call MO_F64_Sqrt(_c2Yy::F64);
      _s2nk::F64 = _c2Yx::F64;
      P32[(old + 36)] = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      P32[(old + 32)] = GHC.Show.shows25_closure;
      F64[(old + 28)] = _s2nk::F64;
      I32[(old + 20)] = stg_ap_p_info;
      P32[(old + 16)] = GHC.Types.[]_closure+1;
      call GHC.Float.$w$sshowSignedFloat_info() args: 36, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c2YQ:
      if (Sp - <highSp> < SpLim) goto c2YT; else goto c2YU;
  c2YT:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2YU:
      P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
      P32[(old + 12)] = Main.main2_closure;
      P32[(old + 8)] = GHC.Types.True_closure+2;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2Z2:
      if (Sp - <highSp> < SpLim) goto c2Z5; else goto c2Z6;
  c2Z5:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2Z6:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2Zd:
      if (Sp - <highSp> < SpLim) goto c2Zg; else goto c2Zh;
  c2Zg:
      R1 = Main.main15_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2Zh:
      P32[(old + 8)] = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2Zp:
      if (Sp - <highSp> < SpLim) goto c2Zs; else goto c2Zt;
  c2Zs:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2Zt:
      call Main.main15_info() args: 4, res: 0, upd: 4;
}

