==================== Before copy propagation ====================
{offset
  c1VC:
      _s1Sw::P32 = P32[(old + 12)];
      _s1Sx::P32 = P32[(old + 8)];
      goto c1Vy;
  c1Vy:
      if (Sp - <highSp> < SpLim) goto c1VD; else goto c1VE;
  c1VD:
      R1 = $wintegerLogBase_r1So_closure;
      P32[(old + 12)] = _s1Sw::P32;
      P32[(old + 8)] = _s1Sx::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c1VE:
      I32[(young<c1VA> + 4)] = c1VA;
      P32[(young<c1VA> + 12)] = _s1Sx::P32;
      P32[(young<c1VA> + 8)] = _s1Sw::P32;
      call GHC.Integer.Type.ltInteger#_info() returns to c1VA, args: 12, res: 4, upd: 4;
  c1VA:
      _s1Sy::I32 = R1;
      if (_s1Sy::I32 >= 1) goto c1X8; else goto c1VQ;
  c1X8:
      R1 = 0;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c1VQ:
      I32[(young<c1VK> + 4)] = c1VK;
      P32[(young<c1VK> + 12)] = _s1Sw::P32;
      P32[(young<c1VK> + 8)] = _s1Sw::P32;
      call GHC.Integer.Type.timesInteger_info() returns to c1VK, args: 12, res: 4, upd: 4;
  c1VK:
      _s1SA::P32 = R1;
      I32[(young<c1VO> + 4)] = c1VO;
      P32[(young<c1VO> + 12)] = _s1SA::P32;
      P32[(young<c1VO> + 8)] = _s1Sx::P32;
      call $wintegerLogBase_r1So_info() returns to c1VO, args: 12, res: 4, upd: 4;
  c1VO:
      _s1SB::I32 = R1;
      _c1VW::I32 = 2 * _s1SB::I32;
      _s1SC::I32 = _c1VW::I32;
      _c1VZ::I32 = %MO_S_Lt_W32(_s1SC::I32, 0);
      _s1SD::I32 = _c1VZ::I32;
      if (_s1SD::I32 >= 1) goto c1X4; else goto c1Wk;
  c1X4:
      R1 = GHC.Real.^3_closure;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  c1Wk:
      _s1SG::I32 = _s1SC::I32;
      if (_s1SG::I32 != 0) goto c1W6; else goto c1W7;
  c1W6:
      I32[(young<c1Wf> + 4)] = c1Wf;
      P32[(young<c1Wf> + 12)] = _s1Sw::P32;
      I32[(young<c1Wf> + 8)] = _s1SG::I32;
      call GHC.Real.$wf1_info() returns to c1Wf, args: 12, res: 4, upd: 4;
  c1W7:
      I32[(young<c1Wf> + 4)] = c1Wf;
      R1 = GHC.Real.$fEnumRatio1_closure;
      if (R1 & 3 != 0) goto c1Wf; else goto c1Wi;
  c1Wi:
      call (I32[R1])(R1) returns to c1Wf, args: 4, res: 4, upd: 4;
  c1Wf:
      _s1SF::P32 = R1;
      goto c1Wb;
  c1Wb:
      I32[(young<c1Wd> + 4)] = c1Wd;
      P32[(young<c1Wd> + 12)] = _s1SF::P32;
      P32[(young<c1Wd> + 8)] = lvl_r1Sn_closure+1;
      call GHC.Integer.Type.eqInteger#_info() returns to c1Wd, args: 12, res: 4, upd: 4;
  c1Wd:
      _s1SH::I32 = R1;
      if (_s1SH::I32 >= 1) goto c1X0; else goto c1WV;
  c1X0:
      R1 = GHC.Real.divZeroError_closure;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
  c1WV:
      I32[(young<c1Wu> + 4)] = c1Wu;
      P32[(young<c1Wu> + 12)] = _s1Sx::P32;
      P32[(young<c1Wu> + 8)] = _s1SF::P32;
      call GHC.Integer.Type.divInteger_info() returns to c1Wu, args: 12, res: 4, upd: 4;
  c1Wu:
      _s1SQ::P32 = R1;
      _s1SL::I32 = _s1SC::I32;
      _s1SK::P32 = _s1SQ::P32;
      goto c1Wv;
  c1Wv:
      I32[(young<c1Wy> + 4)] = c1Wy;
      P32[(young<c1Wy> + 12)] = _s1SK::P32;
      P32[(young<c1Wy> + 8)] = _s1Sw::P32;
      call GHC.Integer.Type.ltInteger#_info() returns to c1Wy, args: 12, res: 4, upd: 4;
  c1Wy:
      _s1SM::I32 = R1;
      if (_s1SM::I32 >= 1) goto c1WQ; else goto c1WL;
  c1WQ:
      R1 = _s1SL::I32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c1WL:
      _c1WG::I32 = _s1SL::I32 + 1;
      _s1SP::I32 = _c1WG::I32;
      I32[(young<c1WJ> + 4)] = c1WJ;
      P32[(young<c1WJ> + 12)] = _s1SK::P32;
      P32[(young<c1WJ> + 8)] = _s1Sw::P32;
      call GHC.Real.$fIntegralInteger_$cdiv_info() returns to c1WJ, args: 12, res: 4, upd: 4;
  c1WJ:
      _s1SO::P32 = R1;
      _s1SL::I32 = _s1SP::I32;
      _s1SK::P32 = _s1SO::P32;
      goto c1Wv;
}

==================== Before copy propagation ====================
{offset
  c1XB:
      _r1Sq::P32 = R1;
      goto c1Xw;
  c1Xw:
      if (Sp - <highSp> < SpLim) goto c1XC; else goto c1XD;
  c1XD:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c1XF; else goto c1XE;
  c1XF:
      HpAlloc = 8;
      goto c1XC;
  c1XC:
      R1 = _r1Sq::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c1XE:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c1Xy::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r1Sq::P32, Hp - 4);
      if (_c1Xy::I32 == 0) goto c1XA; else goto c1Xz;
  c1XA:
      call (I32[_r1Sq::P32])() args: 4, res: 0, upd: 4;
  c1Xz:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 20)] = GHC.Float.$fRealFloatDouble6_closure;
      I32[(old + 16)] = 24;
      call GHC.Real.$wf1_info() args: 20, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c1XV:
      _r1Sr::P32 = R1;
      goto c1XQ;
  c1XQ:
      if (Sp - <highSp> < SpLim) goto c1XW; else goto c1XX;
  c1XX:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c1XZ; else goto c1XY;
  c1XZ:
      HpAlloc = 8;
      goto c1XW;
  c1XW:
      R1 = _r1Sr::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c1XY:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c1XS::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r1Sr::P32, Hp - 4);
      if (_c1XS::I32 == 0) goto c1XU; else goto c1XT;
  c1XU:
      call (I32[_r1Sr::P32])() args: 4, res: 0, upd: 4;
  c1XT:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 20)] = lvl2_r1Sq_closure;
      P32[(old + 16)] = lvl1_r1Sp_closure+1;
      call GHC.Integer.Type.minusInteger_info() args: 20, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c1YY:
      _r1Ss::P32 = R1;
      goto c1YR;
  c1YR:
      if (Sp - <highSp> < SpLim) goto c1YZ; else goto c1Z0;
  c1Z0:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c1Z2; else goto c1Z1;
  c1Z2:
      HpAlloc = 8;
      goto c1YZ;
  c1YZ:
      R1 = _r1Ss::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c1Z1:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c1YT::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r1Ss::P32, Hp - 4);
      if (_c1YT::I32 == 0) goto c1YV; else goto c1YU;
  c1YV:
      call (I32[_r1Ss::P32])() args: 4, res: 0, upd: 4;
  c1YU:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c1YW> + 4)] = c1YW;
      P32[(young<c1YW> + 12)] = lvl3_r1Sr_closure;
      I32[(young<c1YW> + 8)] = 104;
      call GHC.Integer.Type.encodeFloatInteger_info() returns to c1YW, args: 12, res: 4, upd: 12;
  c1YW:
      _s1ST::F32 = F1;
      _c1Z6::F32 = %MO_F_Neg_W32(_s1ST::F32);
      _s1SU::F32 = _c1Z6::F32;
      I32[(young<c1Z9> + 4)] = c1Z9;
      F32[(young<c1Z9> + 8)] = _s1SU::F32;
      call stg_decodeFloat_Int#() returns to c1Z9, args: 8, res: 8, upd: 12;
  c1Z9:
      _s1SW::I32 = R1;
      _s1SX::I32 = I32[(young<c1Z9> + 8)];
      goto c1Za;
  c1Za:
      _c1Ze::I32 = %MO_S_Lt_W32(_s1SX::I32, 0);
      _s1SY::I32 = _c1Ze::I32;
      if (_s1SY::I32 >= 1) goto c200; else goto c1Zp;
  c200:
      _c1Zw::I32 = -_s1SX::I32;
      _s1T2::I32 = _c1Zw::I32;
      _c1Zz::I32 = %MO_S_Gt_W32(_s1T2::I32, 23);
      _s1T3::I32 = _c1Zz::I32;
      if (_s1T3::I32 >= 1) goto c1ZW; else goto c1ZJ;
  c1ZW:
      _c1ZP::I32 = %MO_S_Lt_W32(_s1SW::I32, 0);
      _s1T7::I32 = _c1ZP::I32;
      if (_s1T7::I32 >= 1) goto c1ZV; else goto c1ZU;
  c1ZV:
      R1 = lvl1_r1Sp_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c1ZU:
      R1 = lvl_r1Sn_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c1ZJ:
      _c1ZE::I32 = %MO_S_Shr_W32(_s1SW::I32, _s1T2::I32);
      _s1T5::I32 = _c1ZE::I32;
      I32[(young<c1ZH> + 4)] = c1ZH;
      I32[(young<c1ZH> + 8)] = _s1T5::I32;
      call GHC.Integer.Type.smallInteger_info() returns to c1ZH, args: 8, res: 4, upd: 12;
  c1ZH:
      _s1T6::P32 = R1;
      P32[(old + 16)] = _s1T6::P32;
      call GHC.Integer.Type.negateInteger_info() args: 16, res: 0, upd: 12;
  c1Zp:
      I32[(young<c1Zj> + 4)] = c1Zj;
      I32[(young<c1Zj> + 8)] = _s1SW::I32;
      call GHC.Integer.Type.smallInteger_info() returns to c1Zj, args: 8, res: 4, upd: 12;
  c1Zj:
      _s1T0::P32 = R1;
      I32[(young<c1Zn> + 4)] = c1Zn;
      P32[(young<c1Zn> + 12)] = _s1T0::P32;
      I32[(young<c1Zn> + 8)] = _s1SX::I32;
      call GHC.Integer.Type.shiftLInteger_info() returns to c1Zn, args: 12, res: 4, upd: 12;
  c1Zn:
      _s1T1::P32 = R1;
      P32[(old + 16)] = _s1T1::P32;
      call GHC.Integer.Type.negateInteger_info() args: 16, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c23D:
      _s1Tq::P32 = R1;
      _s1Tr::I32 = I32[(old + 8)];
      goto c23w;
  c23w:
      if (Sp - <highSp> < SpLim) goto c23R; else goto c23S;
  c23S:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c23U; else goto c23T;
  c23U:
      HpAlloc = 8;
      goto c23R;
  c23R:
      R1 = _s1Tq::P32;
      I32[(old + 8)] = _s1Tr::I32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c23T:
      _s1Ta::P32 = P32[_s1Tq::P32 + 3];
      _s1Tb::P32 = P32[_s1Tq::P32 + 7];
      _s1Ti::P32 = P32[_s1Tq::P32 + 11];
      _s1Tj::P32 = P32[_s1Tq::P32 + 15];
      I32[Hp - 4] = GHC.Types.I#_con_info;
      I32[Hp] = _s1Tr::I32;
      _c23y::P32 = Hp - 3;
      I32[(young<c23z> + 4)] = c23z;
      P32[(young<c23z> + 28)] = GHC.Real.$fRealInt_closure;
      P32[(young<c23z> + 24)] = GHC.Real.$fIntegralInt_$cquot_closure+2;
      P32[(young<c23z> + 20)] = GHC.Real.$fIntegralInt_$crem_closure+2;
      P32[(young<c23z> + 16)] = _s1Ti::P32;
      P32[(young<c23z> + 12)] = _s1Tj::P32;
      P32[(young<c23z> + 8)] = _c23y::P32;
      call GHC.Real.$w^^%^^_info() returns to c23z, args: 28, res: 8, upd: 4;
  c23z:
      _s1Tu::P32 = R1;
      _s1Tv::P32 = P32[(young<c23z> + 8)];
      I32[(young<c23B> + 4)] = c23B;
      P32[(young<c23B> + 12)] = _s1Tb::P32;
      P32[(young<c23B> + 8)] = _s1Tv::P32;
      call GHC.Integer.Type.timesInteger_info() returns to c23B, args: 12, res: 4, upd: 4;
  c23B:
      _s1Tx::P32 = R1;
      I32[(young<c23G> + 4)] = c23G;
      P32[(young<c23G> + 12)] = _s1Ta::P32;
      P32[(young<c23G> + 8)] = _s1Tu::P32;
      call GHC.Integer.Type.timesInteger_info() returns to c23G, args: 12, res: 4, upd: 4;
  c23G:
      _s1Tw::P32 = R1;
      I32[(young<c23K> + 4)] = c23K;
      P32[(young<c23K> + 12)] = _s1Tw::P32;
      P32[(young<c23K> + 8)] = _s1Tx::P32;
      call GHC.Real.$w$sreduce_info() returns to c23K, args: 12, res: 8, upd: 4;
  c23K:
      _s1Tz::P32 = R1;
      _s1TA::P32 = P32[(young<c23K> + 8)];
      I32[(young<c23M> + 4)] = c23M;
      P32[(young<c23M> + 16)] = GHC.Real.$fIntegralInteger_closure;
      P32[(young<c23M> + 12)] = _s1Tz::P32;
      P32[(young<c23M> + 8)] = _s1TA::P32;
      call GHC.Real.$w$s$cround_info() returns to c23M, args: 16, res: 4, upd: 4;
  c23M:
      _s1TB::P32 = R1;
      I32[(young<c23Q> + 4)] = c23Q;
      P32[(young<c23Q> + 12)] = _s1TB::P32;
      I32[(young<c23Q> + 8)] = _s1Tr::I32;
      call GHC.Integer.Type.encodeFloatInteger_info() returns to c23Q, args: 12, res: 4, upd: 4;
  c23Q:
      _s1TC::F32 = F1;
      I32[(young<c243> + 4)] = c243;
      F32[(young<c243> + 8)] = _s1TC::F32;
      call stg_decodeFloat_Int#() returns to c243, args: 8, res: 8, upd: 4;
  c243:
      _s1TE::I32 = R1;
      _s1TF::I32 = I32[(young<c243> + 8)];
      goto c245;
  c245:
      _c249::I32 = _s1TF::I32 == _s1Tr::I32;
      _s1TG::I32 = _c249::I32;
      if (_s1TG::I32 >= 1) goto c24f; else goto c24e;
  c24f:
      F1 = _s1TC::F32;
      call (P32[(old + 4)])(F1) args: 4, res: 0, upd: 4;
  c24e:
      R1 = _s1Tq::P32;
      I32[(old + 8)] = _s1TF::I32;
      call $wf_s1Tq_info(R1) args: 8, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c24j:
      _s1T9::I32 = I32[(old + 16)];
      _s1Ta::P32 = P32[(old + 12)];
      _s1Tb::P32 = P32[(old + 8)];
      goto c22V;
  c22V:
      if (Sp - <highSp> < SpLim) goto c24k; else goto c24l;
  c24k:
      R1 = Main.$wfromRat_closure;
      I32[(old + 16)] = _s1T9::I32;
      P32[(old + 12)] = _s1Ta::P32;
      P32[(old + 8)] = _s1Tb::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c24l:
      I32[(young<c22X> + 4)] = c22X;
      P32[(young<c22X> + 12)] = _s1Tb::P32;
      P32[(young<c22X> + 8)] = h_r1Ss_closure;
      call GHC.Integer.Type.gtInteger#_info() returns to c22X, args: 12, res: 4, upd: 4;
  c22X:
      _s1Tc::I32 = R1;
      if (_s1Tc::I32 >= 1) goto c26k; else goto c24o;
  c26k:
      I32[(young<c26f> + 4)] = c26f;
      P32[(young<c26f> + 12)] = _s1Tb::P32;
      P32[(young<c26f> + 8)] = h_r1Ss_closure;
      call GHC.Real.$fIntegralInteger_$cdiv_info() returns to c26f, args: 12, res: 4, upd: 4;
  c26f:
      _s1U6::P32 = R1;
      I32[(young<c26j> + 4)] = c26j;
      P32[(young<c26j> + 12)] = GHC.Float.$fRealFloatDouble6_closure;
      P32[(young<c26j> + 8)] = _s1U6::P32;
      call $wintegerLogBase_r1So_info() returns to c26j, args: 12, res: 4, upd: 4;
  c26j:
      _s1U7::I32 = R1;
      _c26q::I32 = _s1U7::I32 + 1;
      _s1U8::I32 = _c26q::I32;
      _c26t::I32 = %MO_S_Lt_W32(_s1U8::I32, 0);
      _s1U9::I32 = _c26t::I32;
      if (_s1U9::I32 >= 1) goto c27p; else goto c26O;
  c26O:
      _s1Uc::I32 = _s1U8::I32;
      if (_s1Uc::I32 != 0) goto c26A; else goto c26B;
  c26A:
      I32[(young<c26J> + 4)] = c26J;
      P32[(young<c26J> + 12)] = GHC.Float.$fRealFloatDouble6_closure;
      I32[(young<c26J> + 8)] = _s1Uc::I32;
      call GHC.Real.$wf1_info() returns to c26J, args: 12, res: 4, upd: 4;
  c26B:
      I32[(young<c26J> + 4)] = c26J;
      R1 = GHC.Real.$fEnumRatio1_closure;
      if (R1 & 3 != 0) goto c26J; else goto c26M;
  c26M:
      call (I32[R1])(R1) returns to c26J, args: 4, res: 4, upd: 4;
  c26J:
      _s1Ub::P32 = R1;
      goto c26F;
  c26F:
      I32[(young<c26H> + 4)] = c26H;
      P32[(young<c26H> + 12)] = _s1Ub::P32;
      P32[(young<c26H> + 8)] = lvl_r1Sn_closure+1;
      call GHC.Integer.Type.eqInteger#_info() returns to c26H, args: 12, res: 4, upd: 4;
  c26H:
      _s1Ud::I32 = R1;
      if (_s1Ud::I32 >= 1) goto c27l; else goto c27a;
  c27a:
      I32[(young<c26W> + 4)] = c26W;
      P32[(young<c26W> + 12)] = _s1Tb::P32;
      P32[(young<c26W> + 8)] = _s1Ub::P32;
      call GHC.Integer.Type.divInteger_info() returns to c26W, args: 12, res: 4, upd: 4;
  c26W:
      _s1Uf::P32 = R1;
      I32[(young<c270> + 4)] = c270;
      P32[(young<c270> + 8)] = _s1Uf::P32;
      call GHC.Integer.Type.absInteger_info() returns to c270, args: 8, res: 4, upd: 4;
  c270:
      _s1Ui::P32 = R1;
      I32[(young<c274> + 4)] = c274;
      P32[(young<c274> + 8)] = _s1Uf::P32;
      call GHC.Integer.Type.signumInteger_info() returns to c274, args: 8, res: 4, upd: 4;
  c274:
      _s1Ug::P32 = R1;
      I32[(young<c278> + 4)] = c278;
      P32[(young<c278> + 12)] = _s1Ta::P32;
      P32[(young<c278> + 8)] = _s1Ug::P32;
      call GHC.Integer.Type.timesInteger_info() returns to c278, args: 12, res: 4, upd: 4;
  c278:
      _s1Uh::P32 = R1;
      I32[(young<c27h> + 4)] = c27h;
      P32[(young<c27h> + 12)] = _s1Uh::P32;
      P32[(young<c27h> + 8)] = _s1Ui::P32;
      call GHC.Real.$w$sreduce_info() returns to c27h, args: 12, res: 8, upd: 4;
  c27h:
      _s1Uk::P32 = R1;
      _s1Ul::P32 = P32[(young<c27h> + 8)];
      _c27w::I32 = _s1T9::I32 - _s1U8::I32;
      _s1Um::I32 = _c27w::I32;
      I32[(old + 16)] = _s1Um::I32;
      P32[(old + 12)] = _s1Uk::P32;
      P32[(old + 8)] = _s1Ul::P32;
      call Main.$wfromRat_info() args: 16, res: 0, upd: 4;
  c24o:
      I32[(young<c233> + 4)] = c233;
      P32[(young<c233> + 8)] = _s1Ta::P32;
      call GHC.Integer.Type.absInteger_info() returns to c233, args: 8, res: 4, upd: 4;
  c233:
      _s1Te::P32 = R1;
      I32[(young<c237> + 4)] = c237;
      P32[(young<c237> + 12)] = _s1Te::P32;
      P32[(young<c237> + 8)] = h_r1Ss_closure;
      call GHC.Integer.Type.gtInteger#_info() returns to c237, args: 12, res: 4, upd: 4;
  c237:
      _s1Tf::I32 = R1;
      if (_s1Tf::I32 >= 1) goto c24G; else goto c24t;
  c24G:
      I32[(young<c24F> + 4)] = c24F;
      P32[(young<c24F> + 12)] = h_r1Ss_closure;
      P32[(young<c24F> + 8)] = lvl_r1Sn_closure+1;
      call GHC.Integer.Type.eqInteger#_info() returns to c24F, args: 12, res: 4, upd: 4;
  c24F:
      _s1TJ::I32 = R1;
      if (_s1TJ::I32 >= 1) goto c27l; else goto c24X;
  c24X:
      I32[(young<c24N> + 4)] = c24N;
      P32[(young<c24N> + 8)] = _s1Ta::P32;
      call GHC.Integer.Type.absInteger_info() returns to c24N, args: 8, res: 4, upd: 4;
  c24N:
      _s1TL::P32 = R1;
      I32[(young<c24R> + 4)] = c24R;
      P32[(young<c24R> + 12)] = _s1TL::P32;
      P32[(young<c24R> + 8)] = h_r1Ss_closure;
      call GHC.Integer.Type.divInteger_info() returns to c24R, args: 12, res: 4, upd: 4;
  c24R:
      _s1TM::P32 = R1;
      I32[(young<c24V> + 4)] = c24V;
      P32[(young<c24V> + 12)] = GHC.Float.$fRealFloatDouble6_closure;
      P32[(young<c24V> + 8)] = _s1TM::P32;
      call $wintegerLogBase_r1So_info() returns to c24V, args: 12, res: 4, upd: 4;
  c24V:
      _s1TN::I32 = R1;
      _c254::I32 = _s1TN::I32 + 1;
      _s1TO::I32 = _c254::I32;
      _c257::I32 = %MO_S_Lt_W32(_s1TO::I32, 0);
      _s1TP::I32 = _c257::I32;
      if (_s1TP::I32 >= 1) goto c27p; else goto c25s;
  c27p:
      R1 = GHC.Real.^3_closure;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  c25s:
      _s1TS::I32 = _s1TO::I32;
      if (_s1TS::I32 != 0) goto c25e; else goto c25f;
  c25e:
      I32[(young<c25n> + 4)] = c25n;
      P32[(young<c25n> + 12)] = GHC.Float.$fRealFloatDouble6_closure;
      I32[(young<c25n> + 8)] = _s1TS::I32;
      call GHC.Real.$wf1_info() returns to c25n, args: 12, res: 4, upd: 4;
  c25f:
      I32[(young<c25n> + 4)] = c25n;
      R1 = GHC.Real.$fEnumRatio1_closure;
      if (R1 & 3 != 0) goto c25n; else goto c25q;
  c25q:
      call (I32[R1])(R1) returns to c25n, args: 4, res: 4, upd: 4;
  c25n:
      _s1TR::P32 = R1;
      goto c25j;
  c25j:
      I32[(young<c25l> + 4)] = c25l;
      P32[(young<c25l> + 12)] = _s1TR::P32;
      P32[(young<c25l> + 8)] = lvl_r1Sn_closure+1;
      call GHC.Integer.Type.eqInteger#_info() returns to c25l, args: 12, res: 4, upd: 4;
  c25l:
      _s1TT::I32 = R1;
      if (_s1TT::I32 >= 1) goto c27l; else goto c25O;
  c27l:
      R1 = GHC.Real.divZeroError_closure;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
  c25O:
      I32[(young<c25A> + 4)] = c25A;
      P32[(young<c25A> + 8)] = _s1Tb::P32;
      call GHC.Integer.Type.absInteger_info() returns to c25A, args: 8, res: 4, upd: 4;
  c25A:
      _s1TY::P32 = R1;
      I32[(young<c25E> + 4)] = c25E;
      P32[(young<c25E> + 8)] = _s1Tb::P32;
      call GHC.Integer.Type.signumInteger_info() returns to c25E, args: 8, res: 4, upd: 4;
  c25E:
      _s1TW::P32 = R1;
      I32[(young<c25I> + 4)] = c25I;
      P32[(young<c25I> + 12)] = _s1Ta::P32;
      P32[(young<c25I> + 8)] = _s1TR::P32;
      call GHC.Integer.Type.divInteger_info() returns to c25I, args: 12, res: 4, upd: 4;
  c25I:
      _s1TV::P32 = R1;
      I32[(young<c25M> + 4)] = c25M;
      P32[(young<c25M> + 12)] = _s1TV::P32;
      P32[(young<c25M> + 8)] = _s1TW::P32;
      call GHC.Integer.Type.timesInteger_info() returns to c25M, args: 12, res: 4, upd: 4;
  c25M:
      _s1TX::P32 = R1;
      I32[(young<c25V> + 4)] = c25V;
      P32[(young<c25V> + 12)] = _s1TX::P32;
      P32[(young<c25V> + 8)] = _s1TY::P32;
      call GHC.Real.$w$sreduce_info() returns to c25V, args: 12, res: 8, upd: 4;
  c25V:
      _s1U0::P32 = R1;
      _s1U1::P32 = P32[(young<c25V> + 8)];
      _c27x::I32 = _s1T9::I32 + _s1TO::I32;
      _s1U2::I32 = _c27x::I32;
      I32[(old + 16)] = _s1U2::I32;
      P32[(old + 12)] = _s1U0::P32;
      P32[(old + 8)] = _s1U1::P32;
      call Main.$wfromRat_info() args: 16, res: 0, upd: 4;
  c24t:
      I32[(young<c23d> + 4)] = c23d;
      P32[(young<c23d> + 12)] = lvl1_r1Sp_closure+1;
      P32[(young<c23d> + 8)] = GHC.Float.$fRealFloatDouble6_closure;
      call GHC.Real.$w$s%_info() returns to c23d, args: 12, res: 8, upd: 4;
  c23d:
      _s1Ti::P32 = R1;
      _s1Tj::P32 = P32[(young<c23d> + 8)];
      I32[(young<c23f> + 4)] = c23f;
      P32[(young<c23f> + 8)] = _s1Ta::P32;
      call GHC.Integer.Type.floatFromInteger_info() returns to c23f, args: 8, res: 4, upd: 4;
  c23f:
      _s1Tk::F32 = F1;
      I32[(young<c23j> + 4)] = c23j;
      P32[(young<c23j> + 8)] = _s1Tb::P32;
      call GHC.Integer.Type.floatFromInteger_info() returns to c23j, args: 8, res: 4, upd: 4;
  c23j:
      _s1Tl::F32 = F1;
      _c23n::F32 = %MO_F_Quot_W32(_s1Tk::F32, _s1Tl::F32);
      _s1Tm::F32 = _c23n::F32;
      I32[(young<c23q> + 4)] = c23q;
      F32[(young<c23q> + 8)] = _s1Tm::F32;
      call stg_decodeFloat_Int#() returns to c23q, args: 8, res: 8, upd: 4;
  c23q:
      _s1To::I32 = R1;
      _s1Tp::I32 = I32[(young<c23q> + 8)];
      goto c23r;
  c23r:
      Hp = Hp + 20;
      if (Hp > HpLim) goto c24z; else goto c24y;
  c24z:
      HpAlloc = 20;
      goto c24x;
  c24x:
      I32[(young<c23s> + 4)] = c23s;
      call stg_gc_noregs() returns to c23s, args: 4, res: 4, upd: 4;
  c23s:
      goto c23r;
  c24y:
      _c23u::P32 = Hp - 15;
      I32[Hp - 16] = $wf_s1Tq_info;
      P32[Hp - 12] = _s1Ta::P32;
      P32[Hp - 8] = _s1Tb::P32;
      P32[Hp - 4] = _s1Ti::P32;
      P32[Hp] = _s1Tj::P32;
      I32[(young<c24r> + 4)] = c24r;
      R1 = _c23u::P32;
      I32[(young<c24r> + 8)] = _s1Tp::I32;
      call $wf_s1Tq_info(R1) returns to c24r, args: 8, res: 4, upd: 4;
  c24r:
      _s1TI::F32 = F1;
      I32[(old + 12)] = _s1T9::I32;
      F32[(old + 8)] = _s1TI::F32;
      call GHC.Float.$w$cscaleFloat1_info() args: 12, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c28Z:
      _r1Sk::P32 = R1;
      goto c28Q;
  c28Q:
      if (Sp - <highSp> < SpLim) goto c290; else goto c291;
  c291:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c293; else goto c292;
  c293:
      HpAlloc = 8;
      goto c290;
  c290:
      R1 = _r1Sk::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c292:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c28S::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r1Sk::P32, Hp - 4);
      if (_c28S::I32 == 0) goto c28U; else goto c28T;
  c28U:
      call (I32[_r1Sk::P32])() args: 4, res: 0, upd: 4;
  c28T:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c28V> + 4)] = c28V;
      F32[(young<c28V> + 8)] = 1.1754943508222875e-38 :: W32;
      call GHC.Float.$w$ctoRational1_info() returns to c28V, args: 8, res: 8, upd: 12;
  c28V:
      _s1Uq::P32 = R1;
      _s1Ur::P32 = P32[(young<c28V> + 8)];
      I32[(young<c28X> + 4)] = c28X;
      I32[(young<c28X> + 16)] = 0;
      P32[(young<c28X> + 12)] = _s1Uq::P32;
      P32[(young<c28X> + 8)] = _s1Ur::P32;
      call Main.$wfromRat_info() returns to c28X, args: 16, res: 4, upd: 12;
  c28X:
      _s1Us::P32 = R1;
      _s1Ut::F32 = F32[_s1Us::P32 + 3];
      _s1Uu::F32 = _s1Ut::F32;
      if (%MO_F_Ne_W32(_s1Uu::F32,
                       1.1754943508222875e-38 :: W32)) goto c29a; else goto c29b;
  c29a:
      R1 = GHC.Show.shows24_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
  c29b:
      R1 = GHC.Show.shows22_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c29r:
      if (Sp - <highSp> < SpLim) goto c29u; else goto c29v;
  c29u:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c29v:
      P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
      P32[(old + 12)] = Main.main2_closure;
      P32[(old + 8)] = GHC.Types.True_closure+2;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c29D:
      if (Sp - <highSp> < SpLim) goto c29G; else goto c29H;
  c29G:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c29H:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c29O:
      if (Sp - <highSp> < SpLim) goto c29R; else goto c29S;
  c29R:
      R1 = Main.main3_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c29S:
      P32[(old + 8)] = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c2a0:
      if (Sp - <highSp> < SpLim) goto c2a3; else goto c2a4;
  c2a3:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c2a4:
      call Main.main3_info() args: 4, res: 0, upd: 4;
}

