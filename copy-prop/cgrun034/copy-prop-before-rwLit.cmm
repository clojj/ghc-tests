==================== Before copy propagation ====================
{offset
  c1Sf:
      _s1Pi::P32 = P32[(old + 12)];
      _s1Pj::P32 = P32[(old + 8)];
      goto c1RC;
  c1RC:
      if (Sp - <highSp> < SpLim) goto c1Sg; else goto c1Sh;
  c1Sg:
      R1 = $wintegerLogBase_r1P9_closure;
      P32[(old + 12)] = _s1Pi::P32;
      P32[(old + 8)] = _s1Pj::P32;
      call (stg_gc_fun)(R1) args: 12, res: 0, upd: 4;
  c1Sh:
      I32[(young<c1RE> + 4)] = c1RE;
      P32[(young<c1RE> + 12)] = _s1Pj::P32;
      P32[(young<c1RE> + 8)] = _s1Pi::P32;
      call GHC.Integer.Type.ltInteger_info() returns to c1RE, args: 12, res: 4, upd: 4;
  c1RE:
      _s1Pk::P32 = R1;
      _c1Sb::P32 = _s1Pk::P32 & 3;
      if (_c1Sb::P32 >= 2) goto c1Sa; else goto c1S9;
  c1Sa:
      R1 = 0;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c1S9:
      I32[(young<c1RI> + 4)] = c1RI;
      P32[(young<c1RI> + 12)] = _s1Pi::P32;
      P32[(young<c1RI> + 8)] = _s1Pi::P32;
      call GHC.Integer.Type.timesInteger_info() returns to c1RI, args: 12, res: 4, upd: 4;
  c1RI:
      _s1Pl::P32 = R1;
      I32[(young<c1RM> + 4)] = c1RM;
      P32[(young<c1RM> + 12)] = _s1Pl::P32;
      P32[(young<c1RM> + 8)] = _s1Pj::P32;
      call $wintegerLogBase_r1P9_info() returns to c1RM, args: 12, res: 4, upd: 4;
  c1RM:
      _s1Pm::I32 = R1;
      _c1RQ::I32 = 2 * _s1Pm::I32;
      _s1Pn::I32 = _c1RQ::I32;
      _c1RT::I32 = %MO_S_Lt_W32(_s1Pn::I32, 0);
      if (_c1RT::I32 >= 1) goto c1Tr; else goto c1Sx;
  c1Tr:
      R1 = GHC.Real.^3_closure;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  c1Sx:
      _s1Pq::I32 = _s1Pn::I32;
      if (_s1Pq::I32 != 0) goto c1Sr; else goto c1Su;
  c1Sr:
      I32[(young<c1Sp> + 4)] = c1Sp;
      P32[(young<c1Sp> + 12)] = _s1Pi::P32;
      I32[(young<c1Sp> + 8)] = _s1Pq::I32;
      call GHC.Real.$wf1_info() returns to c1Sp, args: 12, res: 4, upd: 4;
  c1Su:
      I32[(young<c1Sp> + 4)] = c1Sp;
      R1 = GHC.Real.$fEnumRatio1_closure;
      if (R1 & 3 != 0) goto c1Sp; else goto c1Sv;
  c1Sv:
      call (I32[R1])(R1) returns to c1Sp, args: 4, res: 4, upd: 4;
  c1Sp:
      _s1Pp::P32 = R1;
      goto c1SB;
  c1SB:
      I32[(young<c1SD> + 4)] = c1SD;
      P32[(young<c1SD> + 12)] = _s1Pp::P32;
      P32[(young<c1SD> + 8)] = GHC.Real.even1_closure;
      call GHC.Integer.Type.eqInteger_info() returns to c1SD, args: 12, res: 4, upd: 4;
  c1SD:
      _s1Pr::P32 = R1;
      _c1Tn::P32 = _s1Pr::P32 & 3;
      if (_c1Tn::P32 >= 2) goto c1Tm; else goto c1Te;
  c1Tm:
      R1 = GHC.Real.divZeroError_closure;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
  c1Te:
      I32[(young<c1SK> + 4)] = c1SK;
      P32[(young<c1SK> + 12)] = _s1Pj::P32;
      P32[(young<c1SK> + 8)] = _s1Pp::P32;
      call GHC.Integer.Type.divInteger_info() returns to c1SK, args: 12, res: 4, upd: 4;
  c1SK:
      _s1Py::P32 = R1;
      _s1Pu::I32 = _s1Pn::I32;
      _s1Pt::P32 = _s1Py::P32;
      goto c1SM;
  c1SM:
      I32[(young<c1SP> + 4)] = c1SP;
      P32[(young<c1SP> + 12)] = _s1Pt::P32;
      P32[(young<c1SP> + 8)] = _s1Pi::P32;
      call GHC.Integer.Type.ltInteger_info() returns to c1SP, args: 12, res: 4, upd: 4;
  c1SP:
      _s1Pv::P32 = R1;
      _c1T9::P32 = _s1Pv::P32 & 3;
      if (_c1T9::P32 >= 2) goto c1T8; else goto c1T0;
  c1T8:
      R1 = _s1Pu::I32;
      call (P32[(old + 4)])(R1) args: 4, res: 0, upd: 4;
  c1T0:
      _c1SU::I32 = _s1Pu::I32 + 1;
      _s1Px::I32 = _c1SU::I32;
      I32[(young<c1SX> + 4)] = c1SX;
      P32[(young<c1SX> + 12)] = _s1Pt::P32;
      P32[(young<c1SX> + 8)] = _s1Pi::P32;
      call GHC.Real.$fIntegralInteger_$cdiv_info() returns to c1SX, args: 12, res: 4, upd: 4;
  c1SX:
      _s1Pw::P32 = R1;
      _s1Pu::I32 = _s1Px::I32;
      _s1Pt::P32 = _s1Pw::P32;
      goto c1SM;
}

==================== Before copy propagation ====================
{offset
  c1U4:
      _r1Pb::P32 = R1;
      goto c1TZ;
  c1TZ:
      if (Sp - <highSp> < SpLim) goto c1U5; else goto c1U6;
  c1U6:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c1U8; else goto c1U7;
  c1U8:
      HpAlloc = 8;
      goto c1U5;
  c1U5:
      R1 = _r1Pb::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c1U7:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c1U1::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r1Pb::P32, Hp - 4);
      if (_c1U1::I32 == 0) goto c1U3; else goto c1U2;
  c1U3:
      call (I32[_r1Pb::P32])() args: 4, res: 0, upd: 4;
  c1U2:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 20)] = GHC.Float.$fRealFloatDouble6_closure;
      I32[(old + 16)] = 24;
      call GHC.Real.$wf1_info() args: 20, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c1Uo:
      _r1Pc::P32 = R1;
      goto c1Uj;
  c1Uj:
      if (Sp - <highSp> < SpLim) goto c1Up; else goto c1Uq;
  c1Uq:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c1Us; else goto c1Ur;
  c1Us:
      HpAlloc = 8;
      goto c1Up;
  c1Up:
      R1 = _r1Pc::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c1Ur:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c1Ul::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r1Pc::P32, Hp - 4);
      if (_c1Ul::I32 == 0) goto c1Un; else goto c1Um;
  c1Un:
      call (I32[_r1Pc::P32])() args: 4, res: 0, upd: 4;
  c1Um:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 20)] = lvl1_r1Pb_closure;
      P32[(old + 16)] = lvl_r1Pa_closure+1;
      call GHC.Integer.Type.minusInteger_info() args: 20, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c1VD:
      _r1Pd::P32 = R1;
      goto c1V9;
  c1V9:
      if (Sp - <highSp> < SpLim) goto c1VE; else goto c1VF;
  c1VF:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c1VH; else goto c1VG;
  c1VH:
      HpAlloc = 8;
      goto c1VE;
  c1VE:
      R1 = _r1Pd::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c1VG:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c1Vb::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r1Pd::P32, Hp - 4);
      if (_c1Vb::I32 == 0) goto c1Vd; else goto c1Vc;
  c1Vd:
      call (I32[_r1Pd::P32])() args: 4, res: 0, upd: 4;
  c1Vc:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c1Ve> + 4)] = c1Ve;
      P32[(young<c1Ve> + 12)] = lvl2_r1Pc_closure;
      I32[(young<c1Ve> + 8)] = 104;
      call GHC.Integer.Type.encodeFloatInteger_info() returns to c1Ve, args: 12, res: 4, upd: 12;
  c1Ve:
      _s1PB::F32 = F1;
      _c1Vi::F32 = %MO_F_Neg_W32(_s1PB::F32);
      _s1PC::F32 = _c1Vi::F32;
      I32[(young<c1Vl> + 4)] = c1Vl;
      F32[(young<c1Vl> + 8)] = _s1PC::F32;
      call stg_decodeFloat_Int#() returns to c1Vl, args: 8, res: 8, upd: 12;
  c1Vl:
      _s1PE::I32 = R1;
      _s1PF::I32 = I32[(young<c1Vl> + 8)];
      goto c1Vm;
  c1Vm:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c1VL; else goto c1VK;
  c1VL:
      HpAlloc = 8;
      goto c1VJ;
  c1VJ:
      I32[(young<c1Vn> + 4)] = c1Vn;
      call stg_gc_noregs() returns to c1Vn, args: 4, res: 4, upd: 12;
  c1Vn:
      goto c1Vm;
  c1VK:
      _c1Vp::I32 = %MO_S_Lt_W32(_s1PF::I32, 0);
      if (_c1Vp::I32 >= 1) goto c1Wi; else goto c1VS;
  c1Wi:
      _c1Vt::I32 = -_s1PF::I32;
      _s1PJ::I32 = _c1Vt::I32;
      _c1Vw::I32 = %MO_S_Gt_W32(_s1PJ::I32, 23);
      if (_c1Vw::I32 >= 1) goto c1We; else goto c1W3;
  c1We:
      _c1VA::I32 = %MO_S_Lt_W32(_s1PE::I32, 0);
      if (_c1VA::I32 >= 1) goto c1Wd; else goto c1Wc;
  c1Wd:
      Hp = Hp - 8;
      R1 = lvl_r1Pa_closure+1;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c1Wc:
      I32[Hp - 4] = GHC.Integer.Type.S#_con_info;
      I32[Hp] = 0;
      _c1Wa::P32 = Hp - 3;
      R1 = _c1Wa::P32;
      call (P32[(old + 12)])(R1) args: 12, res: 0, upd: 12;
  c1W3:
      _c1VY::I32 = %MO_S_Shr_W32(_s1PE::I32, _s1PJ::I32);
      _s1PL::I32 = _c1VY::I32;
      Hp = Hp - 8;
      I32[(young<c1W1> + 4)] = c1W1;
      I32[(young<c1W1> + 8)] = _s1PL::I32;
      call GHC.Integer.Type.smallInteger_info() returns to c1W1, args: 8, res: 4, upd: 12;
  c1W1:
      _s1PM::P32 = R1;
      P32[(old + 16)] = _s1PM::P32;
      call GHC.Integer.Type.negateInteger_info() args: 16, res: 0, upd: 12;
  c1VS:
      Hp = Hp - 8;
      I32[(young<c1VM> + 4)] = c1VM;
      I32[(young<c1VM> + 8)] = _s1PE::I32;
      call GHC.Integer.Type.smallInteger_info() returns to c1VM, args: 8, res: 4, upd: 12;
  c1VM:
      _s1PH::P32 = R1;
      I32[(young<c1VQ> + 4)] = c1VQ;
      P32[(young<c1VQ> + 12)] = _s1PH::P32;
      I32[(young<c1VQ> + 8)] = _s1PF::I32;
      call GHC.Integer.Type.shiftLInteger_info() returns to c1VQ, args: 12, res: 4, upd: 12;
  c1VQ:
      _s1PI::P32 = R1;
      P32[(old + 16)] = _s1PI::P32;
      call GHC.Integer.Type.negateInteger_info() args: 16, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c1WI:
      _r1Pe::P32 = R1;
      goto c1WD;
  c1WD:
      if (Sp - <highSp> < SpLim) goto c1WJ; else goto c1WK;
  c1WK:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c1WM; else goto c1WL;
  c1WM:
      HpAlloc = 8;
      goto c1WJ;
  c1WJ:
      R1 = _r1Pe::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c1WL:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c1WF::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r1Pe::P32, Hp - 4);
      if (_c1WF::I32 == 0) goto c1WH; else goto c1WG;
  c1WH:
      call (I32[_r1Pe::P32])() args: 4, res: 0, upd: 4;
  c1WG:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      P32[(old + 20)] = h_r1Pd_closure;
      P32[(old + 16)] = GHC.Real.even1_closure;
      call GHC.Integer.Type.eqInteger_info() args: 20, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c20K:
      _s1Q3::P32 = R1;
      _s1Q4::I32 = I32[(old + 8)];
      goto c20i;
  c20i:
      if (Sp - <highSp> < SpLim) goto c20L; else goto c20M;
  c20M:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c20O; else goto c20N;
  c20O:
      HpAlloc = 8;
      goto c20L;
  c20L:
      R1 = _s1Q3::P32;
      I32[(old + 8)] = _s1Q4::I32;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 4;
  c20N:
      _s1PP::P32 = P32[_s1Q3::P32 + 3];
      _s1PQ::P32 = P32[_s1Q3::P32 + 7];
      _s1PV::P32 = P32[_s1Q3::P32 + 11];
      _s1PW::P32 = P32[_s1Q3::P32 + 15];
      I32[Hp - 4] = GHC.Types.I#_con_info;
      I32[Hp] = _s1Q4::I32;
      _c20k::P32 = Hp - 3;
      I32[(young<c20l> + 4)] = c20l;
      P32[(young<c20l> + 28)] = GHC.Real.$fRealInt_closure;
      P32[(young<c20l> + 24)] = GHC.Real.$fIntegralInt_$cquot_closure+2;
      P32[(young<c20l> + 20)] = GHC.Real.$fIntegralInt_$crem_closure+2;
      P32[(young<c20l> + 16)] = _s1PV::P32;
      P32[(young<c20l> + 12)] = _s1PW::P32;
      P32[(young<c20l> + 8)] = _c20k::P32;
      call GHC.Real.$w^^%^^_info() returns to c20l, args: 28, res: 8, upd: 4;
  c20l:
      _s1Q7::P32 = R1;
      _s1Q8::P32 = P32[(young<c20l> + 8)];
      I32[(young<c20n> + 4)] = c20n;
      P32[(young<c20n> + 12)] = _s1PQ::P32;
      P32[(young<c20n> + 8)] = _s1Q8::P32;
      call GHC.Integer.Type.timesInteger_info() returns to c20n, args: 12, res: 4, upd: 4;
  c20n:
      _s1Qa::P32 = R1;
      I32[(young<c20r> + 4)] = c20r;
      P32[(young<c20r> + 12)] = _s1PP::P32;
      P32[(young<c20r> + 8)] = _s1Q7::P32;
      call GHC.Integer.Type.timesInteger_info() returns to c20r, args: 12, res: 4, upd: 4;
  c20r:
      _s1Q9::P32 = R1;
      I32[(young<c20v> + 4)] = c20v;
      P32[(young<c20v> + 12)] = _s1Q9::P32;
      P32[(young<c20v> + 8)] = _s1Qa::P32;
      call GHC.Real.$w$sreduce_info() returns to c20v, args: 12, res: 8, upd: 4;
  c20v:
      _s1Qc::P32 = R1;
      _s1Qd::P32 = P32[(young<c20v> + 8)];
      I32[(young<c20x> + 4)] = c20x;
      P32[(young<c20x> + 16)] = GHC.Real.$fIntegralInteger_closure;
      P32[(young<c20x> + 12)] = _s1Qc::P32;
      P32[(young<c20x> + 8)] = _s1Qd::P32;
      call GHC.Real.$w$s$cround_info() returns to c20x, args: 16, res: 4, upd: 4;
  c20x:
      _s1Qe::P32 = R1;
      I32[(young<c20B> + 4)] = c20B;
      P32[(young<c20B> + 12)] = _s1Qe::P32;
      I32[(young<c20B> + 8)] = _s1Q4::I32;
      call GHC.Integer.Type.encodeFloatInteger_info() returns to c20B, args: 12, res: 4, upd: 4;
  c20B:
      _s1Qf::F32 = F1;
      I32[(young<c20F> + 4)] = c20F;
      F32[(young<c20F> + 8)] = _s1Qf::F32;
      call stg_decodeFloat_Int#() returns to c20F, args: 8, res: 8, upd: 4;
  c20F:
      _s1Qh::I32 = R1;
      _s1Qi::I32 = I32[(young<c20F> + 8)];
      goto c20G;
  c20G:
      _c20J::I32 = _s1Qi::I32 == _s1Q4::I32;
      if (_c20J::I32 >= 1) goto c20Z; else goto c20Y;
  c20Z:
      F1 = _s1Qf::F32;
      call (P32[(old + 4)])(F1) args: 4, res: 0, upd: 4;
  c20Y:
      R1 = _s1Q3::P32;
      I32[(old + 8)] = _s1Qi::I32;
      call $wf_s1Q3_info(R1) args: 8, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c21a:
      _s1PO::I32 = I32[(old + 16)];
      _s1PP::P32 = P32[(old + 12)];
      _s1PQ::P32 = P32[(old + 8)];
      goto c1XI;
  c1XI:
      if (Sp - <highSp> < SpLim) goto c21b; else goto c21c;
  c21b:
      R1 = Main.$wfromRat_closure;
      I32[(old + 16)] = _s1PO::I32;
      P32[(old + 12)] = _s1PP::P32;
      P32[(old + 8)] = _s1PQ::P32;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 4;
  c21c:
      I32[(young<c1XK> + 4)] = c1XK;
      P32[(young<c1XK> + 12)] = _s1PQ::P32;
      P32[(young<c1XK> + 8)] = h_r1Pd_closure;
      call GHC.Integer.Type.gtInteger_info() returns to c1XK, args: 12, res: 4, upd: 4;
  c1XK:
      _s1PR::P32 = R1;
      _c216::P32 = _s1PR::P32 & 3;
      if (_c216::P32 >= 2) goto c215; else goto c214;
  c215:
      I32[(young<c1Z0> + 4)] = c1Z0;
      P32[(young<c1Z0> + 12)] = _s1PQ::P32;
      P32[(young<c1Z0> + 8)] = h_r1Pd_closure;
      call GHC.Real.$fIntegralInteger_$cdiv_info() returns to c1Z0, args: 12, res: 4, upd: 4;
  c1Z0:
      _s1QF::P32 = R1;
      I32[(young<c1Z4> + 4)] = c1Z4;
      P32[(young<c1Z4> + 12)] = GHC.Float.$fRealFloatDouble6_closure;
      P32[(young<c1Z4> + 8)] = _s1QF::P32;
      call $wintegerLogBase_r1P9_info() returns to c1Z4, args: 12, res: 4, upd: 4;
  c1Z4:
      _s1QG::I32 = R1;
      _c1Z8::I32 = _s1QG::I32 + 1;
      _s1QH::I32 = _c1Z8::I32;
      _c1Zb::I32 = %MO_S_Lt_W32(_s1QH::I32, 0);
      if (_c1Zb::I32 >= 1) goto c23K; else goto c231;
  c231:
      _s1QK::I32 = _s1QH::I32;
      if (_s1QK::I32 != 0) goto c22V; else goto c22Y;
  c22V:
      I32[(young<c22T> + 4)] = c22T;
      P32[(young<c22T> + 12)] = GHC.Float.$fRealFloatDouble6_closure;
      I32[(young<c22T> + 8)] = _s1QK::I32;
      call GHC.Real.$wf1_info() returns to c22T, args: 12, res: 4, upd: 4;
  c22Y:
      I32[(young<c22T> + 4)] = c22T;
      R1 = GHC.Real.$fEnumRatio1_closure;
      if (R1 & 3 != 0) goto c22T; else goto c22Z;
  c22Z:
      call (I32[R1])(R1) returns to c22T, args: 4, res: 4, upd: 4;
  c22T:
      _s1QJ::P32 = R1;
      goto c235;
  c235:
      I32[(young<c237> + 4)] = c237;
      P32[(young<c237> + 12)] = _s1QJ::P32;
      P32[(young<c237> + 8)] = GHC.Real.even1_closure;
      call GHC.Integer.Type.eqInteger_info() returns to c237, args: 12, res: 4, upd: 4;
  c237:
      _s1QL::P32 = R1;
      _c23G::P32 = _s1QL::P32 & 3;
      if (_c23G::P32 >= 2) goto c23F; else goto c23r;
  c23r:
      I32[(young<c23c> + 4)] = c23c;
      P32[(young<c23c> + 12)] = _s1PQ::P32;
      P32[(young<c23c> + 8)] = _s1QJ::P32;
      call GHC.Integer.Type.divInteger_info() returns to c23c, args: 12, res: 4, upd: 4;
  c23c:
      _s1QM::P32 = R1;
      I32[(young<c23g> + 4)] = c23g;
      P32[(young<c23g> + 8)] = _s1QM::P32;
      call GHC.Integer.Type.absInteger_info() returns to c23g, args: 8, res: 4, upd: 4;
  c23g:
      _s1QP::P32 = R1;
      I32[(young<c23k> + 4)] = c23k;
      P32[(young<c23k> + 8)] = _s1QM::P32;
      call GHC.Integer.Type.signumInteger_info() returns to c23k, args: 8, res: 4, upd: 4;
  c23k:
      _s1QN::P32 = R1;
      I32[(young<c23o> + 4)] = c23o;
      P32[(young<c23o> + 12)] = _s1PP::P32;
      P32[(young<c23o> + 8)] = _s1QN::P32;
      call GHC.Integer.Type.timesInteger_info() returns to c23o, args: 12, res: 4, upd: 4;
  c23o:
      _s1QO::P32 = R1;
      I32[(young<c23y> + 4)] = c23y;
      P32[(young<c23y> + 12)] = _s1QO::P32;
      P32[(young<c23y> + 8)] = _s1QP::P32;
      call GHC.Real.$w$sreduce_info() returns to c23y, args: 12, res: 8, upd: 4;
  c23y:
      _s1QR::P32 = R1;
      _s1QS::P32 = P32[(young<c23y> + 8)];
      _c23O::I32 = _s1PO::I32 - _s1QH::I32;
      _s1QT::I32 = _c23O::I32;
      I32[(old + 16)] = _s1QT::I32;
      P32[(old + 12)] = _s1QR::P32;
      P32[(old + 8)] = _s1QS::P32;
      call Main.$wfromRat_info() args: 16, res: 0, upd: 4;
  c214:
      I32[(young<c1XO> + 4)] = c1XO;
      P32[(young<c1XO> + 8)] = _s1PP::P32;
      call GHC.Integer.Type.absInteger_info() returns to c1XO, args: 8, res: 4, upd: 4;
  c1XO:
      _s1PS::P32 = R1;
      I32[(young<c1XS> + 4)] = c1XS;
      P32[(young<c1XS> + 12)] = _s1PS::P32;
      P32[(young<c1XS> + 8)] = h_r1Pd_closure;
      call GHC.Integer.Type.gtInteger_info() returns to c1XS, args: 12, res: 4, upd: 4;
  c1XS:
      _s1PT::P32 = R1;
      _c22I::P32 = _s1PT::P32 & 3;
      if (_c22I::P32 >= 2) goto c21u; else goto c21i;
  c21u:
      I32[(young<c1XX> + 4)] = c1XX;
      R1 = lvl3_r1Pe_closure;
      if (R1 & 3 != 0) goto c1XX; else goto c1XY;
  c1XY:
      call (I32[R1])(R1) returns to c1XX, args: 4, res: 4, upd: 4;
  c1XX:
      _s1Ql::P32 = R1;
      _c22E::P32 = _s1Ql::P32 & 3;
      if (_c22E::P32 >= 2) goto c23F; else goto c21x;
  c21x:
      I32[(young<c1Y2> + 4)] = c1Y2;
      P32[(young<c1Y2> + 8)] = _s1PP::P32;
      call GHC.Integer.Type.absInteger_info() returns to c1Y2, args: 8, res: 4, upd: 4;
  c1Y2:
      _s1Qm::P32 = R1;
      I32[(young<c1Y6> + 4)] = c1Y6;
      P32[(young<c1Y6> + 12)] = _s1Qm::P32;
      P32[(young<c1Y6> + 8)] = h_r1Pd_closure;
      call GHC.Integer.Type.divInteger_info() returns to c1Y6, args: 12, res: 4, upd: 4;
  c1Y6:
      _s1Qn::P32 = R1;
      I32[(young<c1Ya> + 4)] = c1Ya;
      P32[(young<c1Ya> + 12)] = GHC.Float.$fRealFloatDouble6_closure;
      P32[(young<c1Ya> + 8)] = _s1Qn::P32;
      call $wintegerLogBase_r1P9_info() returns to c1Ya, args: 12, res: 4, upd: 4;
  c1Ya:
      _s1Qo::I32 = R1;
      _c1Ye::I32 = _s1Qo::I32 + 1;
      _s1Qp::I32 = _c1Ye::I32;
      _c1Yh::I32 = %MO_S_Lt_W32(_s1Qp::I32, 0);
      if (_c1Yh::I32 >= 1) goto c23K; else goto c21N;
  c23K:
      R1 = GHC.Real.^3_closure;
      call (I32[R1])(R1) args: 4, res: 0, upd: 4;
  c21N:
      _s1Qs::I32 = _s1Qp::I32;
      if (_s1Qs::I32 != 0) goto c21H; else goto c21K;
  c21H:
      I32[(young<c21F> + 4)] = c21F;
      P32[(young<c21F> + 12)] = GHC.Float.$fRealFloatDouble6_closure;
      I32[(young<c21F> + 8)] = _s1Qs::I32;
      call GHC.Real.$wf1_info() returns to c21F, args: 12, res: 4, upd: 4;
  c21K:
      I32[(young<c21F> + 4)] = c21F;
      R1 = GHC.Real.$fEnumRatio1_closure;
      if (R1 & 3 != 0) goto c21F; else goto c21L;
  c21L:
      call (I32[R1])(R1) returns to c21F, args: 4, res: 4, upd: 4;
  c21F:
      _s1Qr::P32 = R1;
      goto c21R;
  c21R:
      I32[(young<c21T> + 4)] = c21T;
      P32[(young<c21T> + 12)] = _s1Qr::P32;
      P32[(young<c21T> + 8)] = GHC.Real.even1_closure;
      call GHC.Integer.Type.eqInteger_info() returns to c21T, args: 12, res: 4, upd: 4;
  c21T:
      _s1Qt::P32 = R1;
      _c22s::P32 = _s1Qt::P32 & 3;
      if (_c22s::P32 >= 2) goto c23F; else goto c22d;
  c23F:
      R1 = GHC.Real.divZeroError_closure;
      call stg_ap_0_fast(R1) args: 4, res: 0, upd: 4;
  c22d:
      I32[(young<c21Y> + 4)] = c21Y;
      P32[(young<c21Y> + 8)] = _s1PQ::P32;
      call GHC.Integer.Type.absInteger_info() returns to c21Y, args: 8, res: 4, upd: 4;
  c21Y:
      _s1Qx::P32 = R1;
      I32[(young<c222> + 4)] = c222;
      P32[(young<c222> + 8)] = _s1PQ::P32;
      call GHC.Integer.Type.signumInteger_info() returns to c222, args: 8, res: 4, upd: 4;
  c222:
      _s1Qv::P32 = R1;
      I32[(young<c226> + 4)] = c226;
      P32[(young<c226> + 12)] = _s1PP::P32;
      P32[(young<c226> + 8)] = _s1Qr::P32;
      call GHC.Integer.Type.divInteger_info() returns to c226, args: 12, res: 4, upd: 4;
  c226:
      _s1Qu::P32 = R1;
      I32[(young<c22a> + 4)] = c22a;
      P32[(young<c22a> + 12)] = _s1Qu::P32;
      P32[(young<c22a> + 8)] = _s1Qv::P32;
      call GHC.Integer.Type.timesInteger_info() returns to c22a, args: 12, res: 4, upd: 4;
  c22a:
      _s1Qw::P32 = R1;
      I32[(young<c22k> + 4)] = c22k;
      P32[(young<c22k> + 12)] = _s1Qw::P32;
      P32[(young<c22k> + 8)] = _s1Qx::P32;
      call GHC.Real.$w$sreduce_info() returns to c22k, args: 12, res: 8, upd: 4;
  c22k:
      _s1Qz::P32 = R1;
      _s1QA::P32 = P32[(young<c22k> + 8)];
      _c23P::I32 = _s1PO::I32 + _s1Qp::I32;
      _s1QB::I32 = _c23P::I32;
      I32[(old + 16)] = _s1QB::I32;
      P32[(old + 12)] = _s1Qz::P32;
      P32[(old + 8)] = _s1QA::P32;
      call Main.$wfromRat_info() args: 16, res: 0, upd: 4;
  c21i:
      I32[(young<c1ZZ> + 4)] = c1ZZ;
      P32[(young<c1ZZ> + 12)] = lvl_r1Pa_closure+1;
      P32[(young<c1ZZ> + 8)] = GHC.Float.$fRealFloatDouble6_closure;
      call GHC.Real.$w$s%_info() returns to c1ZZ, args: 12, res: 8, upd: 4;
  c1ZZ:
      _s1PV::P32 = R1;
      _s1PW::P32 = P32[(young<c1ZZ> + 8)];
      I32[(young<c201> + 4)] = c201;
      P32[(young<c201> + 8)] = _s1PP::P32;
      call GHC.Integer.Type.floatFromInteger_info() returns to c201, args: 8, res: 4, upd: 4;
  c201:
      _s1PX::F32 = F1;
      I32[(young<c205> + 4)] = c205;
      P32[(young<c205> + 8)] = _s1PQ::P32;
      call GHC.Integer.Type.floatFromInteger_info() returns to c205, args: 8, res: 4, upd: 4;
  c205:
      _s1PY::F32 = F1;
      _c209::F32 = %MO_F_Quot_W32(_s1PX::F32, _s1PY::F32);
      _s1PZ::F32 = _c209::F32;
      I32[(young<c20c> + 4)] = c20c;
      F32[(young<c20c> + 8)] = _s1PZ::F32;
      call stg_decodeFloat_Int#() returns to c20c, args: 8, res: 8, upd: 4;
  c20c:
      _s1Q1::I32 = R1;
      _s1Q2::I32 = I32[(young<c20c> + 8)];
      goto c20d;
  c20d:
      Hp = Hp + 20;
      if (Hp > HpLim) goto c21o; else goto c21n;
  c21o:
      HpAlloc = 20;
      goto c21m;
  c21m:
      I32[(young<c20e> + 4)] = c20e;
      call stg_gc_noregs() returns to c20e, args: 4, res: 4, upd: 4;
  c20e:
      goto c20d;
  c21n:
      _c20g::P32 = Hp - 15;
      I32[Hp - 16] = $wf_s1Q3_info;
      P32[Hp - 12] = _s1PP::P32;
      P32[Hp - 8] = _s1PQ::P32;
      P32[Hp - 4] = _s1PV::P32;
      P32[Hp] = _s1PW::P32;
      I32[(young<c21f> + 4)] = c21f;
      R1 = _c20g::P32;
      I32[(young<c21f> + 8)] = _s1Q2::I32;
      call $wf_s1Q3_info(R1) returns to c21f, args: 8, res: 4, upd: 4;
  c21f:
      _s1Qk::F32 = F1;
      I32[(old + 12)] = _s1PO::I32;
      F32[(old + 8)] = _s1Qk::F32;
      call GHC.Float.$w$cscaleFloat1_info() args: 12, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c25u:
      _r1P6::P32 = R1;
      goto c25l;
  c25l:
      if (Sp - <highSp> < SpLim) goto c25v; else goto c25w;
  c25w:
      Hp = Hp + 8;
      if (Hp > HpLim) goto c25y; else goto c25x;
  c25y:
      HpAlloc = 8;
      goto c25v;
  c25v:
      R1 = _r1P6::P32;
      call (stg_gc_enter_1)(R1) args: 4, res: 0, upd: 4;
  c25x:
      I32[Hp - 4] = stg_CAF_BLACKHOLE_info;
      I32[Hp] = CurrentTSO;
      (_c25n::I32) = call "ccall" arg hints:  [PtrHint, PtrHint,
                                               PtrHint]  result hints:  [] newCAF(BaseReg, _r1P6::P32, Hp - 4);
      if (_c25n::I32 == 0) goto c25p; else goto c25o;
  c25p:
      call (I32[_r1P6::P32])() args: 4, res: 0, upd: 4;
  c25o:
      I32[(old + 12)] = stg_bh_upd_frame_info;
      P32[(old + 8)] = Hp - 4;
      I32[(young<c25q> + 4)] = c25q;
      F32[(young<c25q> + 8)] = 1.1754943508222875e-38 :: W32;
      call GHC.Float.$w$ctoRational1_info() returns to c25q, args: 8, res: 8, upd: 12;
  c25q:
      _s1QX::P32 = R1;
      _s1QY::P32 = P32[(young<c25q> + 8)];
      I32[(young<c25s> + 4)] = c25s;
      I32[(young<c25s> + 16)] = 0;
      P32[(young<c25s> + 12)] = _s1QX::P32;
      P32[(young<c25s> + 8)] = _s1QY::P32;
      call Main.$wfromRat_info() returns to c25s, args: 16, res: 4, upd: 12;
  c25s:
      _s1QZ::P32 = R1;
      _s1R0::F32 = F32[_s1QZ::P32 + 3];
      _s1R1::F32 = _s1R0::F32;
      if (%MO_F_Ne_W32(_s1R1::F32,
                       1.1754943508222875e-38 :: W32)) goto c25F; else goto c25G;
  c25F:
      R1 = GHC.Show.shows24_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
  c25G:
      R1 = GHC.Show.shows22_closure;
      call (I32[R1])(R1) args: 12, res: 0, upd: 12;
}

==================== Before copy propagation ====================
{offset
  c25W:
      if (Sp - <highSp> < SpLim) goto c25Z; else goto c260;
  c25Z:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c260:
      P32[(old + 16)] = GHC.IO.Handle.FD.stdout_closure;
      P32[(old + 12)] = Main.main2_closure;
      P32[(old + 8)] = GHC.Types.True_closure+2;
      call GHC.IO.Handle.Text.hPutStr2_info() args: 16, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c268:
      if (Sp - <highSp> < SpLim) goto c26b; else goto c26c;
  c26b:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c26c:
      call Main.main1_info() args: 4, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c26j:
      if (Sp - <highSp> < SpLim) goto c26m; else goto c26n;
  c26m:
      R1 = Main.main3_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c26n:
      P32[(old + 8)] = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info() args: 8, res: 0, upd: 4;
}

==================== Before copy propagation ====================
{offset
  c26v:
      if (Sp - <highSp> < SpLim) goto c26y; else goto c26z;
  c26y:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 4, res: 0, upd: 4;
  c26z:
      call Main.main3_info() args: 4, res: 0, upd: 4;
}

